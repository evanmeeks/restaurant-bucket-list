--- Folder Structure ---
.env
.env.example
.eslintrc.js
.prettierrc
[docs]
    ├── .project_structure_ignore
    └── project_structure.txt
package.json
[packages]
    ├── [constants]
        └── categories.ts
    ├── [core]
        ├── package.json
        ├── [src]
            ├── [api]
                └── foursquare.ts
            ├── [hooks]
                └── useGeolocation.ts
            ├── index.ts
            ├── [models]
                ├── app-state.ts
                ├── bucket-list.ts
                ├── index.ts
                ├── user.ts
                └── venue.ts
            ├── [store]
                ├── index.ts
                ├── [sagas]
                    ├── authSaga.ts
                    ├── bucketListSaga.ts
                    ├── locationSaga.ts
                    └── venuesSaga.ts
                └── [slices]
                    ├── authSlice.ts
                    ├── bucketListSlice.ts
                    ├── uiSlice.ts
                    └── venuesSlice.ts
            └── [utils]
        └── tsconfig.json
    ├── [mobile]
        ├── App.tsx
        ├── app.json
        ├── [constants]
            └── categories.ts
        ├── index.js
        ├── package.json
        ├── [src]
            ├── [components]
                ├── [common]
                    ├── BucketListScreen.tsx
                    ├── CategoryCard.tsx
                    ├── HomeScreen.tsx
                    ├── LocationPermissionRequest.tsx
                    ├── ProfileScreen.tsx
                    ├── RestaurantCard copy.tsx
                    ├── RestaurantCard.tsx
                    └── SearchScreen.tsx
                └── [screens]
                    ├── AddToBucketListScreen.tsx
                    ├── AuthScreen.tsx
                    ├── BucketListItemEditScreen.tsx
                    ├── BucketListScreen copy.tsx
                    ├── BucketListScreen.tsx
                    ├── DetailsScreen.tsx
                    ├── ExploreScreen.tsx
                    ├── HomeScreen.tsx
                    ├── OnBoardingScreen.tsx
                    ├── ProfileScreen copy.tsx
                    ├── ProfileScreen.tsx
                    ├── SearchScreen copy.tsx
                    ├── SearchScreen.tsx
                    ├── SettingsScreen.tsx
                    └── VenueDetailsScreen.tsx
            ├── [navigation]
                ├── LocationPermissionRequest.tsx
                ├── MainNavigator.tsx
                └── types.ts
            ├── [theme]
                ├── categories.ts
                └── index.ts
            └── [utils]
                ├── distanceUtils.ts
                └── imageUtils.ts
        ├── [theme]
            ├── categories.ts
            └── index.ts
        └── tsconfig.json
    └── [web]
        ├── package.json
        ├── [public]
        ├── [src]
            ├── App.tsx
            ├── [components]
                ├── [common]
                └── [pages]
                    └── HomePage.tsx
            ├── index.tsx
            ├── [routes]
            ├── [theme]
            └── [utils]
        └── tsconfig.json
tsconfig.json

--- File Contents ---

--- File: .env ---
# API Keys
FOURSQUARE_API_KEY=fsq3qBKJqJ2IpGLto+Kqe6ei5IIN6IG/5ty45BfAFK8WCAU=

# Firebase Config
FIREBASE_API_KEY=your_firebase_api_key_here
FIREBASE_AUTH_DOMAIN=your_firebase_auth_domain_here
FIREBASE_PROJECT_ID=your_firebase_project_id_here
FIREBASE_STORAGE_BUCKET=your_firebase_storage_bucket_here
FIREBASE_MESSAGING_SENDER_ID=your_firebase_messaging_sender_id_here
FIREBASE_APP_ID=your_firebase_app_id_here

# Environment
NODE_ENV=development
API_URL=https://api.foursquare.com/v3

# App Config
APP_NAME=Restaurant Bucket List
DEFAULT_LOCATION_LATITUDE=37.7749
DEFAULT_LOCATION_LONGITUDE=-122.4194


--- File: .env.example ---
# API Keys
FOURSQUARE_API_KEY=fsq3qBKJqJ2IpGLto+Kqe6ei5IIN6IG/5ty45BfAFK8WCAU=

# Firebase Config
FIREBASE_API_KEY=your_firebase_api_key_here
FIREBASE_AUTH_DOMAIN=your_firebase_auth_domain_here
FIREBASE_PROJECT_ID=your_firebase_project_id_here
FIREBASE_STORAGE_BUCKET=your_firebase_storage_bucket_here
FIREBASE_MESSAGING_SENDER_ID=your_firebase_messaging_sender_id_here
FIREBASE_APP_ID=your_firebase_app_id_here

# Environment
NODE_ENV=development
API_URL=https://api.foursquare.com/v3

# App Config
APP_NAME=Restaurant Bucket List
DEFAULT_LOCATION_LATITUDE=37.7749
DEFAULT_LOCATION_LONGITUDE=-122.4194


--- File: .eslintrc.js ---
module.exports = {
  root: true,
  extends: [
    'eslint:recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:import/recommended',
    'plugin:import/typescript',
    'plugin:jsx-a11y/recommended',
    'prettier',
  ],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaFeatures: {
      jsx: true,
    },
    ecmaVersion: 2021,
    sourceType: 'module',
  },
  plugins: ['react', 'react-hooks', '@typescript-eslint', 'prettier', 'import', 'jsx-a11y'],
  rules: {
    'prettier/prettier': 'error',
    'react/react-in-jsx-scope': 'off',
    'react/prop-types': 'off',
    'no-console': ['warn', { allow: ['warn', 'error'] }],
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
    'import/no-unresolved': 'error',
    'import/order': [
      'error',
      {
        groups: ['builtin', 'external', 'internal', 'parent', 'sibling', 'index'],
        'newlines-between': 'always',
        alphabetize: { order: 'asc', caseInsensitive: true },
      },
    ],
    'jsx-a11y/anchor-is-valid': 'warn',
  },
  settings: {
    react: {
      version: 'detect',
    },
    'import/resolver': {
      typescript: {
        alwaysTryTypes: true,
        project: [
          './tsconfig.json',
          './packages/*/tsconfig.json',
        ],
      },
      node: {
        extensions: ['.js', '.jsx', '.ts', '.tsx'],
      },
    },
  },
  env: {
    browser: true,
    node: true,
    es6: true,
    jest: true,
  },
};


--- File: .prettierrc ---
{
  "semi": true,
  "tabWidth": 2,
  "printWidth": 100,
  "singleQuote": true,
  "trailingComma": "es5",
  "bracketSpacing": true,
  "jsxBracketSameLine": false,
  "arrowParens": "avoid",
  "endOfLine": "lf"
}


--- File: docs/.project_structure_ignore ---
.gitignore
node_modules
.expo
.git
ios
android
yarn.lock
yarn.\*
assets
.DS_Store


--- File: docs/project_structure.txt ---
--- Folder Structure ---
.eslintrc.js
.prettierrc
[docs]
    ├── .project_structure_ignore
    └── project_structure.txt
package.json
[packages]
    ├── [core]
        ├── package.json
        ├── [src]
            ├── [api]
                └── foursquare.ts
            ├── [hooks]
                └── useGeolocation.ts
            ├── index.ts
            ├── [models]
                ├── app-state.ts
                ├── bucket-list.ts
                ├── index.ts
                ├── user.ts
                └── venue.ts
            ├── [store]
                ├── index.ts
                ├── [sagas]
                    ├── authSaga.ts
                    ├── bucketListSaga.ts
                    ├── locationSaga.ts
                    └── venuesSaga.ts
                └── [slices]
                    ├── authSlice copy.ts
                    ├── authSlice.ts
                    ├── bucketListSlice.ts
                    ├── uiSlice copy.ts
                    ├── uiSlice.ts
                    └── venuesSlice.ts
            └── [utils]
        └── tsconfig.json
    ├── [mobile]
        ├── App.tsx
        ├── app.json
        ├── index.js
        ├── package.json
        ├── [src]
            ├── [components]
                ├── [common]
                └── [screens]
                    ├── AddToBucketListScreen.tsx
                    ├── AuthScreen.tsx
                    ├── BucketListItemEditScreen.tsx
                    ├── BucketListScreen copy.tsx
                    ├── BucketListScreen.tsx
                    ├── DetailsScreen.tsx
                    ├── ExploreScreen.tsx
                    ├── HomeScreen.tsx
                    ├── OnBoardingScreen.tsx
                    ├── ProfileScreen copy.tsx
                    ├── ProfileScreen.tsx
                    ├── SearchScreen copy.tsx
                    ├── SearchScreen.tsx
                    ├── SettingsScreen.tsx
                    └── VenueDetailsScreen.tsx
            ├── [navigation]
                ├── LocationPermissionRequest.tsx
                ├── MainNavigator.tsx
                └── types.ts
            ├── [theme]
                ├── categories.ts
                └── index.ts
            └── [utils]
        └── tsconfig.json
    └── [web]
        ├── package.json
        ├── [public]
        ├── [src]
            ├── App.tsx
            ├── [components]
                ├── [common]
                └── [pages]
                    └── HomePage.tsx
            ├── index.tsx
            ├── [routes]
            ├── [theme]
            └── [utils]
        └── tsconfig.json
tsconfig.json

--- File Contents ---

--- File: .eslintrc.js ---
module.exports = {
  root: true,
  extends: [
    'eslint:recommended',
    'plugin:react/recommended',
    'plugin:react-hooks/recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:import/recommended',
    'plugin:import/typescript',
    'plugin:jsx-a11y/recommended',
    'prettier',
  ],
  parser: '@typescript-eslint/parser',
  parserOptions: {
    ecmaFeatures: {
      jsx: true,
    },
    ecmaVersion: 2021,
    sourceType: 'module',
  },
  plugins: ['react', 'react-hooks', '@typescript-eslint', 'prettier', 'import', 'jsx-a11y'],
  rules: {
    'prettier/prettier': 'error',
    'react/react-in-jsx-scope': 'off',
    'react/prop-types': 'off',
    'no-console': ['warn', { allow: ['warn', 'error'] }],
    '@typescript-eslint/explicit-module-boundary-types': 'off',
    '@typescript-eslint/no-explicit-any': 'warn',
    '@typescript-eslint/no-unused-vars': ['error', { argsIgnorePattern: '^_' }],
    'import/no-unresolved': 'error',
    'import/order': [
      'error',
      {
        groups: ['builtin', 'external', 'internal', 'parent', 'sibling', 'index'],
        'newlines-between': 'always',
        alphabetize: { order: 'asc', caseInsensitive: true },
      },
    ],
    'jsx-a11y/anchor-is-valid': 'warn',
  },
  settings: {
    react: {
      version: 'detect',
    },
    'import/resolver': {
      typescript: {
        alwaysTryTypes: true,
        project: [
          './tsconfig.json',
          './packages/*/tsconfig.json',
        ],
      },
      node: {
        extensions: ['.js', '.jsx', '.ts', '.tsx'],
      },
    },
  },
  env: {
    browser: true,
    node: true,
    es6: true,
    jest: true,
  },
};


--- File: .prettierrc ---
{
  "semi": true,
  "tabWidth": 2,
  "printWidth": 100,
  "singleQuote": true,
  "trailingComma": "es5",
  "bracketSpacing": true,
  "jsxBracketSameLine": false,
  "arrowParens": "avoid",
  "endOfLine": "lf"
}


--- File: docs/.project_structure_ignore ---
.gitignore
node_modules
.expo
.git
ios
android
yarn.lock
yarn.\*
assets
.DS_Store


--- File: docs/project_structure.txt ---


--- File: package.json ---
{
  "name": "restaurant-bucket-list",
  "version": "1.0.0",
  "description": "A cross-platform application to discover, save, and track restaurants you want to visit",
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "start": "yarn workspaces run start",
    "build": "yarn workspaces run build",
    "test": "yarn workspaces run test",
    "lint": "yarn workspaces run lint",
    "clean": "yarn workspaces run clean",
    "web:start": "yarn workspace web start",
    "mobile:start": "yarn workspace mobile start",
    "ios": "yarn workspace mobile ios",
    "android": "yarn workspace mobile android",
    "ios:pod-install": "cd packages/mobile/ios && pod install"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/your-username/restaurant-bucket-list.git"
  },
  "keywords": [
    "react",
    "react-native",
    "redux",
    "redux-saga",
    "typescript",
    "monorepo",
    "foursquare",
    "geolocation"
  ],
  "author": "Your Name",
  "license": "MIT",
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^5.59.0",
    "@typescript-eslint/parser": "^5.59.0",
    "eslint": "^8.38.0",
    "eslint-config-prettier": "^8.8.0",
    "eslint-plugin-import": "^2.27.5",
    "eslint-plugin-jsx-a11y": "^6.7.1",
    "eslint-plugin-prettier": "^4.2.1",
    "eslint-plugin-react": "^7.32.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "husky": "^8.0.3",
    "lint-staged": "^13.2.1",
    "prettier": "^2.8.7",
    "typescript": "^5.0.4"
  }
}


--- File: packages/core/package.json ---
{
  "name": "core",
  "version": "1.0.0",
  "description": "Shared business logic and models for Restaurant Bucket List app",
  "main": "src/index.ts",
  "private": true,
  "scripts": {
    "build": "tsc",
    "clean": "rimraf ./dist",
    "test": "jest",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@reduxjs/toolkit": "^1.9.5",
    "axios": "^1.4.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-redux": "^8.0.5",
    "redux": "^4.2.1",
    "redux-persist": "^6.0.0",
    "redux-saga": "^1.2.3"
  },
  "devDependencies": {
    "@testing-library/react-hooks": "^8.0.1",
    "@types/jest": "^29.5.1",
    "@types/node": "^18.16.3",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.1",
    "jest": "^29.5.0",
    "rimraf": "^5.0.0",
    "ts-jest": "^29.1.0",
    "typescript": "^5.0.4"
  },
  "peerDependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  }
}


--- File: packages/core/src/api/foursquare.ts ---
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import { 
  VenueSearchParams, 
  VenueSearchResponse, 
  VenueDetailsResponse,
  Coordinates
} from '../models/venue';

/**
 * Foursquare API service using modern patterns:
 * - TypeScript for type safety
 * - Axios for HTTP requests
 * - Environment variables for configuration
 * - Proper error handling
 * - Clean abstraction
 */
export class FoursquareService {
  private client: AxiosInstance;
  private static instance: FoursquareService;
  
  private constructor() {
    // Create axios instance with base configuration
    this.client = axios.create({
      baseURL: 'https://api.foursquare.com/v3',
      headers: {
        'Accept': 'application/json',
        'Authorization': `${process.env.FOURSQUARE_API_KEY}`
      }
    });
    
    // Add request interceptor for logging and modifying requests
    this.client.interceptors.request.use(
      (config) => {
        // Add any request modification here
        return config;
      },
      (error) => {
        return Promise.reject(error);
      }
    );
    
    // Add response interceptor for error handling
    this.client.interceptors.response.use(
      (response) => {
        return response;
      },
      (error) => {
        // Enhanced error handling
        if (error.response) {
          // Server responded with error status
          console.error('API Error:', error.response.status, error.response.data);
        } else if (error.request) {
          // Request made but no response received
          console.error('Network Error:', error.request);
        } else {
          // Error in setting up request
          console.error('Request Error:', error.message);
        }
        return Promise.reject(error);
      }
    );
  }
  
  /**
   * Get singleton instance of the service
   */
  public static getInstance(): FoursquareService {
    if (!FoursquareService.instance) {
      FoursquareService.instance = new FoursquareService();
    }
    return FoursquareService.instance;
  }
  
  /**
   * Search for venues near the specified location
   */
  public async searchVenues(params: VenueSearchParams): Promise<VenueSearchResponse> {
    try {
      const response = await this.client.get('/places/search', {
        params: {
          ...params,
          limit: params.limit || 20,
          sort: params.sort || 'DISTANCE'
        }
      });
      return response.data;
    } catch (error) {
      console.error('Failed to search venues:', error);
      throw error;
    }
  }
  
  /**
   * Get venue details by ID
   */
  public async getVenueDetails(venueId: string): Promise<VenueDetailsResponse> {
    try {
      const response = await this.client.get(`/places/${venueId}`);
      return response.data;
    } catch (error) {
      console.error(`Failed to get venue details for ID ${venueId}:`, error);
      throw error;
    }
  }
  
  /**
   * Search venues near the user's current location
   */
  public async searchNearbyVenues(
    coordinates: Coordinates,
    query?: string,
    categories?: string[],
    radius: number = 1000,
    limit: number = 20
  ): Promise<VenueSearchResponse> {
    const params: VenueSearchParams = {
      ll: `${coordinates.latitude},${coordinates.longitude}`,
      radius,
      limit
    };
    
    if (query) {
      params.query = query;
    }
    
    if (categories && categories.length > 0) {
      params.categories = categories.join(',');
    }
    
    return this.searchVenues(params);
  }
  
  /**
   * Get recommended venues near the specified location
   */
  public async getRecommendedVenues(
    coordinates: Coordinates,
    limit: number = 10
  ): Promise<VenueSearchResponse> {
    return this.searchVenues({
      ll: `${coordinates.latitude},${coordinates.longitude}`,
      limit,
      sort: 'RATING'
    });
  }
}

// Export a singleton instance
export const foursquareService = FoursquareService.getInstance();


--- File: packages/core/src/hooks/useGeolocation.ts ---
import { useEffect, useState, useCallback } from 'react';
import { useAppDispatch, useAppSelector } from '../store';
import { 
  getUserLocation, 
  setLocationPermission 
} from '../store/slices/venuesSlice';
import { Coordinates } from '../models/venue';

interface GeolocationHook {
  coordinates: Coordinates | null;
  loading: boolean;
  error: string | null;
  permissionGranted: boolean;
  requestLocation: () => void;
}

/**
 * Custom hook for getting and tracking user location
 */
export const useGeolocation = (): GeolocationHook => {
  const dispatch = useAppDispatch();
  const coordinates = useAppSelector(state => state.venues.userLocation);
  const permissionGranted = useAppSelector(state => state.venues.locationPermissionGranted);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  // Request location permissions and get location
  const requestLocation = useCallback(() => {
    setLoading(true);
    setError(null);
    dispatch(getUserLocation());
  }, [dispatch]);

  // Check for location permissions on mount
  useEffect(() => {
    // Check if geolocation is available
    if (!navigator.geolocation) {
      setError('Geolocation is not supported by your browser');
      return;
    }

    // Check permission status if available
    if (navigator.permissions && navigator.permissions.query) {
      navigator.permissions
        .query({ name: 'geolocation' as PermissionName })
        .then(result => {
          if (result.state === 'granted') {
            dispatch(setLocationPermission(true));
            requestLocation();
          } else if (result.state === 'prompt') {
            // We'll wait for user to explicitly request location
            dispatch(setLocationPermission(false));
          } else if (result.state === 'denied') {
            dispatch(setLocationPermission(false));
            setError('Location permission denied');
          }

          // Listen for permission changes
          result.addEventListener('change', () => {
            dispatch(setLocationPermission(result.state === 'granted'));
            
            if (result.state === 'granted') {
              requestLocation();
            }
          });
        })
        .catch(err => {
          console.error('Error checking geolocation permission:', err);
        });
    }
  }, [dispatch, requestLocation]);

  // Update loading state when coordinates change
  useEffect(() => {
    if (coordinates) {
      setLoading(false);
    }
  }, [coordinates]);

  return {
    coordinates,
    loading,
    error,
    permissionGranted,
    requestLocation
  };
};


--- File: packages/core/src/index.ts ---
// Export models
export * from './models/venue';
export * from './models/bucket-list';
export * from './models/user';
export * from './models/app-state';

// Export API services
export * from './api/foursquare';

// Export hooks
export * from './hooks/useGeolocation';

// Export store
export * from './store';
export * from './store/slices/venuesSlice';
export * from './store/slices/bucketListSlice';
export * from './store/slices/authSlice';
export * from './store/slices/uiSlice';


--- File: packages/core/src/models/app-state.ts ---
/**
 * Global application state
 */
export interface AppState {
  auth: AuthState;
  ui: UIState;
}

/**
 * Authentication state
 */
export interface AuthState {
  isAuthenticated: boolean;
  user: UserProfile | null;
  loading: boolean;
  error: string | null;
}

/**
 * User profile information
 */
export interface UserProfile {
  id: string;
  email: string;
  displayName?: string;
  photoUrl?: string;
}

/**
 * UI state
 */
export interface UIState {
  theme: 'light' | 'dark';
  networkStatus: 'online' | 'offline';
  hasCompletedOnboarding: boolean;
}


--- File: packages/core/src/models/bucket-list.ts ---
import { Venue } from './venue';

/**
 * User-specific bucket list item with additional metadata
 */
export interface BucketListItem {
  id: string;
  venueId: string;
  venue: Venue;
  userId: string;
  notes?: string;
  tags?: string[];
  priority?: 'low' | 'medium' | 'high';
  addedAt: number;
  plannedVisitDate?: number;
  visitedAt?: number;
  rating?: number;
  review?: string;
}

/**
 * Filter options for bucket list
 */
export interface BucketListFilter {
  tags?: string[];
  priority?: ('low' | 'medium' | 'high')[];
  visited?: boolean;
  searchTerm?: string;
  sortBy?: 'dateAdded' | 'name' | 'priority' | 'plannedDate';
  sortDirection?: 'asc' | 'desc';
}


--- File: packages/core/src/models/index.ts ---
export * from './app-state';
export * from './bucket-list';
export * from './user';
export * from './venue';


--- File: packages/core/src/models/user.ts ---
/**
 * User profile information
 */
export interface UserProfile {
  id: string;
  email: string;
  displayName?: string;
  photoUrl?: string;
  createdAt: number;
  lastLogin: number;
  preferences?: UserPreferences;
}

/**
 * User preferences
 */
export interface UserPreferences {
  darkMode?: boolean;
  defaultRadius?: number;
  defaultCategories?: string[];
  emailNotifications?: boolean;
  pushNotifications?: boolean;
}


--- File: packages/core/src/models/venue.ts ---
/**
 * Geographical coordinates
 */
export interface Coordinates {
  latitude: number;
  longitude: number;
}

/**
 * Parameters for venue search API
 */
export interface VenueSearchParams {
  // Required: Latitude and longitude
  ll: string;
  
  // Optional parameters
  query?: string;
  categories?: string;
  radius?: number;
  limit?: number;
  sort?: 'DISTANCE' | 'POPULARITY' | 'RATING';
  fields?: string[];
}

/**
 * Venue location information
 */
export interface VenueLocation {
  address?: string;
  city?: string;
  state?: string;
  country?: string;
  postalCode?: string;
  neighborhood?: string[];
  formattedAddress?: string;
  crossStreet?: string;
  lat: number;
  lng: number;
}

/**
 * Venue category
 */
export interface VenueCategory {
  id: string;
  name: string;
  icon: {
    prefix: string;
    suffix: string;
  };
  primary?: boolean;
}

/**
 * Venue hours
 */
export interface VenueHours {
  status?: string;
  isOpen?: boolean;
  openNow?: boolean;
  displayHours?: string[];
  regularHours?: {
    days: string;
    open: {
      start: string;
      end: string;
    }[];
  }[];
}

/**
 * Venue photo
 */
export interface VenuePhoto {
  id: string;
  prefix: string;
  suffix: string;
  width: number;
  height: number;
}

/**
 * Venue rating
 */
export interface VenueRating {
  rating: number;
  ratingColor: string;
  ratingSignals: number;
}

/**
 * Venue price information
 */
export interface VenuePrice {
  tier: number; // 1, 2, 3, or 4
  message: string; // "$", "$$", "$$$", "$$$$"
  currency?: string;
}

/**
 * Venue contact information
 */
export interface VenueContact {
  phone?: string;
  formattedPhone?: string;
  twitter?: string;
  instagram?: string;
  facebook?: string;
  email?: string;
  url?: string;
}

/**
 * Menu information
 */
export interface VenueMenu {
  url: string;
  mobileUrl: string;
  type: string;
  label: string;
}

/**
 * A venue/place from Foursquare API
 */
export interface Venue {
  id: string;
  name: string;
  location: VenueLocation;
  categories: VenueCategory[];
  photos?: VenuePhoto[];
  rating?: number;
  ratingColor?: string;
  price?: VenuePrice;
  hours?: VenueHours;
  contact?: VenueContact;
  description?: string;
  url?: string;
  menu?: VenueMenu;
  createdAt?: number;
  verified?: boolean;
  stats?: {
    tipCount: number;
    usersCount: number;
    checkinsCount: number;
  };
  likes?: {
    count: number;
    summary: string;
  };
  listed?: {
    count: number;
    groups: any[];
  };
  phrases?: {
    phrase: string;
    count: number;
  }[];
  attributes?: {
    groups: {
      type: string;
      name: string;
      summary: string;
      items: {
        displayName: string;
        displayValue: string;
      }[];
    }[];
  };
  distances?: number;
}

/**
 * Response from venue search API
 */
export interface VenueSearchResponse {
  results: Venue[];
  context: {
    geoBounds: {
      circle: {
        center: {
          latitude: number;
          longitude: number;
        };
        radius: number;
      };
    };
  };
  totalResults: number;
}

/**
 * Response from venue details API
 */
export interface VenueDetailsResponse {
  venue: Venue;
}


--- File: packages/core/src/store/index.ts ---
import { configureStore, combineReducers, getDefaultMiddleware } from '@reduxjs/toolkit';
import createSagaMiddleware from 'redux-saga';
import { all } from 'redux-saga/effects';
import { persistStore, persistReducer } from 'redux-persist';
import storage from 'redux-persist/lib/storage';

// Import reducers
import authReducer from './slices/authSlice';
import uiReducer from './slices/uiSlice';

// Configure redux-persist
const persistConfig = {
  key: 'root',
  storage,
  whitelist: ['auth', 'ui'], // Only persist these reducers
};

// Combine all reducers
const rootReducer = {
  auth: authReducer,
  ui: uiReducer,
};

// Root saga
function* rootSaga() {
  yield all([
    // Add sagas here
  ]);
}

// Setup saga middleware
const sagaMiddleware = createSagaMiddleware();

// Create persisted reducer
const persistedReducer = persistReducer(persistConfig, combineReducers(rootReducer));

// Configure store with middleware
export const store = configureStore({
  reducer: persistedReducer,
  middleware: [...getDefaultMiddleware({
    serializableCheck: {
      ignoredActions: ['persist/PERSIST'],
    },
    thunk: false,
  }), sagaMiddleware],
  devTools: process.env.NODE_ENV !== 'production',
});

// Run saga middleware
sagaMiddleware.run(rootSaga);

// Create persistor
export const persistor = persistStore(store);

// Export types
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// Create typed hooks for use in components
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;


--- File: packages/core/src/store/sagas/authSaga.ts ---
import { call, put, takeLatest } from 'redux-saga/effects';
import { PayloadAction } from '@reduxjs/toolkit';
import {
  login,
  loginSuccess,
  loginFailure,
  register,
  registerSuccess,
  registerFailure,
  logout,
  logoutSuccess,
  logoutFailure,
  resetPassword,
  resetPasswordSuccess,
  resetPasswordFailure,
  updateProfile,
  updateProfileSuccess,
  updateProfileFailure,
  socialLogin,
} from '../slices/authSlice';
import { UserProfile } from '../../models/user';

// Firebase service would be imported here
// import { firebaseService } from '../../api/firebase';

// This is a placeholder function for Firebase auth service
// In a real application, this would interact with Firebase Authentication
const signInWithEmailAndPassword = async (email: string, password: string): Promise<UserProfile> => {
  // Simulate API call
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Mock successful login
  const user: UserProfile = {
    id: 'user123',
    email,
    displayName: 'John Doe',
    photoUrl: 'https://example.com/profile.jpg',
    createdAt: Date.now() - 1000 * 60 * 60 * 24 * 30, // 30 days ago
    lastLogin: Date.now(),
  };
  
  return user;
};

// Placeholder for creating user with email and password
const createUserWithEmailAndPassword = async (
  email: string,
  password: string,
  displayName?: string
): Promise<UserProfile> => {
  // Simulate API call
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Mock successful registration
  const user: UserProfile = {
    id: 'user123',
    email,
    displayName: displayName || email.split('@')[0],
    createdAt: Date.now(),
    lastLogin: Date.now(),
  };
  
  return user;
};

// Placeholder for social auth
const signInWithProvider = async (provider: 'google' | 'apple' | 'facebook'): Promise<UserProfile> => {
  // Simulate API call
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Mock successful login
  const user: UserProfile = {
    id: 'user123',
    email: 'user@example.com',
    displayName: 'John Doe',
    photoUrl: 'https://example.com/profile.jpg',
    createdAt: Date.now() - 1000 * 60 * 60 * 24 * 30, // 30 days ago
    lastLogin: Date.now(),
  };
  
  return user;
};

// Placeholder for updating user profile
const updateUserProfile = async (
  userId: string,
  updates: Partial<UserProfile>
): Promise<UserProfile> => {
  // Simulate API call
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Mock successful update
  const user: UserProfile = {
    id: userId,
    email: 'user@example.com',
    displayName: updates.displayName || 'John Doe',
    photoUrl: updates.photoUrl || 'https://example.com/profile.jpg',
    createdAt: Date.now() - 1000 * 60 * 60 * 24 * 30, // 30 days ago
    lastLogin: Date.now(),
    preferences: updates.preferences,
  };
  
  return user;
};

// Placeholder for signing out
const signOut = async (): Promise<void> => {
  // Simulate API call
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // No return value needed for sign out
};

// Placeholder for sending password reset email
const sendPasswordResetEmail = async (email: string): Promise<void> => {
  // Simulate API call
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // No return value needed for password reset
};

// Handle login saga
function* handleLogin(action: PayloadAction<{ email: string; password: string }>) {
  try {
    const { email, password } = action.payload;
    const user: UserProfile = yield call(signInWithEmailAndPassword, email, password);
    
    // Login successful
    yield put(loginSuccess(user));
  } catch (error) {
    // Login failed
    yield put(loginFailure(error.message || 'Login failed'));
  }
}

// Handle social login saga
function* handleSocialLogin(action: PayloadAction<{ provider: 'google' | 'apple' | 'facebook' }>) {
  try {
    const { provider } = action.payload;
    const user: UserProfile = yield call(signInWithProvider, provider);
    
    // Login successful
    yield put(loginSuccess(user));
  } catch (error) {
    // Login failed
    yield put(loginFailure(error.message || 'Social login failed'));
  }
}

// Handle registration saga
function* handleRegister(
  action: PayloadAction<{ email: string; password: string; displayName?: string }>
) {
  try {
    const { email, password, displayName } = action.payload;
    const user: UserProfile = yield call(
      createUserWithEmailAndPassword,
      email,
      password,
      displayName
    );
    
    // Registration successful
    yield put(registerSuccess(user));
  } catch (error) {
    // Registration failed
    yield put(registerFailure(error.message || 'Registration failed'));
  }
}

// Handle logout saga
function* handleLogout() {
  try {
    yield call(signOut);
    
    // Logout successful
    yield put(logoutSuccess());
  } catch (error) {
    // Logout failed
    yield put(logoutFailure(error.message || 'Logout failed'));
  }
}

// Handle update profile saga
function* handleUpdateProfile(action: PayloadAction<Partial<UserProfile>>) {
  try {
    const userId = 'user123'; // In a real app, this would come from the state or auth service
    const updatedUser: UserProfile = yield call(updateUserProfile, userId, action.payload);
    
    // Update successful
    yield put(updateProfileSuccess(updatedUser));
  } catch (error) {
    // Update failed
    yield put(updateProfileFailure(error.message || 'Update profile failed'));
  }
}

// Handle reset password saga
function* handleResetPassword(action: PayloadAction<{ email: string }>) {
  try {
    const { email } = action.payload;
    yield call(sendPasswordResetEmail, email);
    
    // Reset password email sent successfully
    yield put(resetPasswordSuccess());
  } catch (error) {
    // Reset password failed
    yield put(resetPasswordFailure(error.message || 'Reset password failed'));
  }
}

// Watch for auth actions
export function* watchAuth() {
  yield takeLatest(login.type, handleLogin);
  yield takeLatest(socialLogin.type, handleSocialLogin);
  yield takeLatest(register.type, handleRegister);
  yield takeLatest(logout.type, handleLogout);
  yield takeLatest(updateProfile.type, handleUpdateProfile);
  yield takeLatest(resetPassword.type, handleResetPassword);
}


--- File: packages/core/src/store/sagas/bucketListSaga.ts ---
import { call, put, takeLatest, select } from 'redux-saga/effects';
import { PayloadAction } from '@reduxjs/toolkit';
import { 
  fetchBucketList,
  fetchBucketListSuccess,
  fetchBucketListFailure,
  addToBucketList,
  addToBucketListSuccess,
  addToBucketListFailure,
  updateBucketListItem,
  updateBucketListItemSuccess,
  updateBucketListItemFailure,
  removeFromBucketList,
  removeFromBucketListSuccess,
  removeFromBucketListFailure,
  markAsVisited,
  markAsVisitedSuccess,
  markAsVisitedFailure
} from '../slices/bucketListSlice';
import { selectVenue } from '../slices/venuesSlice';
import { BucketListItem } from '../../models/bucket-list';
import { RootState } from '../index';
import { Venue } from '../../models/venue';
import { foursquareService } from '../../api/foursquare';

// Helper function to get user ID from state
const getUserId = (state: RootState) => state.auth.user?.id;

// Handle fetch bucket list
function* handleFetchBucketList() {
  try {
    const userId = yield select(getUserId);
    
    if (!userId) {
      throw new Error('User not authenticated');
    }
    
    // Call API to get user's bucket list
    // In a real app, this would be a call to your backend API
    // or a service like Firebase
    const items = yield call(fetchBucketListFromFirebase, userId);
    
    // Enhance items with venue details if needed
    const enhancedItems = yield call(enhanceBucketListWithVenueDetails, items);
    
    // Handle success
    yield put(fetchBucketListSuccess(enhancedItems));
  } catch (error) {
    console.error('Failed to fetch bucket list:', error);
    yield put(fetchBucketListFailure(error.message || 'Failed to fetch bucket list'));
  }
}

// Mock function to fetch bucket list from Firebase or backend
// This would be replaced with actual Firebase calls
function fetchBucketListFromFirebase(userId: string): Promise<BucketListItem[]> {
  // In a real implementation, this would be:
  // return firebaseService.getBucketList(userId);
  
  // For now, return mock data
  return Promise.resolve([]);
}

// Helper function to enhance bucket list items with venue details
function* enhanceBucketListWithVenueDetails(items: BucketListItem[]): Generator<any, BucketListItem[], any> {
  // For each item, ensure we have complete venue details
  const enhancedItems = [];
  
  for (const item of items) {
    // If venue is missing or incomplete, fetch venue details
    if (!item.venue || Object.keys(item.venue).length === 0) {
      try {
        const response = yield call(
          foursquareService.getVenueDetails.bind(foursquareService),
          item.venueId
        );
        
        enhancedItems.push({
          ...item,
          venue: response.venue
        });
      } catch (error) {
        console.error(`Failed to fetch venue details for ${item.venueId}:`, error);
        // Still include the item even without venue details
        enhancedItems.push(item);
      }
    } else {
      enhancedItems.push(item);
    }
  }
  
  return enhancedItems;
}

// Handle add to bucket list
function* handleAddToBucketList(action: PayloadAction<{
  venueId: string;
  notes?: string;
  tags?: string[];
  priority?: 'low' | 'medium' | 'high';
}>) {
  try {
    const userId = yield select(getUserId);
    
    if (!userId) {
      throw new Error('User not authenticated');
    }
    
    const { venueId, notes, tags, priority } = action.payload;
    
    // Get venue details if not already in state
    let venue: Venue;
    const state: RootState = yield select();
    
    // Check if venue is in state
    const venueInState = 
      state.venues.nearby.venues.find(v => v.id === venueId) ||
      state.venues.recommended.venues.find(v => v.id === venueId) ||
      state.venues.search.venues.find(v => v.id === venueId) ||
      (state.venues.selectedVenue?.id === venueId ? state.venues.selectedVenue : undefined);
      
    if (venueInState) {
      venue = venueInState;
    } else {
      // Fetch venue details from API
      const response = yield call(
        foursquareService.getVenueDetails.bind(foursquareService),
        venueId
      );
      venue = response.venue;
      
      // Also update selected venue in state
      yield put(selectVenue(venueId));
    }
    
    // Create bucket list item
    const newItem: BucketListItem = {
      id: `${userId}_${venueId}_${Date.now()}`, // Generate a unique ID
      venueId,
      venue,
      userId,
      notes,
      tags,
      priority,
      addedAt: Date.now()
    };
    
    // Save to Firebase or backend
    yield call(saveBucketListItemToFirebase, newItem);
    
    // Handle success
    yield put(addToBucketListSuccess(newItem));
  } catch (error) {
    console.error('Failed to add to bucket list:', error);
    yield put(addToBucketListFailure(error.message || 'Failed to add to bucket list'));
  }
}

// Mock function to save bucket list item to Firebase or backend
function saveBucketListItemToFirebase(item: BucketListItem): Promise<void> {
  // In a real implementation, this would be:
  // return firebaseService.saveBucketListItem(item);
  
  // For now, just return a resolved promise
  return Promise.resolve();
}

// Handle update bucket list item
function* handleUpdateBucketListItem(action: PayloadAction<{
  id: string;
  updates: Partial<BucketListItem>;
}>) {
  try {
    const userId = yield select(getUserId);
    
    if (!userId) {
      throw new Error('User not authenticated');
    }
    
    const { id, updates } = action.payload;
    
    // Get current item from state
    const state: RootState = yield select();
    const currentItem = state.bucketList.items.find(item => item.id === id);
    
    if (!currentItem) {
      throw new Error('Item not found');
    }
    
    // Create updated item
    const updatedItem: BucketListItem = {
      ...currentItem,
      ...updates
    };
    
    // Save to Firebase or backend
    yield call(updateBucketListItemInFirebase, updatedItem);
    
    // Handle success
    yield put(updateBucketListItemSuccess(updatedItem));
  } catch (error) {
    console.error('Failed to update bucket list item:', error);
    yield put(updateBucketListItemFailure(error.message || 'Failed to update bucket list item'));
  }
}

// Mock function to update bucket list item in Firebase or backend
function updateBucketListItemInFirebase(item: BucketListItem): Promise<void> {
  // In a real implementation, this would be:
  // return firebaseService.updateBucketListItem(item);
  
  // For now, just return a resolved promise
  return Promise.resolve();
}

// Handle remove from bucket list
function* handleRemoveFromBucketList(action: PayloadAction<string>) {
  try {
    const userId = yield select(getUserId);
    
    if (!userId) {
      throw new Error('User not authenticated');
    }
    
    const itemId = action.payload;
    
    // Delete from Firebase or backend
    yield call(deleteBucketListItemFromFirebase, itemId);
    
    // Handle success
    yield put(removeFromBucketListSuccess(itemId));
  } catch (error) {
    console.error('Failed to remove from bucket list:', error);
    yield put(removeFromBucketListFailure(error.message || 'Failed to remove from bucket list'));
  }
}

// Mock function to delete bucket list item from Firebase or backend
function deleteBucketListItemFromFirebase(itemId: string): Promise<void> {
  // In a real implementation, this would be:
  // return firebaseService.deleteBucketListItem(itemId);
  
  // For now, just return a resolved promise
  return Promise.resolve();
}

// Handle mark as visited
function* handleMarkAsVisited(action: PayloadAction<{
  id: string;
  rating?: number;
  review?: string;
}>) {
  try {
    const userId = yield select(getUserId);
    
    if (!userId) {
      throw new Error('User not authenticated');
    }
    
    const { id, rating, review } = action.payload;
    
    // Get current item from state
    const state: RootState = yield select();
    const currentItem = state.bucketList.items.find(item => item.id === id);
    
    if (!currentItem) {
      throw new Error('Item not found');
    }
    
    // Create updated item
    const updatedItem: BucketListItem = {
      ...currentItem,
      visitedAt: Date.now(),
      rating,
      review
    };
    
    // Save to Firebase or backend
    yield call(updateBucketListItemInFirebase, updatedItem);
    
    // Handle success
    yield put(markAsVisitedSuccess(updatedItem));
  } catch (error) {
    console.error('Failed to mark as visited:', error);
    yield put(markAsVisitedFailure(error.message || 'Failed to mark as visited'));
  }
}

// Watch for bucket list actions
export function* watchBucketList() {
  yield takeLatest(fetchBucketList.type, handleFetchBucketList);
  yield takeLatest(addToBucketList.type, handleAddToBucketList);
  yield takeLatest(updateBucketListItem.type, handleUpdateBucketListItem);
  yield takeLatest(removeFromBucketList.type, handleRemoveFromBucketList);
  yield takeLatest(markAsVisited.type, handleMarkAsVisited);
}


--- File: packages/core/src/store/sagas/locationSaga.ts ---
import { 
  takeLatest, 
  call, 
  put, 
  spawn,
  take, 
  cancel, 
  fork,
  cancelled,
  delay
} from 'redux-saga/effects';
import { eventChannel, END } from 'redux-saga';
import { 
  getUserLocation, 
  setUserLocation, 
  locationError,
  setLocationPermission
} from '../slices/venuesSlice';
import { Coordinates } from '../../models/venue';

// Create a channel to handle watch position
function createLocationChannel() {
  return eventChannel(emitter => {
    // Watch position and emit location updates
    const watchId = navigator.geolocation.watchPosition(
      (position) => {
        const { latitude, longitude } = position.coords;
        emitter({ latitude, longitude });
      },
      (error) => {
        emitter(END);
        console.error('Geolocation error:', error);
      },
      {
        enableHighAccuracy: true,
        timeout: 20000,
        maximumAge: 1000,
        distanceFilter: 10 // Minimum distance (meters) between updates
      }
    );

    // Return unsubscribe function
    return () => {
      navigator.geolocation.clearWatch(watchId);
    };
  });
}

// Get current position once
function* getCurrentPosition() {
  try {
    const position = yield call(
      () => 
        new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(
            resolve,
            reject,
            {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 1000
            }
          );
        })
    );
    
    const coordinates: Coordinates = {
      latitude: position.coords.latitude,
      longitude: position.coords.longitude
    };
    
    yield put(setUserLocation(coordinates));
    yield put(setLocationPermission(true));
    
    return coordinates;
  } catch (error) {
    console.error('Error getting current position:', error);
    yield put(locationError(error.message));
    
    if (error.code === 1) {
      // Permission denied
      yield put(setLocationPermission(false));
    }
    
    return null;
  }
}

// Watch for location updates
function* watchLocationUpdates() {
  try {
    const channel = yield call(createLocationChannel);
    
    // Process location updates
    while (true) {
      try {
        const coordinates = yield take(channel);
        yield put(setUserLocation(coordinates));
      } catch (error) {
        console.error('Error in location channel:', error);
        yield put(locationError(error.message));
      }
    }
  } catch (error) {
    console.error('Error creating location channel:', error);
    yield put(locationError(error.message));
  } finally {
    if (yield cancelled()) {
      console.log('Location watching cancelled');
    }
  }
}

// Handle get user location action
function* handleGetUserLocation() {
  // First get current position
  const coordinates = yield call(getCurrentPosition);
  
  // If successful, start watching for updates
  if (coordinates) {
    // Start watching location in background
    const watchTask = yield fork(watchLocationUpdates);
    
    // Automatically cancel the watch after 30 minutes
    // to conserve battery (can be adjusted based on requirements)
    yield spawn(function* () {
      yield delay(30 * 60 * 1000); // 30 minutes
      yield cancel(watchTask);
    });
  }
}

// Watch for location actions
export function* watchLocation() {
  yield takeLatest(getUserLocation.type, handleGetUserLocation);
}


--- File: packages/core/src/store/sagas/venuesSaga.ts ---
import { call, put, takeLatest, select } from 'redux-saga/effects';
import { PayloadAction } from '@reduxjs/toolkit';
import { foursquareService } from '../../api/foursquare';
import { 
  fetchNearbyVenues,
  fetchNearbyVenuesSuccess,
  fetchNearbyVenuesFailure,
  fetchRecommendedVenues,
  fetchRecommendedVenuesSuccess,
  fetchRecommendedVenuesFailure,
  searchVenues,
  searchVenuesSuccess,
  searchVenuesFailure,
  selectVenue,
  setSelectedVenue,
} from '../slices/venuesSlice';
import { Coordinates, Venue } from '../../models/venue';
import { RootState } from '../index';

// Handle fetch nearby venues
function* handleFetchNearbyVenues(action: PayloadAction<{
  coordinates: Coordinates;
  radius?: number;
  categories?: string[];
}>) {
  try {
    const { coordinates, radius = 1000, categories } = action.payload;
    
    // Call API
    const response = yield call(
      foursquareService.searchNearbyVenues.bind(foursquareService),
      coordinates,
      undefined, // No query for nearby venues
      categories,
      radius
    );
    
    // Handle success
    yield put(fetchNearbyVenuesSuccess(response.results));
  } catch (error) {
    console.error('Failed to fetch nearby venues:', error);
    yield put(fetchNearbyVenuesFailure(error.message || 'Failed to fetch nearby venues'));
  }
}

// Handle fetch recommended venues
function* handleFetchRecommendedVenues(action: PayloadAction<{
  coordinates: Coordinates;
  limit?: number;
}>) {
  try {
    const { coordinates, limit = 10 } = action.payload;
    
    // Call API
    const response = yield call(
      foursquareService.getRecommendedVenues.bind(foursquareService),
      coordinates,
      limit
    );
    
    // Handle success
    yield put(fetchRecommendedVenuesSuccess(response.results));
  } catch (error) {
    console.error('Failed to fetch recommended venues:', error);
    yield put(fetchRecommendedVenuesFailure(error.message || 'Failed to fetch recommended venues'));
  }
}

// Handle search venues
function* handleSearchVenues(action: PayloadAction<{
  coordinates: Coordinates;
  query: string;
  categories?: string[];
  radius?: number;
}>) {
  try {
    const { coordinates, query, categories, radius = 2000 } = action.payload;
    
    // Call API
    const response = yield call(
      foursquareService.searchNearbyVenues.bind(foursquareService),
      coordinates,
      query,
      categories,
      radius
    );
    
    // Handle success
    yield put(searchVenuesSuccess(response.results));
  } catch (error) {
    console.error('Failed to search venues:', error);
    yield put(searchVenuesFailure(error.message || 'Failed to search venues'));
  }
}

// Handle select venue
function* handleSelectVenue(action: PayloadAction<string>) {
  try {
    const venueId = action.payload;
    
    // Check if venue is already in state
    const state: RootState = yield select();
    let venue: Venue | undefined;
    
    // Look for venue in all lists
    venue = state.venues.nearby.venues.find(v => v.id === venueId);
    if (!venue) venue = state.venues.recommended.venues.find(v => v.id === venueId);
    if (!venue) venue = state.venues.search.venues.find(v => v.id === venueId);
    
    if (venue) {
      // If venue is already in state, use it
      yield put(setSelectedVenue(venue));
    } else {
      // Otherwise fetch from API
      const response = yield call(
        foursquareService.getVenueDetails.bind(foursquareService),
        venueId
      );
      
      // Handle success
      yield put(setSelectedVenue(response.venue));
    }
  } catch (error) {
    console.error('Failed to get venue details:', error);
    // Note: We don't have a specific failure action for this case
    // Could add one if needed
  }
}

// Watch for venue actions
export function* watchVenues() {
  yield takeLatest(fetchNearbyVenues.type, handleFetchNearbyVenues);
  yield takeLatest(fetchRecommendedVenues.type, handleFetchRecommendedVenues);
  yield takeLatest(searchVenues.type, handleSearchVenues);
  yield takeLatest(selectVenue.type, handleSelectVenue);
}


--- File: packages/core/src/store/slices/authSlice copy.ts ---
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { AuthState, UserProfile } from '../../models/app-state';

const initialState: AuthState = {
  isAuthenticated: false,
  user: null,
  loading: false,
  error: null,
};

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    // Login actions
    login: (state, action: PayloadAction<{ email: string; password: string }>) => {
      state.loading = true;
      state.error = null;
    },
    loginSuccess: (state, action: PayloadAction<UserProfile>) => {
      state.isAuthenticated = true;
      state.user = action.payload;
      state.loading = false;
      state.error = null;
    },
    loginFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Social login actions
    socialLogin: (state, action: PayloadAction<{ provider: 'google' | 'apple' | 'facebook' }>) => {
      state.loading = true;
      state.error = null;
    },
    
    // Register actions
    register: (
      state,
      action: PayloadAction<{ email: string; password: string; displayName?: string }>
    ) => {
      state.loading = true;
      state.error = null;
    },
    registerSuccess: (state, action: PayloadAction<UserProfile>) => {
      state.isAuthenticated = true;
      state.user = action.payload;
      state.loading = false;
      state.error = null;
    },
    registerFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Logout action
    logout: state => {
      state.loading = true;
    },
    logoutSuccess: state => {
      state.isAuthenticated = false;
      state.user = null;
      state.loading = false;
      state.error = null;
    },
    logoutFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Update profile actions
    updateProfile: (state, action: PayloadAction<Partial<UserProfile>>) => {
      state.loading = true;
      state.error = null;
    },
    updateProfileSuccess: (state, action: PayloadAction<UserProfile>) => {
      state.user = action.payload;
      state.loading = false;
      state.error = null;
    },
    updateProfileFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Reset password actions
    resetPassword: (state, action: PayloadAction<{ email: string }>) => {
      state.loading = true;
      state.error = null;
    },
    resetPasswordSuccess: state => {
      state.loading = false;
      state.error = null;
    },
    resetPasswordFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Clear error
    clearError: state => {
      state.error = null;
    },
  },
});

export const {
  login,
  loginSuccess,
  loginFailure,
  socialLogin,
  register,
  registerSuccess,
  registerFailure,
  logout,
  logoutSuccess,
  logoutFailure,
  updateProfile,
  updateProfileSuccess,
  updateProfileFailure,
  resetPassword,
  resetPasswordSuccess,
  resetPasswordFailure,
  clearError,
} = authSlice.actions;

export default authSlice.reducer;


--- File: packages/core/src/store/slices/authSlice.ts ---
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { AuthState, UserProfile } from '../../models/app-state';

const initialState: AuthState = {
  isAuthenticated: false,
  user: null,
  loading: false,
  error: null,
};

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    // Login actions
    login: (state, action: PayloadAction<{ email: string; password: string }>) => {
      state.loading = true;
      state.error = null;
    },
    loginSuccess: (state, action: PayloadAction<UserProfile>) => {
      state.isAuthenticated = true;
      state.user = action.payload;
      state.loading = false;
      state.error = null;
    },
    loginFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Logout action
    logout: state => {
      state.loading = true;
    },
    logoutSuccess: state => {
      state.isAuthenticated = false;
      state.user = null;
      state.loading = false;
      state.error = null;
    },
    logoutFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Clear error
    clearError: state => {
      state.error = null;
    },
  },
});

export const {
  login,
  loginSuccess,
  loginFailure,
  logout,
  logoutSuccess,
  logoutFailure,
  clearError,
} = authSlice.actions;

export default authSlice.reducer;


--- File: packages/core/src/store/slices/bucketListSlice.ts ---
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { BucketListState, BucketListItem, BucketListFilter } from '../../models/bucket-list';

const initialState: BucketListState = {
  items: [],
  filteredItems: [],
  filters: {},
  loading: false,
  error: null,
};

const bucketListSlice = createSlice({
  name: 'bucketList',
  initialState,
  reducers: {
    // Fetch bucket list actions
    fetchBucketList: (state) => {
      state.loading = true;
      state.error = null;
    },
    fetchBucketListSuccess: (state, action: PayloadAction<BucketListItem[]>) => {
      state.items = action.payload;
      state.filteredItems = applyFilters(action.payload, state.filters);
      state.loading = false;
    },
    fetchBucketListFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Add to bucket list actions
    addToBucketList: (state, action: PayloadAction<{
      venueId: string;
      notes?: string;
      tags?: string[];
      priority?: 'low' | 'medium' | 'high';
    }>) => {
      state.loading = true;
      state.error = null;
    },
    addToBucketListSuccess: (state, action: PayloadAction<BucketListItem>) => {
      state.items.push(action.payload);
      state.filteredItems = applyFilters(state.items, state.filters);
      state.loading = false;
    },
    addToBucketListFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Update bucket list item actions
    updateBucketListItem: (state, action: PayloadAction<{
      id: string;
      updates: Partial<BucketListItem>;
    }>) => {
      state.loading = true;
      state.error = null;
    },
    updateBucketListItemSuccess: (state, action: PayloadAction<BucketListItem>) => {
      const index = state.items.findIndex(item => item.id === action.payload.id);
      if (index !== -1) {
        state.items[index] = action.payload;
      }
      state.filteredItems = applyFilters(state.items, state.filters);
      state.loading = false;
    },
    updateBucketListItemFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Remove from bucket list actions
    removeFromBucketList: (state, action: PayloadAction<string>) => {
      state.loading = true;
      state.error = null;
    },
    removeFromBucketListSuccess: (state, action: PayloadAction<string>) => {
      state.items = state.items.filter(item => item.id !== action.payload);
      state.filteredItems = applyFilters(state.items, state.filters);
      state.loading = false;
    },
    removeFromBucketListFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Mark as visited actions
    markAsVisited: (state, action: PayloadAction<{
      id: string;
      rating?: number;
      review?: string;
    }>) => {
      state.loading = true;
      state.error = null;
    },
    markAsVisitedSuccess: (state, action: PayloadAction<BucketListItem>) => {
      const index = state.items.findIndex(item => item.id === action.payload.id);
      if (index !== -1) {
        state.items[index] = action.payload;
      }
      state.filteredItems = applyFilters(state.items, state.filters);
      state.loading = false;
    },
    markAsVisitedFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Filter actions
    setFilters: (state, action: PayloadAction<BucketListFilter>) => {
      state.filters = action.payload;
      state.filteredItems = applyFilters(state.items, action.payload);
    },
    clearFilters: (state) => {
      state.filters = {};
      state.filteredItems = state.items;
    },
  },
});

// Helper function to apply filters
const applyFilters = (items: BucketListItem[], filters: BucketListFilter): BucketListItem[] => {
  let result = [...items];
  
  // Filter by tags
  if (filters.tags && filters.tags.length > 0) {
    result = result.filter(item => 
      item.tags && item.tags.some(tag => filters.tags!.includes(tag))
    );
  }
  
  // Filter by priority
  if (filters.priority && filters.priority.length > 0) {
    result = result.filter(item => 
      item.priority && filters.priority!.includes(item.priority)
    );
  }
  
  // Filter by visited status
  if (filters.visited !== undefined) {
    result = result.filter(item => 
      filters.visited ? !!item.visitedAt : !item.visitedAt
    );
  }
  
  // Filter by search term
  if (filters.searchTerm) {
    const term = filters.searchTerm.toLowerCase();
    result = result.filter(item => 
      item.venue.name.toLowerCase().includes(term) || 
      (item.notes && item.notes.toLowerCase().includes(term))
    );
  }
  
  // Sort results
  if (filters.sortBy) {
    result.sort((a, b) => {
      let comparison = 0;
      
      switch (filters.sortBy) {
        case 'dateAdded':
          comparison = a.addedAt - b.addedAt;
          break;
        case 'name':
          comparison = a.venue.name.localeCompare(b.venue.name);
          break;
        case 'priority':
          const priorityOrder = { high: 0, medium: 1, low: 2 };
          const aPriority = a.priority ? priorityOrder[a.priority] : 3;
          const bPriority = b.priority ? priorityOrder[b.priority] : 3;
          comparison = aPriority - bPriority;
          break;
        case 'plannedDate':
          const aDate = a.plannedVisitDate || Number.MAX_SAFE_INTEGER;
          const bDate = b.plannedVisitDate || Number.MAX_SAFE_INTEGER;
          comparison = aDate - bDate;
          break;
        default:
          break;
      }
      
      // Apply sort direction
      return filters.sortDirection === 'desc' ? -comparison : comparison;
    });
  }
  
  return result;
};

// Export actions
export const {
  fetchBucketList,
  fetchBucketListSuccess,
  fetchBucketListFailure,
  addToBucketList,
  addToBucketListSuccess,
  addToBucketListFailure,
  updateBucketListItem,
  updateBucketListItemSuccess,
  updateBucketListItemFailure,
  removeFromBucketList,
  removeFromBucketListSuccess,
  removeFromBucketListFailure,
  markAsVisited,
  markAsVisitedSuccess,
  markAsVisitedFailure,
  setFilters,
  clearFilters,
} = bucketListSlice.actions;

// Export reducer
export default bucketListSlice.reducer;


--- File: packages/core/src/store/slices/uiSlice copy.ts ---
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { UIState } from '../../models/app-state';

const initialState: UIState = {
  theme: 'light',
  networkStatus: 'online',
  hasCompletedOnboarding: false,
  toasts: [],
  modals: {
    addToBucketList: {
      isOpen: false,
      venueId: null,
    },
    venueDetails: {
      isOpen: false,
      venueId: null,
    },
    filters: {
      isOpen: false,
    },
  },
};

const uiSlice = createSlice({
  name: 'ui',
  initialState,
  reducers: {
    // Theme actions
    setTheme: (state, action: PayloadAction<'light' | 'dark'>) => {
      state.theme = action.payload;
    },
    toggleTheme: state => {
      state.theme = state.theme === 'light' ? 'dark' : 'light';
    },
    
    // Network status actions
    setNetworkStatus: (state, action: PayloadAction<'online' | 'offline'>) => {
      state.networkStatus = action.payload;
    },
    
    // Onboarding actions
    completeOnboarding: state => {
      state.hasCompletedOnboarding = true;
    },
    resetOnboarding: state => {
      state.hasCompletedOnboarding = false;
    },
    
    // Toast actions
    addToast: (
      state,
      action: PayloadAction<{
        message: string;
        type: 'info' | 'success' | 'warning' | 'error';
        duration?: number;
      }>
    ) => {
      const { message, type, duration = 3000 } = action.payload;
      const id = `toast-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
      
      state.toasts.push({
        id,
        message,
        type,
        duration,
      });
    },
    removeToast: (state, action: PayloadAction<string>) => {
      state.toasts = state.toasts.filter(toast => toast.id !== action.payload);
    },
    clearToasts: state => {
      state.toasts = [];
    },
    
    // Modal actions
    openAddToBucketListModal: (state, action: PayloadAction<string>) => {
      state.modals.addToBucketList.isOpen = true;
      state.modals.addToBucketList.venueId = action.payload;
    },
    closeAddToBucketListModal: state => {
      state.modals.addToBucketList.isOpen = false;
      state.modals.addToBucketList.venueId = null;
    },
    openVenueDetailsModal: (state, action: PayloadAction<string>) => {
      state.modals.venueDetails.isOpen = true;
      state.modals.venueDetails.venueId = action.payload;
    },
    closeVenueDetailsModal: state => {
      state.modals.venueDetails.isOpen = false;
      state.modals.venueDetails.venueId = null;
    },
    openFiltersModal: state => {
      state.modals.filters.isOpen = true;
    },
    closeFiltersModal: state => {
      state.modals.filters.isOpen = false;
    },
  },
});

export const {
  setTheme,
  toggleTheme,
  setNetworkStatus,
  completeOnboarding,
  resetOnboarding,
  addToast,
  removeToast,
  clearToasts,
  openAddToBucketListModal,
  closeAddToBucketListModal,
  openVenueDetailsModal,
  closeVenueDetailsModal,
  openFiltersModal,
  closeFiltersModal,
} = uiSlice.actions;

export default uiSlice.reducer;


--- File: packages/core/src/store/slices/uiSlice.ts ---
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { UIState } from '../../models/app-state';

const initialState: UIState = {
  theme: 'light',
  networkStatus: 'online',
  hasCompletedOnboarding: false,
};

const uiSlice = createSlice({
  name: 'ui',
  initialState,
  reducers: {
    // Theme actions
    setTheme: (state, action: PayloadAction<'light' | 'dark'>) => {
      state.theme = action.payload;
    },
    toggleTheme: state => {
      state.theme = state.theme === 'light' ? 'dark' : 'light';
    },
    
    // Network status actions
    setNetworkStatus: (state, action: PayloadAction<'online' | 'offline'>) => {
      state.networkStatus = action.payload;
    },
    
    // Onboarding actions
    completeOnboarding: state => {
      state.hasCompletedOnboarding = true;
    },
    resetOnboarding: state => {
      state.hasCompletedOnboarding = false;
    },
  },
});

export const {
  setTheme,
  toggleTheme,
  setNetworkStatus,
  completeOnboarding,
  resetOnboarding,
} = uiSlice.actions;

export default uiSlice.reducer;


--- File: packages/core/src/store/slices/venuesSlice.ts ---
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { VenuesState, Venue, Coordinates } from '../../models/app-state';

const initialState: VenuesState = {
  nearby: {
    venues: [],
    loading: false,
    error: null,
  },
  recommended: {
    venues: [],
    loading: false,
    error: null,
  },
  search: {
    venues: [],
    query: '',
    loading: false,
    error: null,
  },
  selectedVenue: null,
  userLocation: null,
  locationPermissionGranted: false,
};

const venuesSlice = createSlice({
  name: 'venues',
  initialState,
  reducers: {
    // User location actions
    getUserLocation: (state) => {
      // This is a saga trigger, no state change
    },
    setUserLocation: (state, action: PayloadAction<Coordinates>) => {
      state.userLocation = action.payload;
    },
    setLocationPermission: (state, action: PayloadAction<boolean>) => {
      state.locationPermissionGranted = action.payload;
    },
    locationError: (state, action: PayloadAction<string>) => {
      state.userLocation = null;
      // Not setting an error state here as we handle this at the UI level
    },
    
    // Nearby venues actions
    fetchNearbyVenues: (state, action: PayloadAction<{
      coordinates: Coordinates;
      radius?: number;
      categories?: string[];
    }>) => {
      state.nearby.loading = true;
      state.nearby.error = null;
    },
    fetchNearbyVenuesSuccess: (state, action: PayloadAction<Venue[]>) => {
      state.nearby.venues = action.payload;
      state.nearby.loading = false;
    },
    fetchNearbyVenuesFailure: (state, action: PayloadAction<string>) => {
      state.nearby.loading = false;
      state.nearby.error = action.payload;
    },
    
    // Recommended venues actions
    fetchRecommendedVenues: (state, action: PayloadAction<{
      coordinates: Coordinates;
      limit?: number;
    }>) => {
      state.recommended.loading = true;
      state.recommended.error = null;
    },
    fetchRecommendedVenuesSuccess: (state, action: PayloadAction<Venue[]>) => {
      state.recommended.venues = action.payload;
      state.recommended.loading = false;
    },
    fetchRecommendedVenuesFailure: (state, action: PayloadAction<string>) => {
      state.recommended.loading = false;
      state.recommended.error = action.payload;
    },
    
    // Search venues actions
    searchVenues: (state, action: PayloadAction<{
      coordinates: Coordinates;
      query: string;
      categories?: string[];
      radius?: number;
    }>) => {
      state.search.loading = true;
      state.search.error = null;
      state.search.query = action.payload.query;
    },
    searchVenuesSuccess: (state, action: PayloadAction<Venue[]>) => {
      state.search.venues = action.payload;
      state.search.loading = false;
    },
    searchVenuesFailure: (state, action: PayloadAction<string>) => {
      state.search.loading = false;
      state.search.error = action.payload;
    },
    
    // Selected venue actions
    selectVenue: (state, action: PayloadAction<string>) => {
      // This triggers a saga to fetch venue details
    },
    setSelectedVenue: (state, action: PayloadAction<Venue>) => {
      state.selectedVenue = action.payload;
    },
    clearSelectedVenue: (state) => {
      state.selectedVenue = null;
    },
    
    // Clear actions
    clearVenues: (state) => {
      state.nearby.venues = [];
      state.recommended.venues = [];
      state.search.venues = [];
      state.selectedVenue = null;
    },
  },
});

// Export actions
export const {
  getUserLocation,
  setUserLocation,
  setLocationPermission,
  locationError,
  fetchNearbyVenues,
  fetchNearbyVenuesSuccess,
  fetchNearbyVenuesFailure,
  fetchRecommendedVenues,
  fetchRecommendedVenuesSuccess,
  fetchRecommendedVenuesFailure,
  searchVenues,
  searchVenuesSuccess,
  searchVenuesFailure,
  selectVenue,
  setSelectedVenue,
  clearSelectedVenue,
  clearVenues,
} = venuesSlice.actions;

// Export reducer
export default venuesSlice.reducer;


--- File: packages/core/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "composite": true,
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "**/*.spec.ts", "**/*.test.ts"]
}


--- File: packages/mobile/App.tsx ---
import React from 'react';
import { SafeAreaProvider } from 'react-native-safe-area-context';
import { Provider } from 'react-redux';
import { PersistGate } from 'redux-persist/integration/react';
import { store, persistor } from 'core/src/store';
import MainNavigator from './src/navigation/MainNavigator';
import { StatusBar } from 'expo-status-bar';

export default function App() {
  return (
    <Provider store={store}>
      <PersistGate loading={null} persistor={persistor}>
        <SafeAreaProvider>
          <StatusBar style="auto" />
          <MainNavigator />
        </SafeAreaProvider>
      </PersistGate>
    </Provider>
  );
}


--- File: packages/mobile/app.json ---
{
  "expo": {
    "name": "mobile",
    "slug": "mobile",
    "version": "1.0.0",
    "description": "React Native mobile app for Restaurant Bucket List",
    "sdkVersion": "50.0.0",
    "platforms": [
      "ios",
      "android"
    ],
    "ios": {
      "bundleIdentifier": "com.anonymous.mobile"
    }
  }
}


--- File: packages/mobile/index.js ---
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);


--- File: packages/mobile/package.json ---
{
  "name": "mobile",
  "version": "1.0.0",
  "description": "React Native mobile app for Restaurant Bucket List",
  "main": "index.js",
  "private": true,
  "scripts": {
    "start": "expo start --dev-client",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "eject": "expo eject",
    "build": "expo build",
    "clean": "rimraf ./android/build && rimraf ./ios/build",
    "test": "jest",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx"
  },
  "dependencies": {
    "@react-native-async-storage/async-storage": "^1.18.1",
    "@react-navigation/bottom-tabs": "^6.5.7",
    "@react-navigation/native": "^6.1.6",
    "@react-navigation/stack": "^6.3.16",
    "core": "1.0.0",
    "expo": "~50.0.0",
    "expo-constants": "~15.4.5",
    "expo-linking": "~6.2.2",
    "expo-location": "~16.5.2",
    "expo-status-bar": "~1.11.1",
    "react": "18.2.0",
    "react-native": "0.73.6",
    "react-native-gesture-handler": "~2.14.0",
    "react-native-reanimated": "~3.6.2",
    "react-native-safe-area-context": "4.8.2",
    "react-native-screens": "~3.29.0",
    "react-redux": "^8.0.5",
    "expo-splash-screen": "~0.26.4"
  },
  "devDependencies": {
    "@babel/core": "^7.21.5",
    "@babel/preset-env": "^7.21.5",
    "@babel/preset-typescript": "^7.21.5",
    "@babel/runtime": "^7.21.5",
    "@types/jest": "^29.5.1",
    "@types/react": "^18.2.0",
    "@types/react-native": "^0.71.6",
    "babel-jest": "^29.5.0",
    "jest": "^29.5.0",
    "jest-expo": "^48.0.2",
    "metro-react-native-babel-preset": "^0.76.3",
    "react-test-renderer": "^18.2.0",
    "rimraf": "^5.0.0",
    "typescript": "^5.0.4"
  },
  "jest": {
    "preset": "jest-expo",
    "transformIgnorePatterns": [
      "node_modules/(?!(jest-)?react-native|@react-native|react-clone-referenced-element|@react-native-community|expo(nent)?|@expo(nent)?/.*|react-navigation|@react-navigation/.*|@unimodules/.*|unimodules|sentry-expo|native-base)"
    ]
  }
}


--- File: packages/mobile/src/components/screens/AddToBucketListScreen.tsx ---
import { useRoute } from "@react-navigation/native";
import React from "react";
import { StyleSheet, Text, View } from "react-native";
import { AddToBucketListRouteProp } from "../../navigation/types"; // Assuming types are in ../../navigation
import { theme } from "../../theme"; // Assuming theme is in ../../theme

// Placeholder component for AddToBucketListScreen
export const AddToBucketListScreen = () => {
  const route = useRoute<AddToBucketListRouteProp>();
  const { venueId } = route.params;

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Add To Bucket List Screen</Text>
      <Text style={styles.text}>Venue ID: {venueId}</Text>
      <Text style={styles.text}>
        (Placeholder: Implement form to add notes, priority, tags for the venue)
      </Text>
      {/* You would typically include the BucketListItemForm here */}
      {/* <BucketListItemForm venueId={venueId} onSubmit={...} onCancel={...} /> */}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 16,
    backgroundColor: theme.lightColors?.background || "#FFFFFF",
  },
  title: {
    fontSize: 20,
    fontWeight: "bold",
    marginBottom: 16,
    color: theme.lightColors?.primary || "#000000",
  },
  text: {
    fontSize: 16,
    textAlign: "center",
    marginBottom: 8,
    color: theme.lightColors?.grey1 || "#424242",
  },
});

// Export the component
export default AddToBucketListScreen;


--- File: packages/mobile/src/components/screens/AuthScreen.tsx ---
import { useNavigation } from "@react-navigation/native";
import { StackNavigationProp } from "@react-navigation/stack";
import React from "react";
import { Button, StyleSheet, Text, View } from "react-native";
import { RootStackParamList } from "../../navigation/types"; // Assuming types are in ../../navigation
import { theme } from "../../theme"; // Assuming theme is in ../../theme

type AuthScreenNavigationProp = StackNavigationProp<RootStackParamList, "Auth">;

// Placeholder component for AuthScreen
export const AuthScreen = () => {
  const navigation = useNavigation<AuthScreenNavigationProp>();

  const handleLogin = () => {
    // Placeholder for login logic
    console.log("Login button pressed");
    // Example navigation after successful login (replace with actual logic)
    // navigation.navigate('Main');
  };

  const handleRegister = () => {
    // Placeholder for registration logic
    console.log("Register button pressed");
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Authentication Screen</Text>
      <Text style={styles.text}>
        (Placeholder: Implement Login/Registration form)
      </Text>
      <View style={styles.buttonContainer}>
        <Button
          title="Login"
          onPress={handleLogin}
          color={theme.lightColors?.primary}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Register"
          onPress={handleRegister}
          color={theme.lightColors?.secondary}
        />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 16,
    backgroundColor: theme.lightColors?.background || "#FFFFFF",
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    marginBottom: 24,
    color: theme.lightColors?.primary || "#000000",
  },
  text: {
    fontSize: 16,
    textAlign: "center",
    marginBottom: 24,
    color: theme.lightColors?.grey1 || "#424242",
  },
  buttonContainer: {
    marginVertical: 10,
    width: "80%",
  },
});

// Export the component
export default AuthScreen;


--- File: packages/mobile/src/components/screens/BucketListItemEditScreen.tsx ---
import { useRoute } from "@react-navigation/native";
import React from "react";
import { StyleSheet, Text, View } from "react-native";
import { BucketListItemEditRouteProp } from "../../navigation/types"; // Assuming types are in ../../navigation
import { theme } from "../../theme"; // Assuming theme is in ../../theme

// Placeholder component for BucketListItemEditScreen
export const BucketListItemEditScreen = () => {
  const route = useRoute<BucketListItemEditRouteProp>();
  const { itemId } = route.params;

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Edit Bucket List Item Screen</Text>
      <Text style={styles.text}>Item ID: {itemId}</Text>
      <Text style={styles.text}>
        (Placeholder: Implement form to edit notes, priority, tags for the item)
      </Text>
      {/* You would typically include the BucketListItemForm here, pre-filled with item data */}
      {/* <BucketListItemForm venueId={/* fetch venueId based on itemId *} initialData={/* fetch item data *} onSubmit={...} onCancel={...} /> */}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 16,
    backgroundColor: theme.lightColors?.background || "#FFFFFF",
  },
  title: {
    fontSize: 20,
    fontWeight: "bold",
    marginBottom: 16,
    color: theme.lightColors?.primary || "#000000",
  },
  text: {
    fontSize: 16,
    textAlign: "center",
    marginBottom: 8,
    color: theme.lightColors?.grey1 || "#424242",
  },
});

// Export the component
export default BucketListItemEditScreen;


--- File: packages/mobile/src/components/screens/BucketListScreen copy.tsx ---
import {
  BucketListItem,
  removeFromBucketList,
  markAsVisited,
} from '@restaurant-bucket-list/core/src/store/slices/bucketListSlice';
import { RootState } from '@restaurant-bucket-list/core/src/store';
import React from 'react';
import { View, Text, StyleSheet, FlatList, TouchableOpacity, Alert } from 'react-native';
import { useTheme } from '../theme/ThemeProvider';
import { useDispatch, useSelector } from 'react-redux';
import Icon from 'react-native-vector-icons/MaterialIcons';

export const BucketListScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const dispatch = useDispatch();
  const bucketList = useSelector((state: RootState) => state.bucketList.items);

  const handleRemoveItem = (id: string) => {
    Alert.alert(
      'Remove from Bucket List',
      'Are you sure you want to remove this restaurant from your bucket list?',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Remove',
          style: 'destructive',
          onPress: () => dispatch(removeFromBucketList(id)),
        },
      ]
    );
  };

  const handleMarkAsVisited = (item: BucketListItem) => {
    Alert.alert('Mark as Visited', 'Would you like to rate this restaurant?', [
      {
        text: 'Skip',
        onPress: () => dispatch(markAsVisited({ id: item.fsq_id })),
      },
      {
        text: 'Rate',
        onPress: () => navigation.navigate('RestaurantDetails', { venue: item, markVisited: true }),
      },
    ]);
  };

  const renderBucketListItem = ({ item }: { item: BucketListItem }) => (
    <TouchableOpacity
      style={[styles.itemContainer, { backgroundColor: theme.colors.card }]}
      onPress={() => navigation.navigate('RestaurantDetails', { venue: item })}
    >
      <View style={styles.itemInfo}>
        <Text style={[styles.itemName, { color: theme.colors.text }]}>{item.name}</Text>
        <Text style={[styles.itemAddress, { color: theme.colors.text }]}>
          {item.location.address}
        </Text>
        {item.visited && (
          <View style={styles.visitedContainer}>
            <Icon name="check-circle" size={16} color={theme.colors.success} />
            <Text style={[styles.visitedText, { color: theme.colors.success }]}>
              Visited {new Date(item.dateVisited!).toLocaleDateString()}
            </Text>
          </View>
        )}
      </View>
      <View style={styles.itemActions}>
        {!item.visited && (
          <TouchableOpacity
            style={[styles.actionButton, { backgroundColor: theme.colors.success }]}
            onPress={() => handleMarkAsVisited(item)}
          >
            <Icon name="check" size={24} color="#FFFFFF" />
          </TouchableOpacity>
        )}
        <TouchableOpacity
          style={[styles.actionButton, { backgroundColor: theme.colors.error }]}
          onPress={() => handleRemoveItem(item.fsq_id)}
        >
          <Icon name="delete" size={24} color="#FFFFFF" />
        </TouchableOpacity>
      </View>
    </TouchableOpacity>
  );

  return (
    <View style={[styles.container, { backgroundColor: theme.colors.background }]}>
      {bucketList.length === 0 ? (
        <View style={styles.emptyContainer}>
          <Icon name="restaurant" size={64} color={theme.colors.text} />
          <Text style={[styles.emptyText, { color: theme.colors.text }]}>
            Your bucket list is empty
          </Text>
          <Text style={[styles.emptySubtext, { color: theme.colors.text }]}>
            Add restaurants from the search or home screen
          </Text>
        </View>
      ) : (
        <FlatList
          data={bucketList}
          renderItem={renderBucketListItem}
          keyExtractor={item => item.fsq_id}
          contentContainerStyle={styles.listContainer}
        />
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  listContainer: {
    padding: 16,
  },
  itemContainer: {
    flexDirection: 'row',
    padding: 16,
    borderRadius: 8,
    marginBottom: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  itemInfo: {
    flex: 1,
  },
  itemName: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  itemAddress: {
    fontSize: 14,
    marginBottom: 4,
  },
  visitedContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  visitedText: {
    fontSize: 12,
    marginLeft: 4,
  },
  itemActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  actionButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 8,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 32,
  },
  emptyText: {
    fontSize: 20,
    fontWeight: 'bold',
    marginTop: 16,
    marginBottom: 8,
  },
  emptySubtext: {
    fontSize: 16,
    textAlign: 'center',
  },
});

export default BucketListScreen;


--- File: packages/mobile/src/components/screens/BucketListScreen.tsx ---
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { BucketListNavigationProp } from '../../navigation/types';
import { theme } from '../../theme';

interface BucketListScreenProps {
  navigation: BucketListNavigationProp;
}

/**
 * Bucket List Screen Component (Stub)
 */
export const BucketListScreen: React.FC<BucketListScreenProps> = ({ navigation }) => {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Bucket List Screen</Text>
      <Text style={styles.description}>
        This is a stub for the BucketListScreen component. It will be replaced with the actual implementation.
      </Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
    backgroundColor: theme.colors.background,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: theme.colors.primary,
  },
  description: {
    fontSize: 16,
    textAlign: 'center',
    color: theme.colors.textSecondary,
  },
});

export default BucketListScreen;


--- File: packages/mobile/src/components/screens/DetailsScreen.tsx ---
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { RouteProp } from '@react-navigation/native';
import { StackNavigationProp } from '@react-navigation/stack';
import { RootStackParamList } from '../../navigation/types';
import { theme } from '../../theme';

type DetailsScreenRouteProp = RouteProp<RootStackParamList, 'Details'>;
type DetailsScreenNavigationProp = StackNavigationProp<RootStackParamList, 'Details'>;

interface DetailsScreenProps {
  route: DetailsScreenRouteProp;
  navigation: DetailsScreenNavigationProp;
}

/**
 * Details Screen Component (Stub)
 */
export const DetailsScreen: React.FC<DetailsScreenProps> = ({ route, navigation }) => {
  const { id } = route.params;
  
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Details Screen</Text>
      <Text style={styles.description}>
        This is a stub for the DetailsScreen component. It will be replaced with the actual implementation.
      </Text>
      <Text style={styles.id}>Item ID: {id}</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
    backgroundColor: theme.colors.background,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: theme.colors.primary,
  },
  description: {
    fontSize: 16,
    textAlign: 'center',
    color: theme.colors.textSecondary,
    marginBottom: 16,
  },
  id: {
    fontSize: 18,
    fontWeight: '500',
    color: theme.colors.text,
  },
});

export default DetailsScreen;


--- File: packages/mobile/src/components/screens/ExploreScreen.tsx ---
// packages/mobile/src/components/screens/ExploreScreen.tsx

import React, { useEffect, useState, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  RefreshControl,
  ActivityIndicator,
  FlatList,
  StatusBar,
  Image,
  Platform,
  Dimensions,
  SectionList,
  SafeAreaView,
  Alert
} from 'react-native';
import { Icon, Button, Card, SearchBar, Divider } from '@rneui/themed';
import { useFocusEffect } from '@react-navigation/native';
import { useAppDispatch, useAppSelector } from 'core/src/store';
import {
  getUserLocation,
  fetchNearbyVenues,
  fetchRecommendedVenues
} from 'core/src/store/slices/venuesSlice';
import { useGeolocation } from 'core/src/hooks/useGeolocation';
import { RestaurantCard } from '../common/RestaurantCard';
import { CategoryCard } from '../common/CategoryCard';
import { LocationPermissionRequest } from '../common/LocationPermissionRequest';
import { theme } from '../../theme';
import { ExploreNavigationProp } from '../../navigation/types';
import { categories } from '../../constants/categories';

interface ExploreScreenProps {
  navigation: ExploreNavigationProp;
}

/**
 * Explore Screen Component
 * - Main discovery screen for the app
 * - Shows nearby and recommended restaurants
 * - Provides category browsing
 * - Handles location permissions
 */
export const ExploreScreen: React.FC<ExploreScreenProps> = ({ navigation }) => {
  const dispatch = useAppDispatch();
  const { coordinates, permissionGranted, requestLocation } = useGeolocation();

  // Get venues from state
  const nearbyVenues = useAppSelector(state => state.venues.nearby.venues);
  const nearbyLoading = useAppSelector(state => state.venues.nearby.loading);
  const nearbyError = useAppSelector(state => state.venues.nearby.error);

  const recommendedVenues = useAppSelector(state => state.venues.recommended.venues);
  const recommendedLoading = useAppSelector(state => state.venues.recommended.loading);
  const recommendedError = useAppSelector(state => state.venues.recommended.error);

  const bucketListItems = useAppSelector(state => state.bucketList.items);
  const isAuthenticated = useAppSelector(state => state.auth.isAuthenticated);
  const userName = useAppSelector(state => state.auth.user?.displayName);

  // Local state
  const [refreshing, setRefreshing] = useState<boolean>(false);
  const [searchQuery, setSearchQuery] = useState<string>('');

  // Top categories
  const topCategories = categories.slice(0, 6);

  // Check if venue is in bucket list
  const isVenueInBucketList = useCallback((venueId: string) => {
    return bucketListItems.some(item => item.venueId === venueId);
  }, [bucketListItems]);

  // Handle screen focus
  useFocusEffect(
    useCallback(() => {
      // Only fetch if we have location permission
      if (permissionGranted && coordinates) {
        loadVenues();
      }
    }, [permissionGranted, coordinates])
  );

  // Load venues from API
  const loadVenues = useCallback(() => {
    if (coordinates) {
      dispatch(fetchNearbyVenues({ coordinates }));
      dispatch(fetchRecommendedVenues({ coordinates, limit: 5 }));
    }
  }, [coordinates, dispatch]);

  // Handle refresh
  const handleRefresh = useCallback(() => {
    setRefreshing(true);
    loadVenues();
    setTimeout(() => {
      setRefreshing(false);
    }, 1500);
  }, [loadVenues]);

  // Handle search
  const handleSearch = useCallback(() => {
    if (searchQuery.trim()) {
      navigation.navigate('Search', { screen: 'SearchResults', params: { query: searchQuery } });
      setSearchQuery('');
    }
  }, [searchQuery, navigation]);

  // Handle venue press
  const handleVenuePress = useCallback((venueId: string) => {
    navigation.navigate('VenueDetails', { venueId });
  }, [navigation]);

  // Handle category press
  const handleCategoryPress = useCallback((categoryId: string, categoryName: string) => {
    navigation.navigate('Search', {
      screen: 'SearchResults',
      params: {
        categories: [categoryId],
        title: categoryName
      }
    });
  }, [navigation]);

  // Handle see all press
  const handleSeeAllPress = useCallback((type: 'nearby' | 'recommended') => {
    if (type === 'nearby') {
      navigation.navigate('Explore', { screen: 'NearbyVenues' });
    } else {
      navigation.navigate('Explore', { screen: 'RecommendedVenues' });
    }
  }, [navigation]);

  // Request location if not granted
  if (!permissionGranted) {
    return (
      <LocationPermissionRequest
        onRequestLocation={requestLocation}
      />
    );
  }

  // Show loading if waiting for location
  if (!coordinates) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={styles.loadingText}>Getting your location...</Text>
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar barStyle="dark-content" backgroundColor="white" />

      <ScrollView
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        showsVerticalScrollIndicator={false}
      >
        {/* Header */}
        <View style={styles.header}>
          <View style={styles.headerContent}>
            <View>
              <Text style={styles.greeting}>
                {isAuthenticated && userName
                  ? `Hello, ${userName.split(' ')[0]}!`
                  : 'Hello there!'}
              </Text>
              <Text style={styles.subtitle}>Discover amazing restaurants</Text>
            </View>

            <TouchableOpacity
              onPress={() => navigation.navigate('Profile')}
              style={styles.profileButton}
              accessible={true}
              accessibilityLabel="Your profile"
              accessibilityRole="button"
            >
              <Icon name="person" type="material" size={28} color={theme.colors.primary} />
            </TouchableOpacity>
          </View>
        </View>

        {/* Search bar */}
        <View style={styles.searchBarContainer}>
          <SearchBar
            placeholder="Search restaurants..."
            value={searchQuery}
            onChangeText={setSearchQuery}
            onSubmitEditing={handleSearch}
            platform={Platform.OS === 'ios' ? 'ios' : 'android'}
            containerStyle={styles.searchBar}
            inputContainerStyle={styles.searchBarInput}
            returnKeyType="search"
            accessibilityLabel="Search for restaurants"
            accessibilityHint="Enter restaurant name or cuisine"
          />
        </View>

        {/* Categories */}
        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>Categories</Text>
            <TouchableOpacity
              onPress={() => navigation.navigate('Explore', { screen: 'CategoryList' })}
              accessible={true}
              accessibilityLabel="View all categories"
              accessibilityRole="button"
            >
              <Text style={styles.seeAll}>See All</Text>
            </TouchableOpacity>
          </View>

          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={styles.categoriesContainer}
          >
            {topCategories.map((category, index) => (
              <CategoryCard
                key={category.id}
                category={category}
                onPress={() => handleCategoryPress(category.id, category.name)}
              />
            ))}
          </ScrollView>
        </View>

        {/* Recommended venues */}
        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>Recommended for You</Text>
            <TouchableOpacity
              onPress={() => handleSeeAllPress('recommended')}
              accessible={true}
              accessibilityLabel="View all recommended restaurants"
              accessibilityRole="button"
            >
              <Text style={styles.seeAll}>See All</Text>
            </TouchableOpacity>
          </View>

          {recommendedLoading && recommendedVenues.length === 0 ? (
            <View style={styles.loadingRow}>
              <ActivityIndicator size="small" color={theme.colors.primary} />
              <Text style={styles.loadingText}>Finding recommendations...</Text>
            </View>
          ) : recommendedError ? (
            <View style={styles.errorContainer}>
              <Icon name="error" type="material" color={theme.colors.error} size={24} />
              <Text style={styles.errorText}>
                {recommendedError}
              </Text>
              <Button
                title="Try Again"
                type="clear"
                onPress={loadVenues}
              />
            </View>
          ) : recommendedVenues.length === 0 ? (
            <View style={styles.emptyContainer}>
              <Icon name="restaurant" type="material" color={theme.colors.grey3} size={40} />
              <Text style={styles.emptyText}>No recommendations found</Text>
            </View>
          ) : (
            <FlatList
              data={recommendedVenues.slice(0, 5)}
              keyExtractor={(item) => item.id}
              horizontal
              showsHorizontalScrollIndicator={false}
              contentContainerStyle={styles.recommendedList}
              renderItem={({ item }) => (
                <TouchableOpacity
                  style={styles.recommendedItem}
                  onPress={() => handleVenuePress(item.id)}
                  accessible={true}
                  accessibilityLabel={`${item.name}, ${
                    item.categories?.[0]?.name || ''
                  }`}
                  accessibilityRole="button"
                >
                  <Card containerStyle={styles.recommendedCard}>
                    <View style={styles.cardImageContainer}>
                      {item.photos?.length > 0 ? (
                        <Image
                          source={{
                            uri: `${item.photos[0].prefix}300x200${item.photos[0].suffix}`
                          }}
                          style={styles.cardImage}
                          resizeMode="cover"
                        />
                      ) : (
                        <View style={[styles.cardImage, styles.placeholderImage]}>
                          <Icon name="restaurant" type="material" size={30} color={theme.colors.grey3} />
                        </View>
                      )}
                      {isVenueInBucketList(item.id) && (
                        <View style={styles.bookmarkedBadge}>
                          <Icon name="bookmark" type="material" size={16} color="white" />
                        </View>
                      )}
                    </View>
                    <View style={styles.cardContent}>
                      <Text style={styles.cardTitle} numberOfLines={1}>{item.name}</Text>
                      {item.categories && item.categories.length > 0 && (
                        <Text style={styles.cardCategory} numberOfLines={1}>
                          {item.categories[0].name}
                        </Text>
                      )}
                      <View style={styles.cardFooter}>
                        {item.rating && (
                          <View style={styles.ratingContainer}>
                            <Icon name="star" size={14} color={theme.colors.warning} />
                            <Text style={styles.rating}>{item.rating.toFixed(1)}</Text>
                          </View>
                        )}
                        {item.price && (
                          <Text style={styles.price}>
                            {item.price.message || '$'.repeat(item.price.tier || 1)}
                          </Text>
                        )}
                      </View>
                    </View>
                  </Card>
                </TouchableOpacity>
              )}
            />
          )}
        </View>

        {/* Nearby venues */}
        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>Nearby Restaurants</Text>
            <TouchableOpacity
              onPress={() => handleSeeAllPress('nearby')}
              accessible={true}
              accessibilityLabel="View all nearby restaurants"
              accessibilityRole="button"
            >
              <Text style={styles.seeAll}>See All</Text>
            </TouchableOpacity>
          </View>

          {nearbyLoading && nearbyVenues.length === 0 ? (
            <View style={styles.loadingRow}>
              <ActivityIndicator size="small" color={theme.colors.primary} />
              <Text style={styles.loadingText}>Finding nearby restaurants...</Text>
            </View>
          ) : nearbyError ? (
            <View style={styles.errorContainer}>
              <Icon name="error" type="material" color={theme.colors.error} size={24} />
              <Text style={styles.errorText}>{nearbyError}</Text>
              <Button
                title="Try Again"
                type="clear"
                onPress={loadVenues}
              />
            </View>
          ) : nearbyVenues.length === 0 ? (
            <View style={styles.emptyContainer}>
              <Icon name="place" type="material" color={theme.colors.grey3} size={40} />
              <Text style={styles.emptyText}>No nearby restaurants found</Text>
            </View>
          ) : (
            <View style={styles.nearbyContainer}>
              {nearbyVenues.slice(0, 5).map((venue) => (
                <RestaurantCard
                  key={venue.id}
                  venue={venue}
                  isBucketListed={isVenueInBucketList(venue.id)}
                  compact={true}
                  onPress={() => handleVenuePress(venue.id)}
                />
              ))}

              <TouchableOpacity
                style={styles.viewAllButton}
                onPress={() => handleSeeAllPress('nearby')}
                accessible={true}
                accessibilityLabel="View all nearby restaurants"
                accessibilityRole="button"
              >
                <Text style={styles.viewAllText}>View All Nearby</Text>
                <Icon name="chevron-right" type="material" size={18} color={theme.colors.primary} />
              </TouchableOpacity>
            </View>
          )}
        </View>

        {/* Your bucket list preview (if authenticated) */}
        {isAuthenticated && bucketListItems.length > 0 && (
          <View style={styles.section}>
            <View style={styles.sectionHeader}>
              <Text style={styles.sectionTitle}>Your Bucket List</Text>
              <TouchableOpacity
                onPress={() => navigation.navigate('BucketList')}
                accessible={true}
                accessibilityLabel="View your bucket list"
                accessibilityRole="button"
              >
                <Text style={styles.seeAll}>See All</Text>
              </TouchableOpacity>
            </View>

            <ScrollView
              horizontal
              showsHorizontalScrollIndicator={false}
              contentContainerStyle={styles.bucketListPreview}
            >
              {bucketListItems.slice(0, 5).map((item) => (
                <TouchableOpacity
                  key={item.id}
                  style={styles.bucketListItem}
                  onPress={() => handleVenuePress(item.venueId)}
                  accessible={true}
                  accessibilityLabel={`${item.venue.name} from your bucket list`}
                  accessibilityRole="button"
                >
                  <Card containerStyle={styles.bucketListCard}>
                    <View style={styles.cardImageContainer}>
                      {item.venue.photos?.length > 0 ? (
                        <Image
                          source={{
                            uri: `${item.venue.photos[0].prefix}300x200${item.venue.photos[0].suffix}`
                          }}
                          style={styles.cardImage}
                          resizeMode="cover"
                        />
                      ) : (
                        <View style={[styles.cardImage, styles.placeholderImage]}>
                          <Icon name="restaurant" type="material" size={30} color={theme.colors.grey3} />
                        </View>
                      )}
                      {item.priority && (
                        <View style={[
                          styles.priorityBadge,
                          item.priority === 'high' && styles.highPriority,
                          item.priority === 'medium' && styles.mediumPriority,
                          item.priority === 'low' && styles.lowPriority,
                        ]}>
                          <Icon name="flag" type="material" size={14} color="white" />
                        </View>
                      )}
                    </View>
                    <View style={styles.cardContent}>
                      <Text style={styles.cardTitle} numberOfLines={1}>{item.venue.name}</Text>
                      {item.venue.categories && item.venue.categories.length > 0 && (
                        <Text style={styles.cardCategory} numberOfLines={1}>
                          {item.venue.categories[0].name}
                        </Text>
                      )}
                      {item.visitedAt ? (
                        <View style={styles.visitedBadge}>
                          <Icon name="check-circle" type="material" size={14} color={theme.colors.success} />
                          <Text style={styles.visitedText}>Visited</Text>
                        </View>
                      ) : item.plannedVisitDate ? (
                        <Text style={styles.plannedDate}>
                          Planned: {new Date(item.plannedVisitDate).toLocaleDateString()}
                        </Text>
                      ) : null}
                    </View>
                  </Card>
                </TouchableOpacity>
              ))}
            </ScrollView>
          </View>
        )}

        {/* Bottom padding */}
        <View style={{ height: 80 }} />
      </ScrollView>
    </SafeAreaView>
  );
};

const { width } = Dimensions.get('window');

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: 'white',
  },
  scrollContent: {
    flexGrow: 1,
  },
  header: {
    padding: 16,
    paddingTop: Platform.OS === 'ios' ? 0 : 16,
  },
  headerContent: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  greeting: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 4,
    color: theme.colors.grey1,
  },
  subtitle: {
    fontSize: 16,
    color: theme.colors.grey3,
  },
  profileButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: theme.colors.grey5,
    justifyContent: 'center',
    alignItems: 'center',
  },
  searchBarContainer: {
    paddingHorizontal: 16,
    marginBottom: 16,
  },
  searchBar: {
    backgroundColor: 'transparent',
    borderTopWidth: 0,
    borderBottomWidth: 0,
    paddingHorizontal: 0,
  },
  searchBarInput: {
    backgroundColor: theme.colors.grey5,
    borderRadius: 8,
  },
  section: {
    marginBottom: 24,
  },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    marginBottom: 12,
  },
  sectionTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    color: theme.colors.grey1,
  },
  seeAll: {
    fontSize: 14,
    color: theme.colors.primary,
    fontWeight: '500',
  },
  categoriesContainer: {
    paddingHorizontal: 12,
  },
  recommendedList: {
    paddingHorizontal: 12,
    paddingVertical: 4,
  },
  recommendedItem: {
    width: width * 0.7,
    maxWidth: 280,
    marginHorizontal: 4,
  },
  recommendedCard: {
    margin: 0,
    padding: 0,
    borderRadius: 8,
    overflow: 'hidden',
  },
  cardImageContainer: {
    position: 'relative',
  },
  cardImage: {
    width: '100%',
    height: 150,
    backgroundColor: theme.colors.grey5,
  },
  placeholderImage: {
    justifyContent: 'center',
    alignItems: 'center',
  },
  bookmarkedBadge: {
    position: 'absolute',
    top: 8,
    right: 8,
    backgroundColor: theme.colors.primary,
    borderRadius: 12,
    width: 24,
    height: 24,
    justifyContent: 'center',
    alignItems: 'center',
  },
  priorityBadge: {
    position: 'absolute',
    top: 8,
    right: 8,
    borderRadius: 12,
    width: 24,
    height: 24,
    justifyContent: 'center',
    alignItems: 'center',
  },
  highPriority: {
    backgroundColor: theme.colors.error,
  },
  mediumPriority: {
    backgroundColor: theme.colors.warning,
  },
  lowPriority: {
    backgroundColor: theme.colors.success,
  },
  cardContent: {
    padding: 12,
  },
  cardTitle: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
    color: theme.colors.grey1,
  },
  cardCategory: {
    fontSize: 14,
    color: theme.colors.grey3,
    marginBottom: 6,
  },
  cardFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
  },
  ratingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  rating: {
    fontSize: 14,
    marginLeft: 4,
    color: theme.colors.grey2,
  },
  price: {
    fontSize: 14,
    color: theme.colors.grey2,
  },
  nearbyContainer: {
    paddingHorizontal: 16,
  },
  viewAllButton: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 12,
    borderWidth: 1,
    borderColor: theme.colors.grey4,
    borderRadius: 8,
    marginVertical: 8,
  },
  viewAllText: {
    fontSize: 14,
    fontWeight: '500',
    color: theme.colors.primary,
    marginRight: 4,
  },
  bucketListPreview: {
    paddingHorizontal: 12,
    paddingVertical: 4,
  },
  bucketListItem: {
    width: width * 0.6,
    maxWidth: 240,
    marginHorizontal: 4,
  },
  bucketListCard: {
    margin: 0,
    padding: 0,
    borderRadius: 8,
    overflow: 'hidden',
  },
  visitedBadge: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  visitedText: {
    fontSize: 12,
    color: theme.colors.success,
    marginLeft: 4,
  },
  plannedDate: {
    fontSize: 12,
    color: theme.colors.grey3,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    padding: 20,
  },
  loadingText: {
    fontSize: 16,
    color: theme.colors.grey3,
    marginLeft: 12,
  },
  errorContainer: {
    padding: 20,
    alignItems: 'center',
    justifyContent: 'center',
  },
  errorText: {
    fontSize: 16,
    color: theme.colors.error,
    textAlign: 'center',
    marginVertical: 12,
  },
  emptyContainer: {
    padding: 40,
    alignItems: 'center',
    justifyContent: 'center',
  },
  emptyText: {
    fontSize: 16,
    color: theme.colors.grey3,
    textAlign: 'center',
    marginTop: 12,
  },
});

--- File: packages/mobile/src/components/screens/HomeScreen.tsx ---
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { HomeNavigationProp } from '../../navigation/types';
import { theme } from '../../theme';

interface HomeScreenProps {
  navigation: HomeNavigationProp;
}

/**
 * Home Screen Component (Stub)
 */
export const HomeScreen: React.FC<HomeScreenProps> = ({ navigation }) => {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Home Screen</Text>
      <Text style={styles.description}>
        This is a stub for the HomeScreen component. It will be replaced with the actual implementation.
      </Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
    backgroundColor: theme.colors.background,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: theme.colors.primary,
  },
  description: {
    fontSize: 16,
    textAlign: 'center',
    color: theme.colors.textSecondary,
  },
});

export default HomeScreen;


--- File: packages/mobile/src/components/screens/OnBoardingScreen.tsx ---
import { useNavigation } from "@react-navigation/native";
import { StackNavigationProp } from "@react-navigation/stack";
import React from "react";
import { Button, StyleSheet, Text, View } from "react-native";
import { RootStackParamList } from "../../navigation/types"; // Assuming types are in ../../navigation
import { theme } from "../../theme"; // Assuming theme is in ../../theme
// import { useAppDispatch } from 'core/src/store'; // If using Redux for state management
// import { completeOnboarding } from 'core/src/store/slices/uiSlice'; // Action to mark onboarding complete

type OnBoardingScreenNavigationProp = StackNavigationProp<
  RootStackParamList,
  "OnBoarding"
>;

// Placeholder component for OnBoardingScreen
export const OnBoardingScreen = () => {
  const navigation = useNavigation<OnBoardingScreenNavigationProp>();
  // const dispatch = useAppDispatch(); // Uncomment if using Redux

  const handleCompleteOnboarding = () => {
    // Placeholder for completing onboarding logic
    console.log("Onboarding completed");
    // Mark onboarding as complete in state management (e.g., Redux)
    // dispatch(completeOnboarding());
    // Navigate to the main app or auth screen
    // This navigation depends on whether the user needs to authenticate next
    navigation.replace("Auth"); // Or 'Main' if authentication isn't required immediately after onboarding
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Welcome Onboarding!</Text>
      <Text style={styles.text}>
        (Placeholder: Implement onboarding steps/slides)
      </Text>
      <Button
        title="Get Started"
        onPress={handleCompleteOnboarding}
        color={theme.lightColors?.primary}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 16,
    backgroundColor: theme.lightColors?.background || "#FFFFFF",
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    marginBottom: 24,
    color: theme.lightColors?.primary || "#000000",
    textAlign: "center",
  },
  text: {
    fontSize: 18,
    textAlign: "center",
    marginBottom: 32,
    color: theme.lightColors?.grey1 || "#424242",
  },
});

// Export the component
export default OnBoardingScreen;


--- File: packages/mobile/src/components/screens/ProfileScreen copy.tsx ---
import { useNavigation } from "@react-navigation/native";
import React from "react";
import { Button, StyleSheet, Text, View } from "react-native";
import { ProfileNavigationProp } from "../../navigation/types"; // Assuming types are in ../../navigation
import { theme } from "../../theme"; // Assuming theme is in ../../theme
// import { useAppDispatch, useAppSelector } from 'core/src/store'; // If using Redux
// import { logout } from 'core/src/store/slices/authSlice'; // Example Redux action

// Placeholder component for ProfileScreen
// Note: A ProfileScreen also exists in components/common. This aligns with the import path.
export const ProfileScreen = () => {
  const navigation = useNavigation<ProfileNavigationProp>();
  // const dispatch = useAppDispatch(); // Uncomment if using Redux
  // const user = useAppSelector((state) => state.auth.user); // Example Redux state

  const handleLogout = () => {
    // Placeholder for logout logic
    console.log("Logout button pressed");
    // dispatch(logout()); // Example Redux action
    // Navigation after logout usually handled by the main navigator based on auth state
  };

  const navigateToSettings = () => {
    navigation.navigate("Settings");
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Profile Screen</Text>
      {/* Example user info */}
      {/* <Text style={styles.text}>Welcome, {user?.displayName || 'User'}!</Text>
      <Text style={styles.text}>Email: {user?.email}</Text> */}
      <Text style={styles.text}>
        (Placeholder: Display user info, stats, settings links)
      </Text>
      <View style={styles.buttonContainer}>
        <Button
          title="Settings"
          onPress={navigateToSettings}
          color={theme.lightColors?.secondary}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Log Out"
          onPress={handleLogout}
          color={theme.lightColors?.error}
        />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 16,
    backgroundColor: theme.lightColors?.background || "#FFFFFF",
  },
  title: {
    fontSize: 22,
    fontWeight: "bold",
    marginBottom: 20,
    color: theme.lightColors?.primary || "#000000",
  },
  text: {
    fontSize: 16,
    textAlign: "center",
    marginBottom: 10,
    color: theme.lightColors?.grey1 || "#424242",
  },
  buttonContainer: {
    marginVertical: 10,
    width: "60%",
  },
});

// Export the component
export default ProfileScreen;


--- File: packages/mobile/src/components/screens/ProfileScreen.tsx ---
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { ProfileNavigationProp } from '../../navigation/types';
import { theme } from '../../theme';

interface ProfileScreenProps {
  navigation: ProfileNavigationProp;
}

/**
 * Profile Screen Component (Stub)
 */
export const ProfileScreen: React.FC<ProfileScreenProps> = ({ navigation }) => {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Profile Screen</Text>
      <Text style={styles.description}>
        This is a stub for the ProfileScreen component. It will be replaced with the actual implementation.
      </Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
    backgroundColor: theme.colors.background,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: theme.colors.primary,
  },
  description: {
    fontSize: 16,
    textAlign: 'center',
    color: theme.colors.textSecondary,
  },
});

export default ProfileScreen;


--- File: packages/mobile/src/components/screens/SearchScreen copy.tsx ---
import { useNavigation } from "@react-navigation/native";
import React, { useState } from "react";
import { Button, StyleSheet, Text, TextInput, View } from "react-native";
import { SearchNavigationProp } from "../../navigation/types"; // Assuming types are in ../../navigation
import { theme } from "../../theme"; // Assuming theme is in ../../theme
// import { useAppDispatch, useAppSelector } from 'core/src/store'; // If using Redux
// import { searchVenues } from 'core/src/store/slices/venuesSlice'; // Example Redux action

// Placeholder component for SearchScreen
// Note: A SearchScreen also exists in components/common. This aligns with the import path.
export const SearchScreen = () => {
  const navigation = useNavigation<SearchNavigationProp>();
  const [query, setQuery] = useState("");
  // const dispatch = useAppDispatch(); // Uncomment if using Redux
  // const searchResults = useAppSelector((state) => state.venues.search.venues); // Example Redux state
  // const isLoading = useAppSelector((state) => state.venues.search.loading); // Example Redux state

  const handleSearch = () => {
    if (query.trim()) {
      console.log("Searching for:", query);
      // dispatch(searchVenues({ query, coordinates: /* Get coordinates */ })); // Example Redux action
      // Optionally navigate to a dedicated results screen, or display results here
      navigation.navigate("Search", {
        screen: "SearchResults", // Example nested navigation
        params: { query: query },
      });
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Search Screen</Text>
      <TextInput
        style={styles.input}
        placeholder="Search for restaurants, cuisines..."
        value={query}
        onChangeText={setQuery}
        onSubmitEditing={handleSearch}
        returnKeyType="search"
      />
      <Button
        title="Search"
        onPress={handleSearch}
        color={theme.lightColors?.primary}
        // disabled={isLoading} // Disable button while loading
      />
      <Text style={styles.text}>
        (Placeholder: Display search results or suggestions below)
      </Text>
      {/* Placeholder for results list */}
      {/* {isLoading && <ActivityIndicator size="large" color={theme.lightColors?.primary} />} */}
      {/* <FlatList data={searchResults} renderItem={...} keyExtractor={...} /> */}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    paddingTop: 40, // Add padding to avoid status bar overlap
    backgroundColor: theme.lightColors?.background || "#FFFFFF",
  },
  title: {
    fontSize: 22,
    fontWeight: "bold",
    marginBottom: 16,
    textAlign: "center",
    color: theme.lightColors?.primary || "#000000",
  },
  input: {
    height: 45,
    borderColor: theme.lightColors?.grey4 || "#CCCCCC",
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 12,
    marginBottom: 16,
    fontSize: 16,
    backgroundColor: theme.lightColors?.white || "#FFFFFF",
  },
  text: {
    fontSize: 16,
    textAlign: "center",
    marginTop: 20,
    color: theme.lightColors?.grey1 || "#424242",
  },
});

// Export the component
export default SearchScreen;


--- File: packages/mobile/src/components/screens/SearchScreen.tsx ---
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { SearchNavigationProp } from '../../navigation/types';
import { theme } from '../../theme';

interface SearchScreenProps {
  navigation: SearchNavigationProp;
}

/**
 * Search Screen Component (Stub)
 */
export const SearchScreen: React.FC<SearchScreenProps> = ({ navigation }) => {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Search Screen</Text>
      <Text style={styles.description}>
        This is a stub for the SearchScreen component. It will be replaced with the actual implementation.
      </Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
    backgroundColor: theme.colors.background,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: theme.colors.primary,
  },
  description: {
    fontSize: 16,
    textAlign: 'center',
    color: theme.colors.textSecondary,
  },
});

export default SearchScreen;


--- File: packages/mobile/src/components/screens/SettingsScreen.tsx ---
import React from "react";
import { StyleSheet, Switch, Text, View } from "react-native";
import { theme } from "../../theme"; // Assuming theme is in ../../theme
// import { useAppDispatch, useAppSelector } from 'core/src/store'; // If using Redux
// import { toggleTheme, setPreference } from 'core/src/store/slices/uiSlice'; // Example Redux actions

// Placeholder component for SettingsScreen
export const SettingsScreen = () => {
  // const dispatch = useAppDispatch(); // Uncomment if using Redux
  // const currentTheme = useAppSelector((state) => state.ui.theme); // Example Redux state
  // const isDark = currentTheme === 'dark';

  const handleThemeToggle = (value: boolean) => {
    console.log("Theme toggle:", value ? "dark" : "light");
    // dispatch(toggleTheme()); // Example Redux action
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Settings Screen</Text>

      <View style={styles.settingItem}>
        <Text style={styles.settingText}>Dark Mode</Text>
        <Switch
          // value={isDark} // Use Redux state if available
          // onValueChange={handleThemeToggle}
          trackColor={{
            false: theme.lightColors?.grey4,
            true: theme.lightColors?.primary,
          }}
          thumbColor={theme.lightColors?.white}
        />
      </View>

      <Text style={styles.placeholder}>
        (Placeholder: Add more settings like notifications, preferences, etc.)
      </Text>
      {/* Add more settings options here */}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: theme.lightColors?.background || "#FFFFFF",
  },
  title: {
    fontSize: 22,
    fontWeight: "bold",
    marginBottom: 24,
    color: theme.lightColors?.grey0 || "#000000",
  },
  settingItem: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: theme.lightColors?.divider || "#EEEEEE",
  },
  settingText: {
    fontSize: 18,
    color: theme.lightColors?.grey1 || "#424242",
  },
  placeholder: {
    fontSize: 16,
    textAlign: "center",
    marginTop: 30,
    color: theme.lightColors?.grey3 || "#757575",
  },
});

// Export the component
export default SettingsScreen;


--- File: packages/mobile/src/components/screens/VenueDetailsScreen.tsx ---
// packages/mobile/src/components/screens/VenueDetailsScreen.tsx

import React, { useEffect, useState, useCallback, useMemo } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Image,
  Linking,
  Platform,
  Share,
  ActivityIndicator
} from 'react-native';
import { useRoute, useNavigation, RouteProp } from '@react-navigation/native';
import { StackNavigationProp } from '@react-navigation/stack';
import { Button, Icon, Divider, Chip, FAB, Overlay } from '@rneui/themed';
import MapView, { Marker } from 'react-native-maps';
import { useAppDispatch, useAppSelector } from 'core/src/store';
import { selectVenue } from 'core/src/store/slices/venuesSlice';
import {
  addToBucketList,
  removeFromBucketList,
  updateBucketListItem,
  markAsVisited
} from 'core/src/store/slices/bucketListSlice';
import { theme } from '../../theme';
import { getVenueImage } from '../../utils/imageUtils';
import { getDistanceString } from '../../utils/distanceUtils';
import { RootStackParamList } from '../../navigation/types';
import { BucketListItemForm } from '../forms/BucketListItemForm';

type VenueDetailsScreenRouteProp = RouteProp<RootStackParamList, 'VenueDetails'>;
type VenueDetailsScreenNavigationProp = StackNavigationProp<RootStackParamList, 'VenueDetails'>;

/**
 * Venue Details Screen
 * - Displays comprehensive information about a venue
 * - Allows adding/removing from bucket list
 * - Shows map location, photos, reviews, etc.
 * - Includes accessibility features
 */
export const VenueDetailsScreen: React.FC = () => {
  const route = useRoute<VenueDetailsScreenRouteProp>();
  const navigation = useNavigation<VenueDetailsScreenNavigationProp>();
  const dispatch = useAppDispatch();
  const { venueId } = route.params;
  const venue = useAppSelector(state => state.venues.selectedVenue);
  const userLocation = useAppSelector(state => state.venues.userLocation);
  const isAuthenticated = useAppSelector(state => state.auth.isAuthenticated);
  const bucketListItems = useAppSelector(state => state.bucketList.items);

  // State
  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [formVisible, setFormVisible] = useState<boolean>(false);
  const [visitedModalVisible, setVisitedModalVisible] = useState<boolean>(false);
  const [rating, setRating] = useState<number>(0);
  const [review, setReview] = useState<string>('');

  // Find if venue is in bucket list
  const bucketListItem = useMemo(() => {
    return bucketListItems.find(item => item.venueId === venueId);
  }, [bucketListItems, venueId]);

  const isBucketListed = !!bucketListItem;

  // Get main venue image
  const mainImage = useMemo(() => {
    return getVenueImage(venue, 600, 400);
  }, [venue]);

  // Get venue distance
  const distance = useMemo(() => {
    if (userLocation && venue?.location) {
      return getDistanceString(
        userLocation.latitude,
        userLocation.longitude,
        venue.location.lat,
        venue.location.lng
      );
    }
    return null;
  }, [userLocation, venue?.location]);

  // Load venue details
  useEffect(() => {
    const loadVenue = async () => {
      setIsLoading(true);
      await dispatch(selectVenue(venueId));
      setIsLoading(false);
    };

    if (venueId) {
      loadVenue();
    }
  }, [dispatch, venueId]);

  // Set navigation options
  useEffect(() => {
    if (venue) {
      navigation.setOptions({
        title: venue.name,
        headerRight: () => (
          <TouchableOpacity
            onPress={handleShare}
            style={{ marginRight: 16 }}
            accessibilityLabel="Share this venue"
            accessibilityRole="button"
          >
            <Icon name="share" type="material" size={24} color={theme.colors.primary} />
          </TouchableOpacity>
        ),
      });
    }
  }, [navigation, venue]);

  // Handle bucket list toggle
  const handleBucketListToggle = useCallback(() => {
    if (!isAuthenticated) {
      navigation.navigate('Auth');
      return;
    }

    if (isBucketListed) {
      dispatch(removeFromBucketList(bucketListItem!.id));
    } else {
      setFormVisible(true);
    }
  }, [dispatch, isAuthenticated, isBucketListed, bucketListItem, navigation]);

  // Handle edit bucket list item
  const handleEditBucketList = useCallback(() => {
    if (bucketListItem) {
      setFormVisible(true);
    }
  }, [bucketListItem]);

  // Handle form submit
  const handleFormSubmit = useCallback((data: {
    notes?: string;
    tags?: string[];
    priority?: 'low' | 'medium' | 'high';
    plannedVisitDate?: Date;
  }) => {
    if (isBucketListed && bucketListItem) {
      dispatch(updateBucketListItem({
        id: bucketListItem.id,
        updates: {
          ...data,
          plannedVisitDate: data.plannedVisitDate?.getTime(),
        }
      }));
    } else {
      dispatch(addToBucketList({
        venueId,
        ...data,
        plannedVisitDate: data.plannedVisitDate?.getTime(),
      }));
    }

    setFormVisible(false);
  }, [dispatch, venueId, isBucketListed, bucketListItem]);

  // Handle mark as visited
  const handleMarkAsVisited = useCallback(() => {
    setVisitedModalVisible(true);
  }, []);

  // Handle visited form submit
  const handleVisitedSubmit = useCallback(() => {
    if (bucketListItem) {
      dispatch(markAsVisited({
        id: bucketListItem.id,
        rating,
        review: review.trim() || undefined
      }));
      setVisitedModalVisible(false);
    }
  }, [dispatch, bucketListItem, rating, review]);

  // Handle directions
  const handleDirections = useCallback(() => {
    if (!venue?.location) return;

    const { lat, lng } = venue.location;
    const url = Platform.select({
      ios: `maps:?q=${venue.name}&ll=${lat},${lng}`,
      android: `geo:${lat},${lng}?q=${lat},${lng}(${venue.name})`,
    });

    if (url) {
      Linking.openURL(url);
    }
  }, [venue]);

  // Handle open website
  const handleOpenWebsite = useCallback(() => {
    if (venue?.url) {
      Linking.openURL(venue.url);
    }
  }, [venue?.url]);

  // Handle phone call
  const handleCall = useCallback(() => {
    if (venue?.contact?.phone) {
      Linking.openURL(`tel:${venue.contact.phone}`);
    }
  }, [venue?.contact?.phone]);

  // Handle share
  const handleShare = useCallback(() => {
    if (!venue) return;

    const title = `Check out ${venue.name}`;
    const message = `I found ${venue.name} and thought you might be interested!\n${venue.location?.formattedAddress || ''}`;
    const url = venue.url;

    Share.share({
      title,
      message: url ? `${message}\n${url}` : message,
    });
  }, [venue]);

  // Loading state
  if (isLoading || !venue) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={styles.loadingText}>Loading venue details...</Text>
      </View>
    );
  }

  // Get venue categories
  const categoryText = venue.categories?.map(cat => cat.name).join(', ') || '';

  // Get venue price
  const priceText = venue.price?.message ||
    (venue.price?.tier ? '$'.repeat(venue.price.tier) : '');

  return (
    <View style={styles.container}>
      <ScrollView
        contentContainerStyle={styles.scrollContainer}
        showsVerticalScrollIndicator={false}
      >
        {/* Main image */}
        {mainImage ? (
          <Image source={{ uri: mainImage }} style={styles.mainImage} />
        ) : (
          <View style={[styles.mainImage, styles.placeholderImage]}>
            <Icon name="restaurant" type="material" size={60} color={theme.colors.grey3} />
          </View>
        )}

        {/* Header info */}
        <View style={styles.headerContainer}>
          <View style={styles.titleContainer}>
            <Text style={styles.title}>{venue.name}</Text>
            {venue.rating ? (
              <View style={styles.ratingContainer}>
                <Text style={styles.rating}>{venue.rating.toFixed(1)}</Text>
                <Icon name="star" size={16} color={theme.colors.warning} />
              </View>
            ) : null}
          </View>

          {categoryText ? (
            <Text style={styles.category}>{categoryText}</Text>
          ) : null}

          <View style={styles.tagsContainer}>
            {priceText ? <Chip title={priceText} type="outline" /> : null}
            {distance ? <Chip title={distance} type="outline" /> : null}
            {venue.hours?.isOpen !== undefined && (
              <Chip
                title={venue.hours.isOpen ? 'Open' : 'Closed'}
                type="outline"
                titleStyle={{
                  color: venue.hours.isOpen ? theme.colors.success : theme.colors.error,
                }}
              />
            )}
          </View>

          {/* Hours */}
          {venue.hours?.displayHours && venue.hours.displayHours.length > 0 && (
            <View style={styles.hoursContainer}>
              <Text style={styles.sectionTitle}>Hours</Text>
              {venue.hours.displayHours.map((hour, index) => (
                <Text key={index} style={styles.hourText}>{hour}</Text>
              ))}
            </View>
          )}
        </View>

        <Divider style={styles.divider} />

        {/* Action buttons */}
        <View style={styles.actionsContainer}>
          <Button
            title={isBucketListed ? "Saved" : "Save"}
            icon={{
              name: isBucketListed ? 'bookmark' : 'bookmark-outline',
              type: 'material-community',
              color: isBucketListed ? 'white' : theme.colors.primary,
            }}
            onPress={handleBucketListToggle}
            type={isBucketListed ? "solid" : "outline"}
            buttonStyle={styles.actionButton}
          />

          <Button
            title="Directions"
            icon={{
              name: 'directions',
              type: 'material',
              color: theme.colors.primary,
            }}
            type="outline"
            onPress={handleDirections}
            buttonStyle={styles.actionButton}
          />

          {venue.contact?.phone && (
            <Button
              title="Call"
              icon={{
                name: 'phone',
                type: 'material',
                color: theme.colors.primary,
              }}
              type="outline"
              onPress={handleCall}
              buttonStyle={styles.actionButton}
            />
          )}
        </View>

        {/* Additional actions for bucket list items */}
        {isBucketListed && (
          <View style={styles.bucketListActionsContainer}>
            <Button
              title="Edit Details"
              icon={{
                name: 'edit',
                type: 'material',
                color: theme.colors.primary,
              }}
              type="clear"
              onPress={handleEditBucketList}
              titleStyle={styles.smallButtonTitle}
              buttonStyle={styles.smallButton}
            />

            {!bucketListItem?.visitedAt && (
              <Button
                title="Mark as Visited"
                icon={{
                  name: 'check-circle',
                  type: 'material',
                  color: theme.colors.success,
                }}
                type="clear"
                onPress={handleMarkAsVisited}
                titleStyle={[styles.smallButtonTitle, { color: theme.colors.success }]}
                buttonStyle={styles.smallButton}
              />
            )}
          </View>
        )}

        <Divider style={styles.divider} />

        {/* Address */}
        {venue.location?.formattedAddress && (
          <View style={styles.sectionContainer}>
            <Text style={styles.sectionTitle}>Address</Text>
            <View style={styles.addressContainer}>
              <Icon name="place" size={20} color={theme.colors.grey3} />
              <Text style={styles.address}>
                {typeof venue.location.formattedAddress === 'string'
                  ? venue.location.formattedAddress
                  : venue.location.formattedAddress.join(', ')}
              </Text>
            </View>
          </View>
        )}

        {/* Map */}
        {venue.location?.lat && venue.location?.lng && (
          <View style={styles.mapContainer}>
            <MapView
              style={styles.map}
              initialRegion={{
                latitude: venue.location.lat,
                longitude: venue.location.lng,
                latitudeDelta: 0.005,
                longitudeDelta: 0.005,
              }}
            >
              <Marker
                coordinate={{
                  latitude: venue.location.lat,
                  longitude: venue.location.lng,
                }}
                title={venue.name}
                description={categoryText}
              />
            </MapView>
            <TouchableOpacity
              style={styles.directionsButton}
              onPress={handleDirections}
              accessible={true}
              accessibilityLabel="Get directions to this venue"
              accessibilityRole="button"
            >
              <Text style={styles.directionsButtonText}>Directions</Text>
              <Icon name="directions" type="material" size={16} color="white" />
            </TouchableOpacity>
          </View>
        )}

        {/* Bucket list notes */}
        {isBucketListed && bucketListItem?.notes && (
          <View style={styles.sectionContainer}>
            <Text style={styles.sectionTitle}>Your Notes</Text>
            <Text style={styles.notes}>{bucketListItem.notes}</Text>
          </View>
        )}

        {/* Visit details */}
        {isBucketListed && bucketListItem?.visitedAt && (
          <View style={styles.sectionContainer}>
            <Text style={styles.sectionTitle}>Your Visit</Text>
            <Text style={styles.visitedDate}>
              Visited on {new Date(bucketListItem.visitedAt).toLocaleDateString()}
            </Text>

            {bucketListItem.rating && (
              <View style={styles.userRatingContainer}>
                <Text style={styles.userRatingLabel}>Your Rating: </Text>
                <View style={styles.userRatingStars}>
                  {Array.from({ length: 5 }).map((_, i) => (
                    <Icon
                      key={i}
                      name="star"
                      type="material"
                      size={20}
                      color={i < bucketListItem.rating! ? theme.colors.warning : theme.colors.grey4}
                    />
                  ))}
                </View>
              </View>
            )}

            {bucketListItem.review && (
              <View style={styles.reviewContainer}>
                <Text style={styles.reviewLabel}>Your Review:</Text>
                <Text style={styles.review}>{bucketListItem.review}</Text>
              </View>
            )}
          </View>
        )}

        {/* Description */}
        {venue.description && (
          <View style={styles.sectionContainer}>
            <Text style={styles.sectionTitle}>About</Text>
            <Text style={styles.description}>{venue.description}</Text>
          </View>
        )}

        {/* Website */}
        {venue.url && (
          <View style={styles.sectionContainer}>
            <Text style={styles.sectionTitle}>Website</Text>
            <TouchableOpacity
              onPress={handleOpenWebsite}
              style={styles.websiteButton}
              accessible={true}
              accessibilityLabel="Visit website"
              accessibilityRole="button"
            >
              <Text style={styles.websiteButtonText}>{venue.url}</Text>
              <Icon name="open-in-new" type="material" size={16} color={theme.colors.primary} />
            </TouchableOpacity>
          </View>
        )}

        {/* Contact */}
        {(venue.contact?.phone || venue.contact?.formattedPhone) && (
          <View style={styles.sectionContainer}>
            <Text style={styles.sectionTitle}>Contact</Text>
            <TouchableOpacity
              onPress={handleCall}
              style={styles.contactButton}
              accessible={true}
              accessibilityLabel={`Call ${venue.name}`}
              accessibilityRole="button"
            >
              <Icon name="phone" type="material" size={20} color={theme.colors.primary} />
              <Text style={styles.contactButtonText}>
                {venue.contact.formattedPhone || venue.contact.phone}
              </Text>
            </TouchableOpacity>
          </View>
        )}

        {/* Bottom padding */}
        <View style={{ height: 80 }} />
      </ScrollView>

      {/* Add to Bucket List Form Overlay */}
      <Overlay
        isVisible={formVisible}
        onBackdropPress={() => setFormVisible(false)}
        overlayStyle={styles.formOverlay}
      >
        <BucketListItemForm
          venueId={venueId}
          initialData={isBucketListed ? {
            notes: bucketListItem?.notes,
            tags: bucketListItem?.tags,
            priority: bucketListItem?.priority,
            plannedVisitDate: bucketListItem?.plannedVisitDate
              ? new Date(bucketListItem.plannedVisitDate)
              : undefined,
          } : undefined}
          onSubmit={handleFormSubmit}
          onCancel={() => setFormVisible(false)}
        />
      </Overlay>

      {/* Mark as Visited Overlay */}
      <Overlay
        isVisible={visitedModalVisible}
        onBackdropPress={() => setVisitedModalVisible(false)}
        overlayStyle={styles.formOverlay}
      >
        <View style={styles.visitedForm}>
          <Text style={styles.formTitle}>Mark as Visited</Text>

          <Text style={styles.formLabel}>How would you rate your experience?</Text>
          <View style={styles.ratingInputContainer}>
            {Array.from({ length: 5 }).map((_, i) => (
              <TouchableOpacity
                key={i}
                onPress={() => setRating(i + 1)}
                style={styles.ratingButton}
                accessible={true}
                accessibilityLabel={`Rate ${i + 1} stars`}
                accessibilityRole="button"
              >
                <Icon
                  name="star"
                  type="material"
                  size={32}
                  color={i < rating ? theme.colors.warning : theme.colors.grey4}
                />
              </TouchableOpacity>
            ))}
          </View>

          <Text style={styles.formLabel}>Add a review (optional)</Text>
          <TextInput
            style={styles.reviewInput}
            value={review}
            onChangeText={setReview}
            placeholder="Share your experience..."
            multiline
            numberOfLines={4}
            textAlignVertical="top"
          />

          <View style={styles.formButtons}>
            <Button
              title="Cancel"
              type="outline"
              onPress={() => setVisitedModalVisible(false)}
            />
            <Button
              title="Submit"
              onPress={handleVisitedSubmit}
              disabled={rating === 0}
            />
          </View>
        </View>
      </Overlay>

      {/* FAB for quick actions */}
      <FAB
        visible={true}
        icon={{ name: isBucketListed ? 'bookmark' : 'bookmark-outline', type: 'material-community', color: 'white' }}
        color={theme.colors.primary}
        placement="right"
        onPress={handleBucketListToggle}
        title={isBucketListed ? "Saved" : "Save"}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: 'white',
  },
  scrollContainer: {
    flexGrow: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  loadingText: {
    marginTop: 16,
    fontSize: 16,
    color: theme.colors.grey3,
  },
  mainImage: {
    width: '100%',
    height: 250,
  },
  placeholderImage: {
    backgroundColor: theme.colors.grey5,
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerContainer: {
    padding: 16,
  },
  titleContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 4,
  },
  title: {
    fontSize: 22,
    fontWeight: 'bold',
    flex: 1,
    marginRight: 8,
  },
  ratingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: theme.colors.grey5,
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  rating: {
    fontSize: 16,
    fontWeight: 'bold',
    marginRight: 2,
  },
  category: {
    fontSize: 16,
    color: theme.colors.grey3,
    marginBottom: 12,
  },
  tagsContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: 8,
    marginBottom: 12,
  },
  hoursContainer: {
    marginTop: 8,
  },
  hourText: {
    fontSize: 14,
    marginBottom: 2,
    color: theme.colors.grey2,
  },
  divider: {
    marginVertical: 8,
  },
  actionsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    padding: 8,
    marginHorizontal: 8,
  },
  actionButton: {
    paddingHorizontal: 12,
    minWidth: 100,
  },
  bucketListActionsContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    padding: 8,
  },
  smallButton: {
    paddingHorizontal: 8,
  },
  smallButtonTitle: {
    fontSize: 12,
  },
  sectionContainer: {
    padding: 16,
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 8,
    color: theme.colors.grey1,
  },
  addressContainer: {
    flexDirection: 'row',
    alignItems: 'flex-start',
  },
  address: {
    fontSize: 16,
    flex: 1,
    marginLeft: 8,
    color: theme.colors.grey2,
  },
  mapContainer: {
    height: 200,
    marginHorizontal: 16,
    marginBottom: 16,
    borderRadius: 8,
    overflow: 'hidden',
  },
  map: {
    ...StyleSheet.absoluteFillObject,
  },
  directionsButton: {
    position: 'absolute',
    bottom: 12,
    right: 12,
    backgroundColor: theme.colors.primary,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
  },
  directionsButtonText: {
    color: 'white',
    fontWeight: 'bold',
    marginRight: 4,
  },
  notes: {
    fontSize: 16,
    color: theme.colors.grey2,
    backgroundColor: theme.colors.grey5,
    padding: 12,
    borderRadius: 8,
    fontStyle: 'italic',
  },
  visitedDate: {
    fontSize: 16,
    color: theme.colors.grey2,
    marginBottom: 8,
  },
  userRatingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginVertical: 8,
  },
  userRatingLabel: {
    fontSize: 16,
    color: theme.colors.grey2,
  },
  userRatingStars: {
    flexDirection: 'row',
    marginLeft: 8,
  },
  reviewContainer: {
    marginTop: 8,
  },
  reviewLabel: {
    fontSize: 16,
    color: theme.colors.grey2,
    marginBottom: 4,
  },
  review: {
    fontSize: 16,
    color: theme.colors.grey2,
    backgroundColor: theme.colors.grey5,
    padding: 12,
    borderRadius: 8,
  },
  description: {
    fontSize: 16,
    color: theme.colors.grey2,
    lineHeight: 22,
  },
  websiteButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: theme.colors.grey5,
    padding: 12,
    borderRadius: 8,
  },
  websiteButtonText: {
    fontSize: 16,
    color: theme.colors.primary,
    flex: 1,
  },
  contactButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: theme.colors.grey5,
    padding: 12,
    borderRadius: 8,
  },
  contactButtonText: {
    fontSize: 16,
    color: theme.colors.primary,
    marginLeft: 8,
  },
  formOverlay: {
    width: '90%',
    maxWidth: 400,
    borderRadius: 8,
    padding: 0,
  },
  visitedForm: {
    padding: 20,
  },
  formTitle: {
    fontSize: 20,
    fontWeight: 'bold',
    marginBottom: 16,
    textAlign: 'center',
  },
  formLabel: {
    fontSize: 16,
    marginBottom: 8,
    color: theme.colors.grey1,
  },
  ratingInputContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    marginBottom: 20,
  },
  ratingButton: {
    padding: 8,
  },
  reviewInput: {
    borderWidth: 1,
    borderColor: theme.colors.grey4,
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    height: 120,
    marginBottom: 20,
  },
  formButtons: {
    flexDirection: 'row',
    justifyContent: 'space-around',
  },
});

// Add TextInput component import at the top of the file
import { TextInput } from 'react-native';

--- File: packages/mobile/src/navigation/LocationPermissionRequest.tsx ---
// packages/mobile/src/components/common/LocationPermissionRequest.tsx

import React from 'react';
import { View, Text, StyleSheet, Image, Linking, Platform, ScrollView } from 'react-native';
import { Button, Icon } from '@rneui/themed';
import { SafeAreaView } from 'react-native-safe-area-context';
import { theme } from '../../theme';

interface LocationPermissionRequestProps {
  onRequestLocation: () => void;
}

/**
 * Location Permission Request Component
 * - Explains why the app needs location access
 * - Provides options to grant permission or open settings
 * - Fully accessible with clear instructions
 */
export const LocationPermissionRequest: React.FC<LocationPermissionRequestProps> = ({
  onRequestLocation,
}) => {
  // Open app settings
  const openSettings = () => {
    Linking.openSettings();
  };

  return (
    <SafeAreaView style={styles.safeArea}>
      <ScrollView contentContainerStyle={styles.container} showsVerticalScrollIndicator={false}>
        <View style={styles.iconContainer}>
          <Icon
            name="location-on"
            type="material"
            size={80}
            color={theme.colors.primary}
            containerStyle={styles.icon}
          />
        </View>

        <Text style={styles.title}>Location Access Needed</Text>

        <Text style={styles.description}>
          Restaurant Bucket List needs access to your location to find restaurants near you. We use
          this information only to show you relevant results and never track or store your location
          data.
        </Text>

        <View style={styles.benefitsContainer}>
          <View style={styles.benefitItem}>
            <Icon name="place" type="material" size={24} color={theme.colors.primary} />
            <Text style={styles.benefitText}>Discover nearby restaurants</Text>
          </View>

          <View style={styles.benefitItem}>
            <Icon name="star" type="material" size={24} color={theme.colors.primary} />
            <Text style={styles.benefitText}>Get personalized recommendations</Text>
          </View>

          <View style={styles.benefitItem}>
            <Icon name="directions" type="material" size={24} color={theme.colors.primary} />
            <Text style={styles.benefitText}>See distances and get directions</Text>
          </View>
        </View>

        <View style={styles.buttonsContainer}>
          <Button
            title="Allow Location Access"
            onPress={onRequestLocation}
            buttonStyle={styles.primaryButton}
            titleStyle={styles.buttonTitle}
            icon={{
              name: 'location-on',
              type: 'material',
              size: 20,
              color: 'white',
            }}
            iconRight={false}
            iconContainerStyle={styles.buttonIcon}
            accessible={true}
            accessibilityLabel="Allow location access"
            accessibilityRole="button"
          />

          <Button
            title="Open Settings"
            onPress={openSettings}
            type="outline"
            buttonStyle={styles.secondaryButton}
            titleStyle={styles.secondaryButtonTitle}
            icon={{
              name: 'settings',
              type: 'material',
              size: 20,
              color: theme.colors.primary,
            }}
            iconRight={false}
            iconContainerStyle={styles.buttonIcon}
            accessible={true}
            accessibilityLabel="Open app settings"
            accessibilityRole="button"
          />

          <Text style={styles.privacyNote}>
            You can change this permission later in your device settings.
          </Text>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: 'white',
  },
  container: {
    flexGrow: 1,
    alignItems: 'center',
    padding: 24,
    justifyContent: 'center',
  },
  iconContainer: {
    width: 140,
    height: 140,
    borderRadius: 70,
    backgroundColor: theme.colors.grey5,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 24,
  },
  icon: {
    marginBottom: 8,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    textAlign: 'center',
    color: theme.colors.grey1,
  },
  description: {
    fontSize: 16,
    textAlign: 'center',
    marginBottom: 32,
    color: theme.colors.grey2,
    lineHeight: 24,
  },
  benefitsContainer: {
    width: '100%',
    marginBottom: 32,
  },
  benefitItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
    paddingHorizontal: 8,
  },
  benefitText: {
    fontSize: 16,
    marginLeft: 12,
    color: theme.colors.grey2,
  },
  buttonsContainer: {
    width: '100%',
    alignItems: 'center',
  },
  primaryButton: {
    backgroundColor: theme.colors.primary,
    borderRadius: 8,
    paddingVertical: 12,
    width: '100%',
    marginBottom: 16,
  },
  buttonTitle: {
    fontSize: 16,
    fontWeight: '600',
  },
  secondaryButton: {
    borderColor: theme.colors.primary,
    borderRadius: 8,
    paddingVertical: 12,
    width: '100%',
    marginBottom: 20,
  },
  secondaryButtonTitle: {
    color: theme.colors.primary,
    fontSize: 16,
    fontWeight: '600',
  },
  buttonIcon: {
    marginRight: 8,
  },
  privacyNote: {
    fontSize: 14,
    textAlign: 'center',
    color: theme.colors.grey3,
    marginTop: 8,
  },
});


--- File: packages/mobile/src/navigation/MainNavigator.tsx ---
import React from 'react';
import { createStackNavigator } from '@react-navigation/stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { NavigationContainer } from '@react-navigation/native';
import { Text } from 'react-native';
import { useAppSelector } from 'core/src';
import { theme } from '../theme';

// Import screens
import HomeScreen from '../components/screens/HomeScreen';
import SearchScreen from '../components/screens/SearchScreen';
import BucketListScreen from '../components/screens/BucketListScreen';
import ProfileScreen from '../components/screens/ProfileScreen';
import DetailsScreen from '../components/screens/DetailsScreen';

// Import types
import { RootStackParamList, MainTabParamList } from './types';

// Create navigators
const Stack = createStackNavigator<RootStackParamList>();
const Tab = createBottomTabNavigator<MainTabParamList>();

/**
 * Bottom Tab Navigator
 * - Provides the main navigation tabs for the app
 * - Includes icons and labels for each tab
 */
const MainTabNavigator = () => {
  return (
    <Tab.Navigator
      screenOptions={{
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.grey3,
        tabBarLabelStyle: {
          fontSize: 12,
          fontWeight: '500',
        },
        headerShown: false,
      }}
    >
      <Tab.Screen
        name="Home"
        component={HomeScreen}
        options={{
          tabBarIcon: ({ color, size }) => (
            <Text style={{ color, fontSize: size }}>🏠</Text>
          ),
        }}
      />
      <Tab.Screen
        name="Search"
        component={SearchScreen}
        options={{
          tabBarIcon: ({ color, size }) => (
            <Text style={{ color, fontSize: size }}>🔍</Text>
          ),
        }}
      />
      <Tab.Screen
        name="BucketList"
        component={BucketListScreen}
        options={{
          tabBarIcon: ({ color, size }) => (
            <Text style={{ color, fontSize: size }}>📋</Text>
          ),
        }}
      />
      <Tab.Screen
        name="Profile"
        component={ProfileScreen}
        options={{
          tabBarIcon: ({ color, size }) => (
            <Text style={{ color, fontSize: size }}>👤</Text>
          ),
        }}
      />
    </Tab.Navigator>
  );
};

/**
 * Main Navigation Container
 * - Wraps the entire app navigation
 * - Handles authentication state
 * - Provides screen transitions
 */
export const MainNavigator = () => {
  // Default screen options
  const screenOptions = {
    headerStyle: {
      backgroundColor: theme.colors.primary,
    },
    headerTintColor: 'white',
    headerTitleStyle: {
      fontWeight: 'bold',
    },
    cardStyle: {
      backgroundColor: 'white',
    },
  };

  return (
    <NavigationContainer>
      <Stack.Navigator
        screenOptions={screenOptions}
        initialRouteName="Main"
      >
        <Stack.Screen
          name="Main"
          component={MainTabNavigator}
          options={{ headerShown: false }}
        />
        <Stack.Screen
          name="Details"
          component={DetailsScreen}
          options={({ route }) => ({
            title: `Details: ${route.params.id}`,
            headerBackTitle: 'Back',
          })}
        />
      </Stack.Navigator>
    </NavigationContainer>
  );
};

export default MainNavigator;


--- File: packages/mobile/src/navigation/types.ts ---
import { StackNavigationProp } from '@react-navigation/stack';
import { BottomTabNavigationProp } from '@react-navigation/bottom-tabs';
import { CompositeNavigationProp } from '@react-navigation/native';

// Define root stack param list
export type RootStackParamList = {
  Main: undefined;
  Details: { id: string };
};

// Define bottom tab param list
export type MainTabParamList = {
  Home: undefined;
  Search: undefined;
  BucketList: undefined;
  Profile: undefined;
};

// Define combined navigation types
export type HomeNavigationProp = CompositeNavigationProp<
  BottomTabNavigationProp<MainTabParamList, 'Home'>,
  StackNavigationProp<RootStackParamList>
>;

export type SearchNavigationProp = CompositeNavigationProp<
  BottomTabNavigationProp<MainTabParamList, 'Search'>,
  StackNavigationProp<RootStackParamList>
>;

export type BucketListNavigationProp = CompositeNavigationProp<
  BottomTabNavigationProp<MainTabParamList, 'BucketList'>,
  StackNavigationProp<RootStackParamList>
>;

export type ProfileNavigationProp = CompositeNavigationProp<
  BottomTabNavigationProp<MainTabParamList, 'Profile'>,
  StackNavigationProp<RootStackParamList>
>;


--- File: packages/mobile/src/theme/categories.ts ---
  export const categories = [
    {
      id: '13065',
      name: 'Restaurant',
      icon: 'restaurant',
      color: theme.lightColors.primary,
    },
    {
      id: '13034',
      name: 'Cafe',
      icon: 'local-cafe',
      color: '#8D6E63',
    },
    {
      id: '13003',
      name: 'Bar',
      icon: 'local-bar',
      color: '#7B1FA2',
    },
    {
      id: '13145',
      name: 'Fast Food',
      icon: 'fastfood',
      color: '#F57C00',
    },
    {
      id: '13350',
      name: 'Pizza',
      icon: 'local-pizza',
      color: '#D32F2F',
    },
    {
      id: '13274',
      name: 'Breakfast',
      icon: 'free-breakfast',
      color: '#FFA000',
    },
    {
      id: '13065',
      name: 'Dessert',
      icon: 'cake',
      color: '#FBC02D',
    },
    {
      id: '13065',
      name: 'Ice Cream',
      icon: 'icecream',
      color: '#FFB74D',
    },
    {
      id: '13065',
      name: 'Bakery',
      icon: 'bakery_dining',
      color: '#FF7043',
    }]



--- File: packages/mobile/src/theme/index.ts ---
/**
 * Theme colors and styles for the app
 */
export const theme = {
  colors: {
    primary: '#FF5A5F', // Airbnb-inspired red
    primaryDark: '#E04146',
    primaryLight: '#FF8A8F',
    secondary: '#00A699', // Teal
    background: '#FFFFFF',
    backgroundDark: '#121212',
    surface: '#FFFFFF',
    surfaceDark: '#1E1E1E',
    error: '#F44336',
    warning: '#FF9800',
    success: '#4CAF50',
    info: '#2196F3',
    
    // Gray scale
    grey1: '#212121',
    grey2: '#424242',
    grey3: '#757575',
    grey4: '#BDBDBD',
    grey5: '#E0E0E0',
    grey6: '#F5F5F5',
    
    // Text colors
    text: '#212121',
    textSecondary: '#757575',
    textDark: '#FFFFFF',
    textSecondaryDark: '#BDBDBD',
  },
  
  // Typography
  typography: {
    h1: {
      fontSize: 32,
      fontWeight: 'bold',
    },
    h2: {
      fontSize: 24,
      fontWeight: 'bold',
    },
    body1: {
      fontSize: 16,
    },
    body2: {
      fontSize: 14,
    },
  },
  
  // Spacing
  spacing: {
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32,
  },
  
  // Radius
  radius: {
    sm: 4,
    md: 8,
    lg: 16,
    round: 9999,
  },
};

/**
 * Get theme based on mode
 * @param mode 'light' or 'dark'
 */
export const getTheme = (mode: 'light' | 'dark') => {
  const baseTheme = { ...theme };
  
  if (mode === 'dark') {
    return {
      ...baseTheme,
      colors: {
        ...baseTheme.colors,
        background: baseTheme.colors.backgroundDark,
        surface: baseTheme.colors.surfaceDark,
        text: baseTheme.colors.textDark,
        textSecondary: baseTheme.colors.textSecondaryDark,
      },
    };
  }
  
  return baseTheme;
};


--- File: packages/mobile/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "jsx": "react-native",
    "lib": ["es2019", "dom"],
    "moduleResolution": "node",
    "noEmit": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "target": "esnext",
    "allowSyntheticDefaultImports": true,
    "baseUrl": ".",
    "paths": {
      "core/*": ["../core/src/*"]
    },
    "types": ["react-native"]
  },
  "include": ["src/**/*", "App.tsx"],
  "exclude": [
    "node_modules",
    "babel.config.js",
    "metro.config.js",
    "jest.config.js",
    "**/*.spec.ts",
    "**/*.test.ts"
  ]
}


--- File: packages/web/package.json ---
{
  "name": "web",
  "version": "1.0.0",
  "description": "React web app for Restaurant Bucket List",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.10.8",
    "@emotion/styled": "^11.10.8",
    "@mui/icons-material": "^5.11.16",
    "@mui/material": "^5.12.3",
    "core": "1.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-redux": "^8.0.5",
    "react-router-dom": "^6.11.0",
    "react-scripts": "5.0.1"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/react": "^14.0.0",
    "@testing-library/user-event": "^14.4.3",
    "@types/jest": "^29.5.1",
    "@types/node": "^18.16.3",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.1",
    "rimraf": "^5.0.0",
    "typescript": "^5.0.4",
    "web-vitals": "^3.3.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "clean": "rimraf ./build",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}


--- File: packages/web/src/App.tsx ---
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { useAppSelector } from 'core/src';
import HomePage from './components/pages/HomePage';

function App() {
  const theme = useAppSelector(state => state.ui.theme);
  
  return (
    <div className={`app ${theme}`}>
      <Router>
        <Routes>
          <Route path="/" element={<HomePage />} />
          {/* Add more routes as needed */}
        </Routes>
      </Router>
    </div>
  );
}

export default App;


--- File: packages/web/src/components/pages/HomePage.tsx ---
import React from 'react';

const HomePage: React.FC = () => {
  return (
    <div style={{ padding: '2rem', textAlign: 'center' }}>
      <h1>Restaurant Bucket List</h1>
      <p>
        Welcome to the Restaurant Bucket List web application. This is a stub component that will be
        replaced with the actual implementation.
      </p>
    </div>
  );
};

export default HomePage;


--- File: packages/web/src/index.tsx ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import { PersistGate } from 'redux-persist/integration/react';
import { store, persistor } from 'core/src/store';
import App from './App';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(
  <React.StrictMode>
    <Provider store={store}>
      <PersistGate loading={null} persistor={persistor}>
        <App />
      </PersistGate>
    </Provider>
  </React.StrictMode>
);


--- File: packages/web/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "core/*": ["../core/src/*"]
    }
  },
  "include": ["src"],
  "exclude": ["node_modules", "**/*.spec.ts", "**/*.test.ts"]
}


--- File: tsconfig.json ---
{
  "compilerOptions": {
    "target": "es2016",
    "module": "esnext",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "jsx": "react-jsx",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "allowSyntheticDefaultImports": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "core/*": ["packages/core/*"]
    }
  },
  "exclude": ["node_modules", "**/*.spec.ts", "**/*.test.ts"],
  "references": [
    { "path": "./packages/core" },
    { "path": "./packages/mobile" },
    { "path": "./packages/web" }
  ]
}



--- File: package.json ---
{
  "name": "restaurant-bucket-list",
  "version": "1.0.0",
  "description": "A cross-platform application to discover, save, and track restaurants you want to visit",
  "private": true,
  "workspaces": [
    "packages/*"
  ],
  "scripts": {
    "start": "yarn workspaces run start",
    "build": "yarn workspaces run build",
    "test": "yarn workspaces run test",
    "lint": "yarn workspaces run lint",
    "clean": "yarn workspaces run clean",
    "web:start": "yarn workspace web start",
    "mobile:start": "yarn workspace mobile start",
    "ios": "yarn workspace mobile ios",
    "android": "yarn workspace mobile android",
    "ios:pod-install": "cd packages/mobile/ios && pod install"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/your-username/restaurant-bucket-list.git"
  },
  "keywords": [
    "react",
    "react-native",
    "redux",
    "redux-saga",
    "typescript",
    "monorepo",
    "foursquare",
    "geolocation"
  ],
  "author": "Your Name",
  "license": "MIT",
  "devDependencies": {
    "@typescript-eslint/eslint-plugin": "^5.59.0",
    "@typescript-eslint/parser": "^5.59.0",
    "eslint": "^8.38.0",
    "eslint-config-prettier": "^8.8.0",
    "eslint-plugin-import": "^2.27.5",
    "eslint-plugin-jsx-a11y": "^6.7.1",
    "eslint-plugin-prettier": "^4.2.1",
    "eslint-plugin-react": "^7.32.2",
    "eslint-plugin-react-hooks": "^4.6.0",
    "husky": "^8.0.3",
    "lint-staged": "^13.2.1",
    "prettier": "^2.8.7",
    "typescript": "^5.0.4"
  }
}


--- File: packages/constants/categories.ts ---
import { theme } from '../theme';

/**
 * Restaurant categories based on Foursquare taxonomy
 * Each category has:
 * - id: Foursquare category ID
 * - name: Display name
 * - icon: Material icon name
 * - color: Brand color (optional)
 */
export const categories = [
  {
    id: '13065',
    name: 'Restaurant',
    icon: 'restaurant',
    color: theme.colors.primary,
  },
  {
    id: '13034',
    name: 'Cafe',
    icon: 'local-cafe',
    color: '#8D6E63',
  },
  {
    id: '13003',
    name: 'Bar',
    icon: 'local-bar',
    color: '#7B1FA2',
  },
  {
    id: '13145',
    name: 'Fast Food',
    icon: 'fastfood',
    color: '#F57C00',
  },
  {
    id: '13350',
    name: 'Pizza',
    icon: 'local-pizza',
    color: '#D32F2F',
  },
  {
    id: '13274',
    name: 'Breakfast',
    icon: 'free-breakfast',
    color: '#FFA000',
  },
  {
    id: '13072',
    name: 'Asian',
    icon: 'restaurant',
    color: '#00897B',
  },
  {
    id: '13236',
    name: 'Mexican',
    icon: 'restaurant',
    color: '#E64A19',
  },
  {
    id: '13005',
    name: 'Bakery',
    icon: 'cake',
    color: '#AD1457',
  },
  {
    id: '13285',
    name: 'American',
    icon: 'restaurant',
    color: '#0277BD',
  },
  {
    id: '13070',
    name: 'Italian',
    icon: 'restaurant',
    color: '#558B2F',
  },
  {
    id: '13074',
    name: 'Chinese',
    icon: 'restaurant',
    color: '#EF5350',
  },
  {
    id: '13265',
    name: 'Japanese',
    icon: 'restaurant',
    color: '#3949AB',
  },
  {
    id: '13199',
    name: 'Indian',
    icon: 'restaurant',
    color: '#FB8C00',
  },
  {
    id: '13080',
    name: 'Thai',
    icon: 'restaurant',
    color: '#AFB42B',
  },
  {
    id: '13142',
    name: 'Seafood',
    icon: 'set-meal',
    color: '#0097A7',
  },
  {
    id: '13303',
    name: 'Vegetarian',
    icon: 'eco',
    color: '#43A047',
  },
  {
    id: '13193',
    name: 'BBQ',
    icon: 'outdoor-grill',
    color: '#BF360C',
  },
  {
    id: '13377',
    name: 'Steakhouse',
    icon: 'restaurant',
    color: '#6D4C41',
  },
  {
    id: '13053',
    name: 'Food Truck',
    icon: 'local-shipping',
    color: '#607D8B',
  },
  {
    id: '13291',
    name: 'Dessert',
    icon: 'icecream',
    color: '#D81B60',
  },
  {
    id: '13339',
    name: 'Wine Bar',
    icon: 'wine-bar',
    color: '#8E24AA',
  },
  {
    id: '13375',
    name: 'Brewery',
    icon: 'sports-bar',
    color: '#5D4037',
  },
  {
    id: '13263',
    name: 'Sushi',
    icon: 'restaurant',
    color: '#00ACC1',
  },
];

/**
 * Find a category by ID
 */
export const getCategoryById = (id: string) => {
  return categories.find(category => category.id === id);
};

/**
 * Get a subset of categories
 */
export const getCategoriesSubset = (ids: string[]) => {
  return categories.filter(category => ids.includes(category.id));
};

/**
 * Get categories grouped by type
 */
export const getCategoriesGrouped = () => {
  const groups = [
    {
      title: 'Popular',
      data: categories.slice(0, 6),
    },
    {
      title: 'Cuisine Types',
      data: categories.filter(c => 
        ['Asian', 'Mexican', 'American', 'Italian', 'Chinese', 'Japanese', 'Indian', 'Thai'].includes(c.name)
      ),
    },
    {
      title: 'Meal Types',
      data: categories.filter(c => 
        ['Breakfast', 'Fast Food', 'Seafood', 'BBQ', 'Steakhouse', 'Dessert'].includes(c.name)
      ),
    },
    {
      title: 'Drinks & Others',
      data: categories.filter(c => 
        ['Cafe', 'Bar', 'Wine Bar', 'Brewery'].includes(c.name)
      ),
    },
  ];
  
  return groups;
};


--- File: packages/core/package.json ---
{
  "name": "core",
  "version": "1.0.0",
  "description": "Shared business logic and models for Restaurant Bucket List app",
  "main": "src/index.ts",
  "private": true,
  "scripts": {
    "build": "tsc",
    "clean": "rimraf ./dist",
    "test": "jest",
    "lint": "eslint . --ext .ts,.tsx"
  },
  "dependencies": {
    "@reduxjs/toolkit": "^1.9.5",
    "axios": "^1.4.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-redux": "^8.0.5",
    "redux": "^4.2.1",
    "redux-persist": "^6.0.0",
    "redux-saga": "^1.2.3"
  },
  "devDependencies": {
    "@testing-library/react-hooks": "^8.0.1",
    "@types/jest": "^29.5.1",
    "@types/node": "^18.16.3",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.1",
    "jest": "^29.5.0",
    "rimraf": "^5.0.0",
    "ts-jest": "^29.1.0",
    "typescript": "^5.0.4"
  },
  "peerDependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  }
}


--- File: packages/core/src/api/foursquare.ts ---
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';
import { 
  VenueSearchParams, 
  VenueSearchResponse, 
  VenueDetailsResponse,
  Coordinates
} from '../models/venue';

/**
 * Foursquare API service using modern patterns:
 * - TypeScript for type safety
 * - Axios for HTTP requests
 * - Environment variables for configuration
 * - Proper error handling
 * - Clean abstraction
 */
export class FoursquareService {
  private client: AxiosInstance;
  private static instance: FoursquareService;
  
  private constructor() {
    // Create axios instance with base configuration
    this.client = axios.create({
      baseURL: 'https://api.foursquare.com/v3',
      headers: {
        'Accept': 'application/json',
        'Authorization': `${process.env.FOURSQUARE_API_KEY}`
      }
    });
    
    // Add request interceptor for logging and modifying requests
    this.client.interceptors.request.use(
      (config) => {
        // Add any request modification here
        return config;
      },
      (error) => {
        return Promise.reject(error);
      }
    );
    
    // Add response interceptor for error handling
    this.client.interceptors.response.use(
      (response) => {
        return response;
      },
      (error) => {
        // Enhanced error handling
        if (error.response) {
          // Server responded with error status
          console.error('API Error:', error.response.status, error.response.data);
        } else if (error.request) {
          // Request made but no response received
          console.error('Network Error:', error.request);
        } else {
          // Error in setting up request
          console.error('Request Error:', error.message);
        }
        return Promise.reject(error);
      }
    );
  }
  
  /**
   * Get singleton instance of the service
   */
  public static getInstance(): FoursquareService {
    if (!FoursquareService.instance) {
      FoursquareService.instance = new FoursquareService();
    }
    return FoursquareService.instance;
  }
  
  /**
   * Search for venues near the specified location
   */
  public async searchVenues(params: VenueSearchParams): Promise<VenueSearchResponse> {
    try {
      const response = await this.client.get('/places/search', {
        params: {
          ...params,
          limit: params.limit || 20,
          sort: params.sort || 'DISTANCE'
        }
      });
      return response.data;
    } catch (error) {
      console.error('Failed to search venues:', error);
      throw error;
    }
  }
  
  /**
   * Get venue details by ID
   */
  public async getVenueDetails(venueId: string): Promise<VenueDetailsResponse> {
    try {
      const response = await this.client.get(`/places/${venueId}`);
      return response.data;
    } catch (error) {
      console.error(`Failed to get venue details for ID ${venueId}:`, error);
      throw error;
    }
  }
  
  /**
   * Search venues near the user's current location
   */
  public async searchNearbyVenues(
    coordinates: Coordinates,
    query?: string,
    categories?: string[],
    radius: number = 1000,
    limit: number = 20
  ): Promise<VenueSearchResponse> {
    const params: VenueSearchParams = {
      ll: `${coordinates.latitude},${coordinates.longitude}`,
      radius,
      limit
    };
    
    if (query) {
      params.query = query;
    }
    
    if (categories && categories.length > 0) {
      params.categories = categories.join(',');
    }
    
    return this.searchVenues(params);
  }
  
  /**
   * Get recommended venues near the specified location
   */
  public async getRecommendedVenues(
    coordinates: Coordinates,
    limit: number = 10
  ): Promise<VenueSearchResponse> {
    return this.searchVenues({
      ll: `${coordinates.latitude},${coordinates.longitude}`,
      limit,
      sort: 'RATING'
    });
  }
}

// Export a singleton instance
export const foursquareService = FoursquareService.getInstance();


--- File: packages/core/src/hooks/useGeolocation.ts ---
import { useEffect, useState, useCallback } from 'react';
import { useAppDispatch, useAppSelector } from '../store';
import { 
  getUserLocation, 
  setLocationPermission 
} from '../store/slices/venuesSlice';
import { Coordinates } from '../models/venue';

interface GeolocationHook {
  coordinates: Coordinates | null;
  loading: boolean;
  error: string | null;
  permissionGranted: boolean;
  requestLocation: () => void;
}

/**
 * Custom hook for getting and tracking user location
 */
export const useGeolocation = (): GeolocationHook => {
  const dispatch = useAppDispatch();
  const coordinates = useAppSelector(state => state.venues.userLocation);
  const permissionGranted = useAppSelector(state => state.venues.locationPermissionGranted);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);

  // Request location permissions and get location
  const requestLocation = useCallback(() => {
    setLoading(true);
    setError(null);
    dispatch(getUserLocation());
  }, [dispatch]);

  // Check for location permissions on mount
  useEffect(() => {
    // Check if geolocation is available
    if (!navigator.geolocation) {
      setError('Geolocation is not supported by your browser');
      return;
    }

    // Check permission status if available
    if (navigator.permissions && navigator.permissions.query) {
      navigator.permissions
        .query({ name: 'geolocation' as PermissionName })
        .then(result => {
          if (result.state === 'granted') {
            dispatch(setLocationPermission(true));
            requestLocation();
          } else if (result.state === 'prompt') {
            // We'll wait for user to explicitly request location
            dispatch(setLocationPermission(false));
          } else if (result.state === 'denied') {
            dispatch(setLocationPermission(false));
            setError('Location permission denied');
          }

          // Listen for permission changes
          result.addEventListener('change', () => {
            dispatch(setLocationPermission(result.state === 'granted'));
            
            if (result.state === 'granted') {
              requestLocation();
            }
          });
        })
        .catch(err => {
          console.error('Error checking geolocation permission:', err);
        });
    }
  }, [dispatch, requestLocation]);

  // Update loading state when coordinates change
  useEffect(() => {
    if (coordinates) {
      setLoading(false);
    }
  }, [coordinates]);

  return {
    coordinates,
    loading,
    error,
    permissionGranted,
    requestLocation
  };
};


--- File: packages/core/src/index.ts ---
// Export models
export * from './models/venue';
export * from './models/bucket-list';
export * from './models/user';
export * from './models/app-state';

// Export API services
export * from './api/foursquare';

// Export hooks
export * from './hooks/useGeolocation';

// Export store
export * from './store';
export * from './store/slices/venuesSlice';
export * from './store/slices/bucketListSlice';
export * from './store/slices/authSlice';
export * from './store/slices/uiSlice';


--- File: packages/core/src/models/app-state.ts ---
/**
 * Global application state
 */
export interface AppState {
  auth: AuthState;
  ui: UIState;
}

/**
 * Authentication state
 */
export interface AuthState {
  isAuthenticated: boolean;
  user: UserProfile | null;
  loading: boolean;
  error: string | null;
}

/**
 * User profile information
 */
export interface UserProfile {
  id: string;
  email: string;
  displayName?: string;
  photoUrl?: string;
}

/**
 * UI state
 */
export interface UIState {
  theme: 'light' | 'dark';
  networkStatus: 'online' | 'offline';
  hasCompletedOnboarding: boolean;
}


--- File: packages/core/src/models/bucket-list.ts ---
import { Venue } from './venue';

/**
 * User-specific bucket list item with additional metadata
 */
export interface BucketListItem {
  id: string;
  venueId: string;
  venue: Venue;
  userId: string;
  notes?: string;
  tags?: string[];
  priority?: 'low' | 'medium' | 'high';
  addedAt: number;
  plannedVisitDate?: number;
  visitedAt?: number;
  rating?: number;
  review?: string;
}

/**
 * Filter options for bucket list
 */
export interface BucketListFilter {
  tags?: string[];
  priority?: ('low' | 'medium' | 'high')[];
  visited?: boolean;
  searchTerm?: string;
  sortBy?: 'dateAdded' | 'name' | 'priority' | 'plannedDate';
  sortDirection?: 'asc' | 'desc';
}


--- File: packages/core/src/models/index.ts ---
export * from './app-state';
export * from './bucket-list';
export * from './user';
export * from './venue';


--- File: packages/core/src/models/user.ts ---
/**
 * User profile information
 */
export interface UserProfile {
  id: string;
  email: string;
  displayName?: string;
  photoUrl?: string;
  createdAt: number;
  lastLogin: number;
  preferences?: UserPreferences;
}

/**
 * User preferences
 */
export interface UserPreferences {
  darkMode?: boolean;
  defaultRadius?: number;
  defaultCategories?: string[];
  emailNotifications?: boolean;
  pushNotifications?: boolean;
}


--- File: packages/core/src/models/venue.ts ---
/**
 * Geographical coordinates
 */
export interface Coordinates {
  latitude: number;
  longitude: number;
}

/**
 * Parameters for venue search API
 */
export interface VenueSearchParams {
  // Required: Latitude and longitude
  ll: string;
  
  // Optional parameters
  query?: string;
  categories?: string;
  radius?: number;
  limit?: number;
  sort?: 'DISTANCE' | 'POPULARITY' | 'RATING';
  fields?: string[];
}

/**
 * Venue location information
 */
export interface VenueLocation {
  address?: string;
  city?: string;
  state?: string;
  country?: string;
  postalCode?: string;
  neighborhood?: string[];
  formattedAddress?: string;
  crossStreet?: string;
  lat: number;
  lng: number;
}

/**
 * Venue category
 */
export interface VenueCategory {
  id: string;
  name: string;
  icon: {
    prefix: string;
    suffix: string;
  };
  primary?: boolean;
}

/**
 * Venue hours
 */
export interface VenueHours {
  status?: string;
  isOpen?: boolean;
  openNow?: boolean;
  displayHours?: string[];
  regularHours?: {
    days: string;
    open: {
      start: string;
      end: string;
    }[];
  }[];
}

/**
 * Venue photo
 */
export interface VenuePhoto {
  id: string;
  prefix: string;
  suffix: string;
  width: number;
  height: number;
}

/**
 * Venue rating
 */
export interface VenueRating {
  rating: number;
  ratingColor: string;
  ratingSignals: number;
}

/**
 * Venue price information
 */
export interface VenuePrice {
  tier: number; // 1, 2, 3, or 4
  message: string; // "$", "$$", "$$$", "$$$$"
  currency?: string;
}

/**
 * Venue contact information
 */
export interface VenueContact {
  phone?: string;
  formattedPhone?: string;
  twitter?: string;
  instagram?: string;
  facebook?: string;
  email?: string;
  url?: string;
}

/**
 * Menu information
 */
export interface VenueMenu {
  url: string;
  mobileUrl: string;
  type: string;
  label: string;
}

/**
 * A venue/place from Foursquare API
 */
export interface Venue {
  id: string;
  name: string;
  location: VenueLocation;
  categories: VenueCategory[];
  photos?: VenuePhoto[];
  rating?: number;
  ratingColor?: string;
  price?: VenuePrice;
  hours?: VenueHours;
  contact?: VenueContact;
  description?: string;
  url?: string;
  menu?: VenueMenu;
  createdAt?: number;
  verified?: boolean;
  stats?: {
    tipCount: number;
    usersCount: number;
    checkinsCount: number;
  };
  likes?: {
    count: number;
    summary: string;
  };
  listed?: {
    count: number;
    groups: any[];
  };
  phrases?: {
    phrase: string;
    count: number;
  }[];
  attributes?: {
    groups: {
      type: string;
      name: string;
      summary: string;
      items: {
        displayName: string;
        displayValue: string;
      }[];
    }[];
  };
  distances?: number;
}

/**
 * Response from venue search API
 */
export interface VenueSearchResponse {
  results: Venue[];
  context: {
    geoBounds: {
      circle: {
        center: {
          latitude: number;
          longitude: number;
        };
        radius: number;
      };
    };
  };
  totalResults: number;
}

/**
 * Response from venue details API
 */
export interface VenueDetailsResponse {
  venue: Venue;
}


--- File: packages/core/src/store/index.ts ---
import { configureStore, combineReducers, getDefaultMiddleware } from '@reduxjs/toolkit';
import createSagaMiddleware from 'redux-saga';
import { all } from 'redux-saga/effects';
import { persistStore, persistReducer } from 'redux-persist';
import storage from 'redux-persist/lib/storage';

// Import reducers
import authReducer from './slices/authSlice';
import uiReducer from './slices/uiSlice';

// Configure redux-persist
const persistConfig = {
  key: 'root',
  storage,
  whitelist: ['auth', 'ui'], // Only persist these reducers
};

// Combine all reducers
const rootReducer = {
  auth: authReducer,
  ui: uiReducer,
};

// Root saga
function* rootSaga() {
  yield all([
    // Add sagas here
  ]);
}

// Setup saga middleware
const sagaMiddleware = createSagaMiddleware();

// Create persisted reducer
const persistedReducer = persistReducer(persistConfig, combineReducers(rootReducer));

// Configure store with middleware
export const store = configureStore({
  reducer: persistedReducer,
  middleware: [...getDefaultMiddleware({
    serializableCheck: {
      ignoredActions: ['persist/PERSIST'],
    },
    thunk: false,
  }), sagaMiddleware],
  devTools: process.env.NODE_ENV !== 'production',
});

// Run saga middleware
sagaMiddleware.run(rootSaga);

// Create persistor
export const persistor = persistStore(store);

// Export types
export type RootState = ReturnType<typeof store.getState>;
export type AppDispatch = typeof store.dispatch;

// Create typed hooks for use in components
import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';
export const useAppDispatch = () => useDispatch<AppDispatch>();
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;


--- File: packages/core/src/store/sagas/authSaga.ts ---
import { call, put, takeLatest } from 'redux-saga/effects';
import { PayloadAction } from '@reduxjs/toolkit';
import {
  login,
  loginSuccess,
  loginFailure,
  register,
  registerSuccess,
  registerFailure,
  logout,
  logoutSuccess,
  logoutFailure,
  resetPassword,
  resetPasswordSuccess,
  resetPasswordFailure,
  updateProfile,
  updateProfileSuccess,
  updateProfileFailure,
  socialLogin,
} from '../slices/authSlice';
import { UserProfile } from '../../models/user';

// Firebase service would be imported here
// import { firebaseService } from '../../api/firebase';

// This is a placeholder function for Firebase auth service
// In a real application, this would interact with Firebase Authentication
const signInWithEmailAndPassword = async (email: string, password: string): Promise<UserProfile> => {
  // Simulate API call
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Mock successful login
  const user: UserProfile = {
    id: 'user123',
    email,
    displayName: 'John Doe',
    photoUrl: 'https://example.com/profile.jpg',
    createdAt: Date.now() - 1000 * 60 * 60 * 24 * 30, // 30 days ago
    lastLogin: Date.now(),
  };
  
  return user;
};

// Placeholder for creating user with email and password
const createUserWithEmailAndPassword = async (
  email: string,
  password: string,
  displayName?: string
): Promise<UserProfile> => {
  // Simulate API call
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Mock successful registration
  const user: UserProfile = {
    id: 'user123',
    email,
    displayName: displayName || email.split('@')[0],
    createdAt: Date.now(),
    lastLogin: Date.now(),
  };
  
  return user;
};

// Placeholder for social auth
const signInWithProvider = async (provider: 'google' | 'apple' | 'facebook'): Promise<UserProfile> => {
  // Simulate API call
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Mock successful login
  const user: UserProfile = {
    id: 'user123',
    email: 'user@example.com',
    displayName: 'John Doe',
    photoUrl: 'https://example.com/profile.jpg',
    createdAt: Date.now() - 1000 * 60 * 60 * 24 * 30, // 30 days ago
    lastLogin: Date.now(),
  };
  
  return user;
};

// Placeholder for updating user profile
const updateUserProfile = async (
  userId: string,
  updates: Partial<UserProfile>
): Promise<UserProfile> => {
  // Simulate API call
  await new Promise(resolve => setTimeout(resolve, 1000));
  
  // Mock successful update
  const user: UserProfile = {
    id: userId,
    email: 'user@example.com',
    displayName: updates.displayName || 'John Doe',
    photoUrl: updates.photoUrl || 'https://example.com/profile.jpg',
    createdAt: Date.now() - 1000 * 60 * 60 * 24 * 30, // 30 days ago
    lastLogin: Date.now(),
    preferences: updates.preferences,
  };
  
  return user;
};

// Placeholder for signing out
const signOut = async (): Promise<void> => {
  // Simulate API call
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // No return value needed for sign out
};

// Placeholder for sending password reset email
const sendPasswordResetEmail = async (email: string): Promise<void> => {
  // Simulate API call
  await new Promise(resolve => setTimeout(resolve, 500));
  
  // No return value needed for password reset
};

// Handle login saga
function* handleLogin(action: PayloadAction<{ email: string; password: string }>) {
  try {
    const { email, password } = action.payload;
    const user: UserProfile = yield call(signInWithEmailAndPassword, email, password);
    
    // Login successful
    yield put(loginSuccess(user));
  } catch (error) {
    // Login failed
    yield put(loginFailure(error.message || 'Login failed'));
  }
}

// Handle social login saga
function* handleSocialLogin(action: PayloadAction<{ provider: 'google' | 'apple' | 'facebook' }>) {
  try {
    const { provider } = action.payload;
    const user: UserProfile = yield call(signInWithProvider, provider);
    
    // Login successful
    yield put(loginSuccess(user));
  } catch (error) {
    // Login failed
    yield put(loginFailure(error.message || 'Social login failed'));
  }
}

// Handle registration saga
function* handleRegister(
  action: PayloadAction<{ email: string; password: string; displayName?: string }>
) {
  try {
    const { email, password, displayName } = action.payload;
    const user: UserProfile = yield call(
      createUserWithEmailAndPassword,
      email,
      password,
      displayName
    );
    
    // Registration successful
    yield put(registerSuccess(user));
  } catch (error) {
    // Registration failed
    yield put(registerFailure(error.message || 'Registration failed'));
  }
}

// Handle logout saga
function* handleLogout() {
  try {
    yield call(signOut);
    
    // Logout successful
    yield put(logoutSuccess());
  } catch (error) {
    // Logout failed
    yield put(logoutFailure(error.message || 'Logout failed'));
  }
}

// Handle update profile saga
function* handleUpdateProfile(action: PayloadAction<Partial<UserProfile>>) {
  try {
    const userId = 'user123'; // In a real app, this would come from the state or auth service
    const updatedUser: UserProfile = yield call(updateUserProfile, userId, action.payload);
    
    // Update successful
    yield put(updateProfileSuccess(updatedUser));
  } catch (error) {
    // Update failed
    yield put(updateProfileFailure(error.message || 'Update profile failed'));
  }
}

// Handle reset password saga
function* handleResetPassword(action: PayloadAction<{ email: string }>) {
  try {
    const { email } = action.payload;
    yield call(sendPasswordResetEmail, email);
    
    // Reset password email sent successfully
    yield put(resetPasswordSuccess());
  } catch (error) {
    // Reset password failed
    yield put(resetPasswordFailure(error.message || 'Reset password failed'));
  }
}

// Watch for auth actions
export function* watchAuth() {
  yield takeLatest(login.type, handleLogin);
  yield takeLatest(socialLogin.type, handleSocialLogin);
  yield takeLatest(register.type, handleRegister);
  yield takeLatest(logout.type, handleLogout);
  yield takeLatest(updateProfile.type, handleUpdateProfile);
  yield takeLatest(resetPassword.type, handleResetPassword);
}


--- File: packages/core/src/store/sagas/bucketListSaga.ts ---
import { call, put, takeLatest, select } from 'redux-saga/effects';
import { PayloadAction } from '@reduxjs/toolkit';
import { 
  fetchBucketList,
  fetchBucketListSuccess,
  fetchBucketListFailure,
  addToBucketList,
  addToBucketListSuccess,
  addToBucketListFailure,
  updateBucketListItem,
  updateBucketListItemSuccess,
  updateBucketListItemFailure,
  removeFromBucketList,
  removeFromBucketListSuccess,
  removeFromBucketListFailure,
  markAsVisited,
  markAsVisitedSuccess,
  markAsVisitedFailure
} from '../slices/bucketListSlice';
import { selectVenue } from '../slices/venuesSlice';
import { BucketListItem } from '../../models/bucket-list';
import { RootState } from '../index';
import { Venue } from '../../models/venue';
import { foursquareService } from '../../api/foursquare';

// Helper function to get user ID from state
const getUserId = (state: RootState) => state.auth.user?.id;

// Handle fetch bucket list
function* handleFetchBucketList() {
  try {
    const userId = yield select(getUserId);
    
    if (!userId) {
      throw new Error('User not authenticated');
    }
    
    // Call API to get user's bucket list
    // In a real app, this would be a call to your backend API
    // or a service like Firebase
    const items = yield call(fetchBucketListFromFirebase, userId);
    
    // Enhance items with venue details if needed
    const enhancedItems = yield call(enhanceBucketListWithVenueDetails, items);
    
    // Handle success
    yield put(fetchBucketListSuccess(enhancedItems));
  } catch (error) {
    console.error('Failed to fetch bucket list:', error);
    yield put(fetchBucketListFailure(error.message || 'Failed to fetch bucket list'));
  }
}

// Mock function to fetch bucket list from Firebase or backend
// This would be replaced with actual Firebase calls
function fetchBucketListFromFirebase(userId: string): Promise<BucketListItem[]> {
  // In a real implementation, this would be:
  // return firebaseService.getBucketList(userId);
  
  // For now, return mock data
  return Promise.resolve([]);
}

// Helper function to enhance bucket list items with venue details
function* enhanceBucketListWithVenueDetails(items: BucketListItem[]): Generator<any, BucketListItem[], any> {
  // For each item, ensure we have complete venue details
  const enhancedItems = [];
  
  for (const item of items) {
    // If venue is missing or incomplete, fetch venue details
    if (!item.venue || Object.keys(item.venue).length === 0) {
      try {
        const response = yield call(
          foursquareService.getVenueDetails.bind(foursquareService),
          item.venueId
        );
        
        enhancedItems.push({
          ...item,
          venue: response.venue
        });
      } catch (error) {
        console.error(`Failed to fetch venue details for ${item.venueId}:`, error);
        // Still include the item even without venue details
        enhancedItems.push(item);
      }
    } else {
      enhancedItems.push(item);
    }
  }
  
  return enhancedItems;
}

// Handle add to bucket list
function* handleAddToBucketList(action: PayloadAction<{
  venueId: string;
  notes?: string;
  tags?: string[];
  priority?: 'low' | 'medium' | 'high';
}>) {
  try {
    const userId = yield select(getUserId);
    
    if (!userId) {
      throw new Error('User not authenticated');
    }
    
    const { venueId, notes, tags, priority } = action.payload;
    
    // Get venue details if not already in state
    let venue: Venue;
    const state: RootState = yield select();
    
    // Check if venue is in state
    const venueInState = 
      state.venues.nearby.venues.find(v => v.id === venueId) ||
      state.venues.recommended.venues.find(v => v.id === venueId) ||
      state.venues.search.venues.find(v => v.id === venueId) ||
      (state.venues.selectedVenue?.id === venueId ? state.venues.selectedVenue : undefined);
      
    if (venueInState) {
      venue = venueInState;
    } else {
      // Fetch venue details from API
      const response = yield call(
        foursquareService.getVenueDetails.bind(foursquareService),
        venueId
      );
      venue = response.venue;
      
      // Also update selected venue in state
      yield put(selectVenue(venueId));
    }
    
    // Create bucket list item
    const newItem: BucketListItem = {
      id: `${userId}_${venueId}_${Date.now()}`, // Generate a unique ID
      venueId,
      venue,
      userId,
      notes,
      tags,
      priority,
      addedAt: Date.now()
    };
    
    // Save to Firebase or backend
    yield call(saveBucketListItemToFirebase, newItem);
    
    // Handle success
    yield put(addToBucketListSuccess(newItem));
  } catch (error) {
    console.error('Failed to add to bucket list:', error);
    yield put(addToBucketListFailure(error.message || 'Failed to add to bucket list'));
  }
}

// Mock function to save bucket list item to Firebase or backend
function saveBucketListItemToFirebase(item: BucketListItem): Promise<void> {
  // In a real implementation, this would be:
  // return firebaseService.saveBucketListItem(item);
  
  // For now, just return a resolved promise
  return Promise.resolve();
}

// Handle update bucket list item
function* handleUpdateBucketListItem(action: PayloadAction<{
  id: string;
  updates: Partial<BucketListItem>;
}>) {
  try {
    const userId = yield select(getUserId);
    
    if (!userId) {
      throw new Error('User not authenticated');
    }
    
    const { id, updates } = action.payload;
    
    // Get current item from state
    const state: RootState = yield select();
    const currentItem = state.bucketList.items.find(item => item.id === id);
    
    if (!currentItem) {
      throw new Error('Item not found');
    }
    
    // Create updated item
    const updatedItem: BucketListItem = {
      ...currentItem,
      ...updates
    };
    
    // Save to Firebase or backend
    yield call(updateBucketListItemInFirebase, updatedItem);
    
    // Handle success
    yield put(updateBucketListItemSuccess(updatedItem));
  } catch (error) {
    console.error('Failed to update bucket list item:', error);
    yield put(updateBucketListItemFailure(error.message || 'Failed to update bucket list item'));
  }
}

// Mock function to update bucket list item in Firebase or backend
function updateBucketListItemInFirebase(item: BucketListItem): Promise<void> {
  // In a real implementation, this would be:
  // return firebaseService.updateBucketListItem(item);
  
  // For now, just return a resolved promise
  return Promise.resolve();
}

// Handle remove from bucket list
function* handleRemoveFromBucketList(action: PayloadAction<string>) {
  try {
    const userId = yield select(getUserId);
    
    if (!userId) {
      throw new Error('User not authenticated');
    }
    
    const itemId = action.payload;
    
    // Delete from Firebase or backend
    yield call(deleteBucketListItemFromFirebase, itemId);
    
    // Handle success
    yield put(removeFromBucketListSuccess(itemId));
  } catch (error) {
    console.error('Failed to remove from bucket list:', error);
    yield put(removeFromBucketListFailure(error.message || 'Failed to remove from bucket list'));
  }
}

// Mock function to delete bucket list item from Firebase or backend
function deleteBucketListItemFromFirebase(itemId: string): Promise<void> {
  // In a real implementation, this would be:
  // return firebaseService.deleteBucketListItem(itemId);
  
  // For now, just return a resolved promise
  return Promise.resolve();
}

// Handle mark as visited
function* handleMarkAsVisited(action: PayloadAction<{
  id: string;
  rating?: number;
  review?: string;
}>) {
  try {
    const userId = yield select(getUserId);
    
    if (!userId) {
      throw new Error('User not authenticated');
    }
    
    const { id, rating, review } = action.payload;
    
    // Get current item from state
    const state: RootState = yield select();
    const currentItem = state.bucketList.items.find(item => item.id === id);
    
    if (!currentItem) {
      throw new Error('Item not found');
    }
    
    // Create updated item
    const updatedItem: BucketListItem = {
      ...currentItem,
      visitedAt: Date.now(),
      rating,
      review
    };
    
    // Save to Firebase or backend
    yield call(updateBucketListItemInFirebase, updatedItem);
    
    // Handle success
    yield put(markAsVisitedSuccess(updatedItem));
  } catch (error) {
    console.error('Failed to mark as visited:', error);
    yield put(markAsVisitedFailure(error.message || 'Failed to mark as visited'));
  }
}

// Watch for bucket list actions
export function* watchBucketList() {
  yield takeLatest(fetchBucketList.type, handleFetchBucketList);
  yield takeLatest(addToBucketList.type, handleAddToBucketList);
  yield takeLatest(updateBucketListItem.type, handleUpdateBucketListItem);
  yield takeLatest(removeFromBucketList.type, handleRemoveFromBucketList);
  yield takeLatest(markAsVisited.type, handleMarkAsVisited);
}


--- File: packages/core/src/store/sagas/locationSaga.ts ---
import { 
  takeLatest, 
  call, 
  put, 
  spawn,
  take, 
  cancel, 
  fork,
  cancelled,
  delay
} from 'redux-saga/effects';
import { eventChannel, END } from 'redux-saga';
import { 
  getUserLocation, 
  setUserLocation, 
  locationError,
  setLocationPermission
} from '../slices/venuesSlice';
import { Coordinates } from '../../models/venue';

// Create a channel to handle watch position
function createLocationChannel() {
  return eventChannel(emitter => {
    // Watch position and emit location updates
    const watchId = navigator.geolocation.watchPosition(
      (position) => {
        const { latitude, longitude } = position.coords;
        emitter({ latitude, longitude });
      },
      (error) => {
        emitter(END);
        console.error('Geolocation error:', error);
      },
      {
        enableHighAccuracy: true,
        timeout: 20000,
        maximumAge: 1000,
        distanceFilter: 10 // Minimum distance (meters) between updates
      }
    );

    // Return unsubscribe function
    return () => {
      navigator.geolocation.clearWatch(watchId);
    };
  });
}

// Get current position once
function* getCurrentPosition() {
  try {
    const position = yield call(
      () => 
        new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(
            resolve,
            reject,
            {
              enableHighAccuracy: true,
              timeout: 10000,
              maximumAge: 1000
            }
          );
        })
    );
    
    const coordinates: Coordinates = {
      latitude: position.coords.latitude,
      longitude: position.coords.longitude
    };
    
    yield put(setUserLocation(coordinates));
    yield put(setLocationPermission(true));
    
    return coordinates;
  } catch (error) {
    console.error('Error getting current position:', error);
    yield put(locationError(error.message));
    
    if (error.code === 1) {
      // Permission denied
      yield put(setLocationPermission(false));
    }
    
    return null;
  }
}

// Watch for location updates
function* watchLocationUpdates() {
  try {
    const channel = yield call(createLocationChannel);
    
    // Process location updates
    while (true) {
      try {
        const coordinates = yield take(channel);
        yield put(setUserLocation(coordinates));
      } catch (error) {
        console.error('Error in location channel:', error);
        yield put(locationError(error.message));
      }
    }
  } catch (error) {
    console.error('Error creating location channel:', error);
    yield put(locationError(error.message));
  } finally {
    if (yield cancelled()) {
      console.log('Location watching cancelled');
    }
  }
}

// Handle get user location action
function* handleGetUserLocation() {
  // First get current position
  const coordinates = yield call(getCurrentPosition);
  
  // If successful, start watching for updates
  if (coordinates) {
    // Start watching location in background
    const watchTask = yield fork(watchLocationUpdates);
    
    // Automatically cancel the watch after 30 minutes
    // to conserve battery (can be adjusted based on requirements)
    yield spawn(function* () {
      yield delay(30 * 60 * 1000); // 30 minutes
      yield cancel(watchTask);
    });
  }
}

// Watch for location actions
export function* watchLocation() {
  yield takeLatest(getUserLocation.type, handleGetUserLocation);
}


--- File: packages/core/src/store/sagas/venuesSaga.ts ---
import { call, put, takeLatest, select } from 'redux-saga/effects';
import { PayloadAction } from '@reduxjs/toolkit';
import { foursquareService } from '../../api/foursquare';
import { 
  fetchNearbyVenues,
  fetchNearbyVenuesSuccess,
  fetchNearbyVenuesFailure,
  fetchRecommendedVenues,
  fetchRecommendedVenuesSuccess,
  fetchRecommendedVenuesFailure,
  searchVenues,
  searchVenuesSuccess,
  searchVenuesFailure,
  selectVenue,
  setSelectedVenue,
} from '../slices/venuesSlice';
import { Coordinates, Venue } from '../../models/venue';
import { RootState } from '../index';

// Handle fetch nearby venues
function* handleFetchNearbyVenues(action: PayloadAction<{
  coordinates: Coordinates;
  radius?: number;
  categories?: string[];
}>) {
  try {
    const { coordinates, radius = 1000, categories } = action.payload;
    
    // Call API
    const response = yield call(
      foursquareService.searchNearbyVenues.bind(foursquareService),
      coordinates,
      undefined, // No query for nearby venues
      categories,
      radius
    );
    
    // Handle success
    yield put(fetchNearbyVenuesSuccess(response.results));
  } catch (error) {
    console.error('Failed to fetch nearby venues:', error);
    yield put(fetchNearbyVenuesFailure(error.message || 'Failed to fetch nearby venues'));
  }
}

// Handle fetch recommended venues
function* handleFetchRecommendedVenues(action: PayloadAction<{
  coordinates: Coordinates;
  limit?: number;
}>) {
  try {
    const { coordinates, limit = 10 } = action.payload;
    
    // Call API
    const response = yield call(
      foursquareService.getRecommendedVenues.bind(foursquareService),
      coordinates,
      limit
    );
    
    // Handle success
    yield put(fetchRecommendedVenuesSuccess(response.results));
  } catch (error) {
    console.error('Failed to fetch recommended venues:', error);
    yield put(fetchRecommendedVenuesFailure(error.message || 'Failed to fetch recommended venues'));
  }
}

// Handle search venues
function* handleSearchVenues(action: PayloadAction<{
  coordinates: Coordinates;
  query: string;
  categories?: string[];
  radius?: number;
}>) {
  try {
    const { coordinates, query, categories, radius = 2000 } = action.payload;
    
    // Call API
    const response = yield call(
      foursquareService.searchNearbyVenues.bind(foursquareService),
      coordinates,
      query,
      categories,
      radius
    );
    
    // Handle success
    yield put(searchVenuesSuccess(response.results));
  } catch (error) {
    console.error('Failed to search venues:', error);
    yield put(searchVenuesFailure(error.message || 'Failed to search venues'));
  }
}

// Handle select venue
function* handleSelectVenue(action: PayloadAction<string>) {
  try {
    const venueId = action.payload;
    
    // Check if venue is already in state
    const state: RootState = yield select();
    let venue: Venue | undefined;
    
    // Look for venue in all lists
    venue = state.venues.nearby.venues.find(v => v.id === venueId);
    if (!venue) venue = state.venues.recommended.venues.find(v => v.id === venueId);
    if (!venue) venue = state.venues.search.venues.find(v => v.id === venueId);
    
    if (venue) {
      // If venue is already in state, use it
      yield put(setSelectedVenue(venue));
    } else {
      // Otherwise fetch from API
      const response = yield call(
        foursquareService.getVenueDetails.bind(foursquareService),
        venueId
      );
      
      // Handle success
      yield put(setSelectedVenue(response.venue));
    }
  } catch (error) {
    console.error('Failed to get venue details:', error);
    // Note: We don't have a specific failure action for this case
    // Could add one if needed
  }
}

// Watch for venue actions
export function* watchVenues() {
  yield takeLatest(fetchNearbyVenues.type, handleFetchNearbyVenues);
  yield takeLatest(fetchRecommendedVenues.type, handleFetchRecommendedVenues);
  yield takeLatest(searchVenues.type, handleSearchVenues);
  yield takeLatest(selectVenue.type, handleSelectVenue);
}


--- File: packages/core/src/store/slices/authSlice.ts ---
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { AuthState, UserProfile } from '../../models/app-state';

const initialState: AuthState = {
  isAuthenticated: false,
  user: null,
  loading: false,
  error: null,
};

const authSlice = createSlice({
  name: 'auth',
  initialState,
  reducers: {
    // Login actions
    login: (state, action: PayloadAction<{ email: string; password: string }>) => {
      state.loading = true;
      state.error = null;
    },
    loginSuccess: (state, action: PayloadAction<UserProfile>) => {
      state.isAuthenticated = true;
      state.user = action.payload;
      state.loading = false;
      state.error = null;
    },
    loginFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Logout action
    logout: state => {
      state.loading = true;
    },
    logoutSuccess: state => {
      state.isAuthenticated = false;
      state.user = null;
      state.loading = false;
      state.error = null;
    },
    logoutFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Clear error
    clearError: state => {
      state.error = null;
    },
  },
});

export const {
  login,
  loginSuccess,
  loginFailure,
  logout,
  logoutSuccess,
  logoutFailure,
  clearError,
} = authSlice.actions;

export default authSlice.reducer;


--- File: packages/core/src/store/slices/bucketListSlice.ts ---
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { BucketListState, BucketListItem, BucketListFilter } from '../../models/bucket-list';

const initialState: BucketListState = {
  items: [],
  filteredItems: [],
  filters: {},
  loading: false,
  error: null,
};

const bucketListSlice = createSlice({
  name: 'bucketList',
  initialState,
  reducers: {
    // Fetch bucket list actions
    fetchBucketList: (state) => {
      state.loading = true;
      state.error = null;
    },
    fetchBucketListSuccess: (state, action: PayloadAction<BucketListItem[]>) => {
      state.items = action.payload;
      state.filteredItems = applyFilters(action.payload, state.filters);
      state.loading = false;
    },
    fetchBucketListFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Add to bucket list actions
    addToBucketList: (state, action: PayloadAction<{
      venueId: string;
      notes?: string;
      tags?: string[];
      priority?: 'low' | 'medium' | 'high';
    }>) => {
      state.loading = true;
      state.error = null;
    },
    addToBucketListSuccess: (state, action: PayloadAction<BucketListItem>) => {
      state.items.push(action.payload);
      state.filteredItems = applyFilters(state.items, state.filters);
      state.loading = false;
    },
    addToBucketListFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Update bucket list item actions
    updateBucketListItem: (state, action: PayloadAction<{
      id: string;
      updates: Partial<BucketListItem>;
    }>) => {
      state.loading = true;
      state.error = null;
    },
    updateBucketListItemSuccess: (state, action: PayloadAction<BucketListItem>) => {
      const index = state.items.findIndex(item => item.id === action.payload.id);
      if (index !== -1) {
        state.items[index] = action.payload;
      }
      state.filteredItems = applyFilters(state.items, state.filters);
      state.loading = false;
    },
    updateBucketListItemFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Remove from bucket list actions
    removeFromBucketList: (state, action: PayloadAction<string>) => {
      state.loading = true;
      state.error = null;
    },
    removeFromBucketListSuccess: (state, action: PayloadAction<string>) => {
      state.items = state.items.filter(item => item.id !== action.payload);
      state.filteredItems = applyFilters(state.items, state.filters);
      state.loading = false;
    },
    removeFromBucketListFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Mark as visited actions
    markAsVisited: (state, action: PayloadAction<{
      id: string;
      rating?: number;
      review?: string;
    }>) => {
      state.loading = true;
      state.error = null;
    },
    markAsVisitedSuccess: (state, action: PayloadAction<BucketListItem>) => {
      const index = state.items.findIndex(item => item.id === action.payload.id);
      if (index !== -1) {
        state.items[index] = action.payload;
      }
      state.filteredItems = applyFilters(state.items, state.filters);
      state.loading = false;
    },
    markAsVisitedFailure: (state, action: PayloadAction<string>) => {
      state.loading = false;
      state.error = action.payload;
    },
    
    // Filter actions
    setFilters: (state, action: PayloadAction<BucketListFilter>) => {
      state.filters = action.payload;
      state.filteredItems = applyFilters(state.items, action.payload);
    },
    clearFilters: (state) => {
      state.filters = {};
      state.filteredItems = state.items;
    },
  },
});

// Helper function to apply filters
const applyFilters = (items: BucketListItem[], filters: BucketListFilter): BucketListItem[] => {
  let result = [...items];
  
  // Filter by tags
  if (filters.tags && filters.tags.length > 0) {
    result = result.filter(item => 
      item.tags && item.tags.some(tag => filters.tags!.includes(tag))
    );
  }
  
  // Filter by priority
  if (filters.priority && filters.priority.length > 0) {
    result = result.filter(item => 
      item.priority && filters.priority!.includes(item.priority)
    );
  }
  
  // Filter by visited status
  if (filters.visited !== undefined) {
    result = result.filter(item => 
      filters.visited ? !!item.visitedAt : !item.visitedAt
    );
  }
  
  // Filter by search term
  if (filters.searchTerm) {
    const term = filters.searchTerm.toLowerCase();
    result = result.filter(item => 
      item.venue.name.toLowerCase().includes(term) || 
      (item.notes && item.notes.toLowerCase().includes(term))
    );
  }
  
  // Sort results
  if (filters.sortBy) {
    result.sort((a, b) => {
      let comparison = 0;
      
      switch (filters.sortBy) {
        case 'dateAdded':
          comparison = a.addedAt - b.addedAt;
          break;
        case 'name':
          comparison = a.venue.name.localeCompare(b.venue.name);
          break;
        case 'priority':
          const priorityOrder = { high: 0, medium: 1, low: 2 };
          const aPriority = a.priority ? priorityOrder[a.priority] : 3;
          const bPriority = b.priority ? priorityOrder[b.priority] : 3;
          comparison = aPriority - bPriority;
          break;
        case 'plannedDate':
          const aDate = a.plannedVisitDate || Number.MAX_SAFE_INTEGER;
          const bDate = b.plannedVisitDate || Number.MAX_SAFE_INTEGER;
          comparison = aDate - bDate;
          break;
        default:
          break;
      }
      
      // Apply sort direction
      return filters.sortDirection === 'desc' ? -comparison : comparison;
    });
  }
  
  return result;
};

// Export actions
export const {
  fetchBucketList,
  fetchBucketListSuccess,
  fetchBucketListFailure,
  addToBucketList,
  addToBucketListSuccess,
  addToBucketListFailure,
  updateBucketListItem,
  updateBucketListItemSuccess,
  updateBucketListItemFailure,
  removeFromBucketList,
  removeFromBucketListSuccess,
  removeFromBucketListFailure,
  markAsVisited,
  markAsVisitedSuccess,
  markAsVisitedFailure,
  setFilters,
  clearFilters,
} = bucketListSlice.actions;

// Export reducer
export default bucketListSlice.reducer;


--- File: packages/core/src/store/slices/uiSlice.ts ---
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { UIState } from '../../models/app-state';

const initialState: UIState = {
  theme: 'light',
  networkStatus: 'online',
  hasCompletedOnboarding: false,
};

const uiSlice = createSlice({
  name: 'ui',
  initialState,
  reducers: {
    // Theme actions
    setTheme: (state, action: PayloadAction<'light' | 'dark'>) => {
      state.theme = action.payload;
    },
    toggleTheme: state => {
      state.theme = state.theme === 'light' ? 'dark' : 'light';
    },
    
    // Network status actions
    setNetworkStatus: (state, action: PayloadAction<'online' | 'offline'>) => {
      state.networkStatus = action.payload;
    },
    
    // Onboarding actions
    completeOnboarding: state => {
      state.hasCompletedOnboarding = true;
    },
    resetOnboarding: state => {
      state.hasCompletedOnboarding = false;
    },
  },
});

export const {
  setTheme,
  toggleTheme,
  setNetworkStatus,
  completeOnboarding,
  resetOnboarding,
} = uiSlice.actions;

export default uiSlice.reducer;


--- File: packages/core/src/store/slices/venuesSlice.ts ---
import { createSlice, PayloadAction } from '@reduxjs/toolkit';
import { VenuesState, Venue, Coordinates } from '../../models/app-state';

const initialState: VenuesState = {
  nearby: {
    venues: [],
    loading: false,
    error: null,
  },
  recommended: {
    venues: [],
    loading: false,
    error: null,
  },
  search: {
    venues: [],
    query: '',
    loading: false,
    error: null,
  },
  selectedVenue: null,
  userLocation: null,
  locationPermissionGranted: false,
};

const venuesSlice = createSlice({
  name: 'venues',
  initialState,
  reducers: {
    // User location actions
    getUserLocation: (state) => {
      // This is a saga trigger, no state change
    },
    setUserLocation: (state, action: PayloadAction<Coordinates>) => {
      state.userLocation = action.payload;
    },
    setLocationPermission: (state, action: PayloadAction<boolean>) => {
      state.locationPermissionGranted = action.payload;
    },
    locationError: (state, action: PayloadAction<string>) => {
      state.userLocation = null;
      // Not setting an error state here as we handle this at the UI level
    },
    
    // Nearby venues actions
    fetchNearbyVenues: (state, action: PayloadAction<{
      coordinates: Coordinates;
      radius?: number;
      categories?: string[];
    }>) => {
      state.nearby.loading = true;
      state.nearby.error = null;
    },
    fetchNearbyVenuesSuccess: (state, action: PayloadAction<Venue[]>) => {
      state.nearby.venues = action.payload;
      state.nearby.loading = false;
    },
    fetchNearbyVenuesFailure: (state, action: PayloadAction<string>) => {
      state.nearby.loading = false;
      state.nearby.error = action.payload;
    },
    
    // Recommended venues actions
    fetchRecommendedVenues: (state, action: PayloadAction<{
      coordinates: Coordinates;
      limit?: number;
    }>) => {
      state.recommended.loading = true;
      state.recommended.error = null;
    },
    fetchRecommendedVenuesSuccess: (state, action: PayloadAction<Venue[]>) => {
      state.recommended.venues = action.payload;
      state.recommended.loading = false;
    },
    fetchRecommendedVenuesFailure: (state, action: PayloadAction<string>) => {
      state.recommended.loading = false;
      state.recommended.error = action.payload;
    },
    
    // Search venues actions
    searchVenues: (state, action: PayloadAction<{
      coordinates: Coordinates;
      query: string;
      categories?: string[];
      radius?: number;
    }>) => {
      state.search.loading = true;
      state.search.error = null;
      state.search.query = action.payload.query;
    },
    searchVenuesSuccess: (state, action: PayloadAction<Venue[]>) => {
      state.search.venues = action.payload;
      state.search.loading = false;
    },
    searchVenuesFailure: (state, action: PayloadAction<string>) => {
      state.search.loading = false;
      state.search.error = action.payload;
    },
    
    // Selected venue actions
    selectVenue: (state, action: PayloadAction<string>) => {
      // This triggers a saga to fetch venue details
    },
    setSelectedVenue: (state, action: PayloadAction<Venue>) => {
      state.selectedVenue = action.payload;
    },
    clearSelectedVenue: (state) => {
      state.selectedVenue = null;
    },
    
    // Clear actions
    clearVenues: (state) => {
      state.nearby.venues = [];
      state.recommended.venues = [];
      state.search.venues = [];
      state.selectedVenue = null;
    },
  },
});

// Export actions
export const {
  getUserLocation,
  setUserLocation,
  setLocationPermission,
  locationError,
  fetchNearbyVenues,
  fetchNearbyVenuesSuccess,
  fetchNearbyVenuesFailure,
  fetchRecommendedVenues,
  fetchRecommendedVenuesSuccess,
  fetchRecommendedVenuesFailure,
  searchVenues,
  searchVenuesSuccess,
  searchVenuesFailure,
  selectVenue,
  setSelectedVenue,
  clearSelectedVenue,
  clearVenues,
} = venuesSlice.actions;

// Export reducer
export default venuesSlice.reducer;


--- File: packages/core/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "composite": true,
    "declaration": true,
    "declarationMap": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "**/*.spec.ts", "**/*.test.ts"]
}


--- File: packages/mobile/App.tsx ---
import React from 'react';
import { View } from 'react-native';
// import { SafeAreaProvider } from 'react-native-safe-area-context';
// import { Provider } from 'react-redux';
// import { PersistGate } from 'redux-persist/integration/react';
// import { store, persistor } from 'core/src/store';
// import MainNavigator from './src/navigation/MainNavigator';
// import { StatusBar } from 'expo-status-bar';

export default function App() {
  console.log('Rendering App component');
  return (
    <View style={{ flex: 1 }}>
      <View
        style={{
          position: 'absolute',
          top: 0,
          left: 0,
          right: 0,
          height: 24,
          backgroundColor: '#000',
        }}
      />{' '}
      <Text>{'Hello World'}</Text>
    </View>
  );
}


--- File: packages/mobile/app.json ---
{
  "expo": {
    "name": "mobile",
    "slug": "mobile",
    "version": "1.0.0",
    "description": "React Native mobile app for Restaurant Bucket List",
    "sdkVersion": "50.0.0",
    "platforms": [
      "ios",
      "android"
    ],
    "ios": {
      "bundleIdentifier": "com.anonymous.mobile"
    }
  }
}


--- File: packages/mobile/constants/categories.ts ---
import { theme } from '../theme';

/**
 * Restaurant categories based on Foursquare taxonomy
 * Each category has:
 * - id: Foursquare category ID
 * - name: Display name
 * - icon: Material icon name
 * - color: Brand color (optional)
 */
export const categories = [
  {
    id: '13065',
    name: 'Restaurant',
    icon: 'restaurant',
    color: theme.colors.primary,
  },
  {
    id: '13034',
    name: 'Cafe',
    icon: 'local-cafe',
    color: '#8D6E63',
  },
  {
    id: '13003',
    name: 'Bar',
    icon: 'local-bar',
    color: '#7B1FA2',
  },
  {
    id: '13145',
    name: 'Fast Food',
    icon: 'fastfood',
    color: '#F57C00',
  },
  {
    id: '13350',
    name: 'Pizza',
    icon: 'local-pizza',
    color: '#D32F2F',
  },
  {
    id: '13274',
    name: 'Breakfast',
    icon: 'free-breakfast',
    color: '#FFA000',
  },
  {
    id: '13072',
    name: 'Asian',
    icon: 'restaurant',
    color: '#00897B',
  },
  {
    id: '13236',
    name: 'Mexican',
    icon: 'restaurant',
    color: '#E64A19',
  },
  {
    id: '13005',
    name: 'Bakery',
    icon: 'cake',
    color: '#AD1457',
  },
  {
    id: '13285',
    name: 'American',
    icon: 'restaurant',
    color: '#0277BD',
  },
  {
    id: '13070',
    name: 'Italian',
    icon: 'restaurant',
    color: '#558B2F',
  },
  {
    id: '13074',
    name: 'Chinese',
    icon: 'restaurant',
    color: '#EF5350',
  },
  {
    id: '13265',
    name: 'Japanese',
    icon: 'restaurant',
    color: '#3949AB',
  },
  {
    id: '13199',
    name: 'Indian',
    icon: 'restaurant',
    color: '#FB8C00',
  },
  {
    id: '13080',
    name: 'Thai',
    icon: 'restaurant',
    color: '#AFB42B',
  },
  {
    id: '13142',
    name: 'Seafood',
    icon: 'set-meal',
    color: '#0097A7',
  },
  {
    id: '13303',
    name: 'Vegetarian',
    icon: 'eco',
    color: '#43A047',
  },
  {
    id: '13193',
    name: 'BBQ',
    icon: 'outdoor-grill',
    color: '#BF360C',
  },
  {
    id: '13377',
    name: 'Steakhouse',
    icon: 'restaurant',
    color: '#6D4C41',
  },
  {
    id: '13053',
    name: 'Food Truck',
    icon: 'local-shipping',
    color: '#607D8B',
  },
  {
    id: '13291',
    name: 'Dessert',
    icon: 'icecream',
    color: '#D81B60',
  },
  {
    id: '13339',
    name: 'Wine Bar',
    icon: 'wine-bar',
    color: '#8E24AA',
  },
  {
    id: '13375',
    name: 'Brewery',
    icon: 'sports-bar',
    color: '#5D4037',
  },
  {
    id: '13263',
    name: 'Sushi',
    icon: 'restaurant',
    color: '#00ACC1',
  },
];

/**
 * Find a category by ID
 */
export const getCategoryById = (id: string) => {
  return categories.find(category => category.id === id);
};

/**
 * Get a subset of categories
 */
export const getCategoriesSubset = (ids: string[]) => {
  return categories.filter(category => ids.includes(category.id));
};

/**
 * Get categories grouped by type
 */
export const getCategoriesGrouped = () => {
  const groups = [
    {
      title: 'Popular',
      data: categories.slice(0, 6),
    },
    {
      title: 'Cuisine Types',
      data: categories.filter(c => 
        ['Asian', 'Mexican', 'American', 'Italian', 'Chinese', 'Japanese', 'Indian', 'Thai'].includes(c.name)
      ),
    },
    {
      title: 'Meal Types',
      data: categories.filter(c => 
        ['Breakfast', 'Fast Food', 'Seafood', 'BBQ', 'Steakhouse', 'Dessert'].includes(c.name)
      ),
    },
    {
      title: 'Drinks & Others',
      data: categories.filter(c => 
        ['Cafe', 'Bar', 'Wine Bar', 'Brewery'].includes(c.name)
      ),
    },
  ];
  
  return groups;
};


--- File: packages/mobile/index.js ---
import { registerRootComponent } from 'expo';

import App from './App';

// registerRootComponent calls AppRegistry.registerComponent('main', () => App);
// It also ensures that whether you load the app in Expo Go or in a native build,
// the environment is set up appropriately
registerRootComponent(App);


--- File: packages/mobile/package.json ---
{
  "name": "mobile",
  "version": "1.0.0",
  "description": "React Native mobile app for Restaurant Bucket List",
  "main": "index.js",
  "private": true,
  "scripts": {
    "start": "expo start --dev-client",
    "android": "expo run:android",
    "ios": "expo run:ios",
    "web": "expo start --web",
    "eject": "expo eject",
    "build": "expo build",
    "clean": "rimraf ./android/build && rimraf ./ios/build",
    "test": "jest",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx"
  },
  "dependencies": {
    "@react-native-async-storage/async-storage": "^2.1.2",
    "@react-navigation/bottom-tabs": "^6.5.7",
    "@react-navigation/native": "^6.1.6",
    "@react-navigation/stack": "^6.3.16",
    "@rneui/base": "^4.0.0-rc.8",
    "@rneui/themed": "^4.0.0-rc.8",
    "core": "1.0.0",
    "expo": "~50.0.0",
    "expo-constants": "^17.1.5",
    "expo-linking": "~6.2.2",
    "expo-location": "~16.5.2",
    "expo-splash-screen": "~0.26.4",
    "expo-status-bar": "~1.11.1",
    "react": "18.2.0",
    "react-native": "0.73.6",
    "react-native-gesture-handler": "~2.14.0",
    "react-native-reanimated": "~3.6.2",
    "react-native-safe-area-context": "4.8.2",
    "react-native-screens": "~3.29.0",
    "react-native-vector-icons": "^10.2.0",
    "react-redux": "^8.0.5"
  },
  "devDependencies": {
    "@babel/core": "^7.21.5",
    "@babel/preset-env": "^7.21.5",
    "@babel/preset-typescript": "^7.21.5",
    "@babel/runtime": "^7.21.5",
    "@types/jest": "^29.5.1",
    "@types/react": "^18.2.0",
    "@types/react-native": "^0.71.6",
    "babel-jest": "^29.5.0",
    "jest": "^29.5.0",
    "jest-expo": "^48.0.2",
    "metro-react-native-babel-preset": "^0.76.3",
    "react-test-renderer": "^18.2.0",
    "rimraf": "^5.0.0",
    "typescript": "^5.0.4"
  },
  "jest": {
    "preset": "jest-expo",
    "transformIgnorePatterns": [
      "node_modules/(?!(jest-)?react-native|@react-native|react-clone-referenced-element|@react-native-community|expo(nent)?|@expo(nent)?/.*|react-navigation|@react-navigation/.*|@unimodules/.*|unimodules|sentry-expo|native-base)"
    ]
  }
}


--- File: packages/mobile/src/components/common/BucketListScreen.tsx ---
import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  TouchableOpacity,
  Alert,
} from 'react-native';
import { useTheme } from '../theme/ThemeProvider';
import { useDispatch, useSelector } from 'react-redux';
import { RootState } from '@restaurant-bucket-list/core/src/store';
import { removeFromBucketList, markAsVisited } from '@restaurant-bucket-list/core/src/store/slices/bucketListSlice';
import Icon from 'react-native-vector-icons/MaterialIcons';
import { BucketListItem } from '@restaurant-bucket-list/core/src/store/slices/bucketListSlice';

const BucketListScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const dispatch = useDispatch();
  const bucketList = useSelector((state: RootState) => state.bucketList.items);

  const handleRemoveItem = (id: string) => {
    Alert.alert(
      'Remove from Bucket List',
      'Are you sure you want to remove this restaurant from your bucket list?',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Remove',
          style: 'destructive',
          onPress: () => dispatch(removeFromBucketList(id)),
        },
      ]
    );
  };

  const handleMarkAsVisited = (item: BucketListItem) => {
    Alert.alert(
      'Mark as Visited',
      'Would you like to rate this restaurant?',
      [
        {
          text: 'Skip',
          onPress: () => dispatch(markAsVisited({ id: item.fsq_id })),
        },
        {
          text: 'Rate',
          onPress: () => navigation.navigate('RestaurantDetails', { venue: item, markVisited: true }),
        },
      ]
    );
  };

  const renderBucketListItem = ({ item }: { item: BucketListItem }) => (
    <TouchableOpacity
      style={[styles.itemContainer, { backgroundColor: theme.colors.card }]}
      onPress={() => navigation.navigate('RestaurantDetails', { venue: item })}
    >
      <View style={styles.itemInfo}>
        <Text style={[styles.itemName, { color: theme.colors.text }]}>{item.name}</Text>
        <Text style={[styles.itemAddress, { color: theme.colors.text }]}>
          {item.location.address}
        </Text>
        {item.visited && (
          <View style={styles.visitedContainer}>
            <Icon name="check-circle" size={16} color={theme.colors.success} />
            <Text style={[styles.visitedText, { color: theme.colors.success }]}>
              Visited {new Date(item.dateVisited!).toLocaleDateString()}
            </Text>
          </View>
        )}
      </View>
      <View style={styles.itemActions}>
        {!item.visited && (
          <TouchableOpacity
            style={[styles.actionButton, { backgroundColor: theme.colors.success }]}
            onPress={() => handleMarkAsVisited(item)}
          >
            <Icon name="check" size={24} color="#FFFFFF" />
          </TouchableOpacity>
        )}
        <TouchableOpacity
          style={[styles.actionButton, { backgroundColor: theme.colors.error }]}
          onPress={() => handleRemoveItem(item.fsq_id)}
        >
          <Icon name="delete" size={24} color="#FFFFFF" />
        </TouchableOpacity>
      </View>
    </TouchableOpacity>
  );

  return (
    <View style={[styles.container, { backgroundColor: theme.colors.background }]}>
      {bucketList.length === 0 ? (
        <View style={styles.emptyContainer}>
          <Icon name="restaurant" size={64} color={theme.colors.text} />
          <Text style={[styles.emptyText, { color: theme.colors.text }]}>
            Your bucket list is empty
          </Text>
          <Text style={[styles.emptySubtext, { color: theme.colors.text }]}>
            Add restaurants from the search or home screen
          </Text>
        </View>
      ) : (
        <FlatList
          data={bucketList}
          renderItem={renderBucketListItem}
          keyExtractor={(item) => item.fsq_id}
          contentContainerStyle={styles.listContainer}
        />
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  listContainer: {
    padding: 16,
  },
  itemContainer: {
    flexDirection: 'row',
    padding: 16,
    borderRadius: 8,
    marginBottom: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  itemInfo: {
    flex: 1,
  },
  itemName: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  itemAddress: {
    fontSize: 14,
    marginBottom: 4,
  },
  visitedContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  visitedText: {
    fontSize: 12,
    marginLeft: 4,
  },
  itemActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  actionButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 8,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 32,
  },
  emptyText: {
    fontSize: 20,
    fontWeight: 'bold',
    marginTop: 16,
    marginBottom: 8,
  },
  emptySubtext: {
    fontSize: 16,
    textAlign: 'center',
  },
});

export default BucketListScreen;

--- File: packages/mobile/src/components/common/CategoryCard.tsx ---
import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity } from 'react-native';
import Icon from 'react-native-vector-icons/MaterialIcons';
import { theme } from '../../theme';

interface CategoryCardProps {
  category: {
    id: string;
    name: string;
    icon: string;
    color: string;
  };
  onPress: () => void;
}

export const CategoryCard: React.FC<CategoryCardProps> = ({ category, onPress }) => {
  return (
    <TouchableOpacity style={styles.container} onPress={onPress}>
      <View style={[styles.iconContainer, { backgroundColor: category.color }]}>
        <Icon name={category.icon} size={24} color="white" />
      </View>
      <Text style={styles.name}>{category.name}</Text>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  container: { alignItems: 'center', marginHorizontal: 8 },
  iconContainer: {
    width: 60,
    height: 60,
    borderRadius: 30,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 8,
  },
  name: { fontSize: 14, color: theme.colors.grey1, textAlign: 'center' },
});


--- File: packages/mobile/src/components/common/HomeScreen.tsx ---
import React, { useEffect, useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
} from 'react-native';
import { useTheme } from '../theme/ThemeProvider';
import { useDispatch, useSelector } from 'react-redux';
import { RootState } from '@restaurant-bucket-list/core/src/store';
import { Venue } from '@restaurant-bucket-list/core/src/api/foursquare';
import FoursquareAPI from '@restaurant-bucket-list/core/src/api/foursquare';
import Geolocation from '@react-native-community/geolocation';

const HomeScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const dispatch = useDispatch();
  const [loading, setLoading] = useState(true);
  const [nearbyVenues, setNearbyVenues] = useState<Venue[]>([]);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchNearbyVenues = async () => {
      try {
        setLoading(true);
        const position = await new Promise((resolve, reject) => {
          Geolocation.getCurrentPosition(
            resolve,
            reject,
            { enableHighAccuracy: true, timeout: 15000, maximumAge: 10000 }
          );
        });

        const foursquare = new FoursquareAPI(process.env.FOURSQUARE_API_KEY);
        const venues = await foursquare.searchVenues({
          ll: `${position.coords.latitude},${position.coords.longitude}`,
          radius: 1000,
          limit: 10,
        });

        setNearbyVenues(venues);
      } catch (err) {
        setError('Failed to fetch nearby venues');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };

    fetchNearbyVenues();
  }, []);

  const renderVenueCard = (venue: Venue) => (
    <TouchableOpacity
      key={venue.fsq_id}
      style={[styles.venueCard, { backgroundColor: theme.colors.card }]}
      onPress={() => navigation.navigate('RestaurantDetails', { venue })}
    >
      <Text style={[styles.venueName, { color: theme.colors.text }]}>{venue.name}</Text>
      <Text style={[styles.venueAddress, { color: theme.colors.text }]}>
        {venue.location.address}
      </Text>
      {venue.stats?.rating && (
        <Text style={[styles.venueRating, { color: theme.colors.primary }]}>
          Rating: {venue.stats.rating.toFixed(1)}
        </Text>
      )}
    </TouchableOpacity>
  );

  if (loading) {
    return (
      <View style={[styles.container, { backgroundColor: theme.colors.background }]}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
      </View>
    );
  }

  if (error) {
    return (
      <View style={[styles.container, { backgroundColor: theme.colors.background }]}>
        <Text style={[styles.errorText, { color: theme.colors.error }]}>{error}</Text>
      </View>
    );
  }

  return (
    <ScrollView
      style={[styles.container, { backgroundColor: theme.colors.background }]}
      contentContainerStyle={styles.contentContainer}
    >
      <Text style={[styles.title, { color: theme.colors.text }]}>Nearby Restaurants</Text>
      {nearbyVenues.map(renderVenueCard)}
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  contentContainer: {
    padding: 16,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
  },
  venueCard: {
    padding: 16,
    borderRadius: 8,
    marginBottom: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  venueName: {
    fontSize: 18,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  venueAddress: {
    fontSize: 14,
    marginBottom: 4,
  },
  venueRating: {
    fontSize: 14,
    fontWeight: 'bold',
  },
  errorText: {
    fontSize: 16,
    textAlign: 'center',
    margin: 16,
  },
});

export default HomeScreen;

--- File: packages/mobile/src/components/common/LocationPermissionRequest.tsx ---
import React from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  Linking, 
  Platform,
  ScrollView
} from 'react-native';
import { Button, Icon } from '@rneui/themed';
import { SafeAreaView } from 'react-native-safe-area-context';
import { theme } from '../../theme';

interface LocationPermissionRequestProps {
  onRequestLocation: () => void;
}

/**
 * Location Permission Request Component
 * - Explains why the app needs location access
 * - Provides options to grant permission or open settings
 * - Fully accessible with clear instructions
 */
export const LocationPermissionRequest: React.FC<LocationPermissionRequestProps> = ({
  onRequestLocation
}) => {
  // Open app settings
  const openSettings = () => {
    Linking.openSettings();
  };
  
  return (
    <SafeAreaView style={styles.safeArea}>
      <ScrollView 
        contentContainerStyle={styles.container}
        showsVerticalScrollIndicator={false}
      >
        <View style={styles.iconContainer}>
          <Icon
            name="location-on"
            type="material"
            size={80}
            color={theme.colors.primary}
            containerStyle={styles.icon}
          />
        </View>
        
        <Text style={styles.title}>
          Location Access Needed
        </Text>
        
        <Text style={styles.description}>
          Restaurant Bucket List needs access to your location to find restaurants near you. We use this information only to show you relevant results and never track or store your location data.
        </Text>
        
        <View style={styles.benefitsContainer}>
          <View style={styles.benefitItem}>
            <Icon name="place" type="material" size={24} color={theme.colors.primary} />
            <Text style={styles.benefitText}>Discover nearby restaurants</Text>
          </View>
          
          <View style={styles.benefitItem}>
            <Icon name="star" type="material" size={24} color={theme.colors.primary} />
            <Text style={styles.benefitText}>Get personalized recommendations</Text>
          </View>
          
          <View style={styles.benefitItem}>
            <Icon name="directions" type="material" size={24} color={theme.colors.primary} />
            <Text style={styles.benefitText}>See distances and get directions</Text>
          </View>
        </View>
        
        <View style={styles.buttonsContainer}>
          <Button
            title="Allow Location Access"
            onPress={onRequestLocation}
            buttonStyle={styles.primaryButton}
            titleStyle={styles.buttonTitle}
            icon={{
              name: 'location-on',
              type: 'material',
              size: 20,
              color: 'white',
            }}
            iconRight={false}
            iconContainerStyle={styles.buttonIcon}
            accessible={true}
            accessibilityLabel="Allow location access"
            accessibilityRole="button"
          />
          
          <Button
            title="Open Settings"
            onPress={openSettings}
            type="outline"
            buttonStyle={styles.secondaryButton}
            titleStyle={styles.secondaryButtonTitle}
            icon={{
              name: 'settings',
              type: 'material',
              size: 20,
              color: theme.colors.primary,
            }}
            iconRight={false}
            iconContainerStyle={styles.buttonIcon}
            accessible={true}
            accessibilityLabel="Open app settings"
            accessibilityRole="button"
          />
          
          <Text style={styles.privacyNote}>
            You can change this permission later in your device settings.
          </Text>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: 'white',
  },
  container: {
    flexGrow: 1,
    alignItems: 'center',
    padding: 24,
    justifyContent: 'center',
  },
  iconContainer: {
    width: 140,
    height: 140,
    borderRadius: 70,
    backgroundColor: theme.colors.grey5,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 24,
  },
  icon: {
    marginBottom: 8,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    textAlign: 'center',
    color: theme.colors.grey1,
  },
  description: {
    fontSize: 16,
    textAlign: 'center',
    marginBottom: 32,
    color: theme.colors.grey2,
    lineHeight: 24,
  },
  benefitsContainer: {
    width: '100%',
    marginBottom: 32,
  },
  benefitItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
    paddingHorizontal: 8,
  },
  benefitText: {
    fontSize: 16,
    marginLeft: 12,
    color: theme.colors.grey2,
  },
  buttonsContainer: {
    width: '100%',
    alignItems: 'center',
  },
  primaryButton: {
    backgroundColor: theme.colors.primary,
    borderRadius: 8,
    paddingVertical: 12,
    width: '100%',
    marginBottom: 16,
  },
  buttonTitle: {
    fontSize: 16,
    fontWeight: '600',
  },
  secondaryButton: {
    borderColor: theme.colors.primary,
    borderRadius: 8,
    paddingVertical: 12,
    width: '100%',
    marginBottom: 20,
  },
  secondaryButtonTitle: {
    color: theme.colors.primary,
    fontSize: 16,
    fontWeight: '600',
  },
  buttonIcon: {
    marginRight: 8,
  },
  privacyNote: {
    fontSize: 14,
    textAlign: 'center',
    color: theme.colors.grey3,
    marginTop: 8,
  },
});


--- File: packages/mobile/src/components/common/ProfileScreen.tsx ---
import React from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ScrollView,
  Switch,
} from 'react-native';
import { useTheme } from '../theme/ThemeProvider';
import { useDispatch, useSelector } from 'react-redux';
import { RootState } from '@restaurant-bucket-list/core/src/store';
import Icon from 'react-native-vector-icons/MaterialIcons';

const ProfileScreen = () => {
  const { theme, isDark, toggleTheme } = useTheme();
  const dispatch = useDispatch();
  const bucketList = useSelector((state: RootState) => state.bucketList.items);

  const visitedCount = bucketList.filter((item) => item.visited).length;
  const totalCount = bucketList.length;

  const menuItems = [
    {
      title: 'Account Settings',
      icon: 'person',
      onPress: () => {
        // Navigate to account settings
      },
    },
    {
      title: 'Notifications',
      icon: 'notifications',
      onPress: () => {
        // Navigate to notifications settings
      },
    },
    {
      title: 'Privacy Policy',
      icon: 'privacy-tip',
      onPress: () => {
        // Navigate to privacy policy
      },
    },
    {
      title: 'Terms of Service',
      icon: 'description',
      onPress: () => {
        // Navigate to terms of service
      },
    },
    {
      title: 'Help & Support',
      icon: 'help',
      onPress: () => {
        // Navigate to help & support
      },
    },
  ];

  return (
    <ScrollView
      style={[styles.container, { backgroundColor: theme.colors.background }]}
      contentContainerStyle={styles.contentContainer}
    >
      <View style={[styles.header, { backgroundColor: theme.colors.card }]}>
        <View style={styles.profileInfo}>
          <View style={[styles.avatar, { backgroundColor: theme.colors.primary }]}>
            <Icon name="person" size={40} color="#FFFFFF" />
          </View>
          <View style={styles.stats}>
            <Text style={[styles.statValue, { color: theme.colors.text }]}>
              {visitedCount}
            </Text>
            <Text style={[styles.statLabel, { color: theme.colors.text }]}>
              Restaurants Visited
            </Text>
          </View>
          <View style={styles.stats}>
            <Text style={[styles.statValue, { color: theme.colors.text }]}>
              {totalCount}
            </Text>
            <Text style={[styles.statLabel, { color: theme.colors.text }]}>
              In Bucket List
            </Text>
          </View>
        </View>
      </View>

      <View style={[styles.section, { backgroundColor: theme.colors.card }]}>
        <View style={styles.sectionHeader}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>
            Appearance
          </Text>
        </View>
        <View style={styles.settingItem}>
          <View style={styles.settingInfo}>
            <Icon name="dark-mode" size={24} color={theme.colors.text} />
            <Text style={[styles.settingText, { color: theme.colors.text }]}>
              Dark Mode
            </Text>
          </View>
          <Switch
            value={isDark}
            onValueChange={toggleTheme}
            trackColor={{ false: '#767577', true: theme.colors.primary }}
            thumbColor={isDark ? '#FFFFFF' : '#f4f3f4'}
          />
        </View>
      </View>

      <View style={[styles.section, { backgroundColor: theme.colors.card }]}>
        <View style={styles.sectionHeader}>
          <Text style={[styles.sectionTitle, { color: theme.colors.text }]}>
            Settings
          </Text>
        </View>
        {menuItems.map((item, index) => (
          <TouchableOpacity
            key={index}
            style={styles.settingItem}
            onPress={item.onPress}
          >
            <View style={styles.settingInfo}>
              <Icon name={item.icon} size={24} color={theme.colors.text} />
              <Text style={[styles.settingText, { color: theme.colors.text }]}>
                {item.title}
              </Text>
            </View>
            <Icon name="chevron-right" size={24} color={theme.colors.text} />
          </TouchableOpacity>
        ))}
      </View>

      <TouchableOpacity
        style={[styles.logoutButton, { backgroundColor: theme.colors.error }]}
        onPress={() => {
          // Handle logout
        }}
      >
        <Text style={styles.logoutText}>Log Out</Text>
      </TouchableOpacity>
    </ScrollView>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  contentContainer: {
    padding: 16,
  },
  header: {
    borderRadius: 12,
    padding: 16,
    marginBottom: 16,
  },
  profileInfo: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  avatar: {
    width: 80,
    height: 80,
    borderRadius: 40,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: 16,
  },
  stats: {
    flex: 1,
    alignItems: 'center',
  },
  statValue: {
    fontSize: 24,
    fontWeight: 'bold',
  },
  statLabel: {
    fontSize: 12,
    marginTop: 4,
  },
  section: {
    borderRadius: 12,
    marginBottom: 16,
  },
  sectionHeader: {
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  sectionTitle: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  settingItem: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    padding: 16,
    borderBottomWidth: 1,
    borderBottomColor: '#E0E0E0',
  },
  settingInfo: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  settingText: {
    fontSize: 16,
    marginLeft: 12,
  },
  logoutButton: {
    padding: 16,
    borderRadius: 8,
    alignItems: 'center',
    marginTop: 16,
  },
  logoutText: {
    color: '#FFFFFF',
    fontSize: 16,
    fontWeight: 'bold',
  },
});

export default ProfileScreen;

--- File: packages/mobile/src/components/common/RestaurantCard copy.tsx ---
// packages/mobile/src/components/common/RestaurantCard.tsx

import React, { useCallback, useMemo } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  Image,
  Platform,
  Linking,
  Share
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { Card, Icon, Button, Divider, Chip } from '@rneui/themed';
import { Venue } from 'core/src/models/venue';
import { useAppDispatch, useAppSelector } from 'core/src/store';
import {
  selectVenue,
  setSelectedVenue
} from 'core/src/store/slices/venuesSlice';
import {
  addToBucketList,
  removeFromBucketList
} from 'core/src/store/slices/bucketListSlice';
import { theme } from '../../theme';
import { getDistanceString } from '../../utils/distanceUtils';
import { getVenueImage } from '../../utils/imageUtils';

interface RestaurantCardProps {
  venue: Venue;
  isBucketListed?: boolean;
  compact?: boolean;
  onPress?: () => void;
}

/**
 * Restaurant Card Component
 * - Displays restaurant information
 * - Handles add/remove from bucket list
 * - Provides navigation to detail screen
 * - Includes accessibility features
 */
export const RestaurantCard: React.FC<RestaurantCardProps> = ({
  venue,
  isBucketListed = false,
  compact = false,
  onPress
}) => {
  const navigation = useNavigation();
  const dispatch = useAppDispatch();
  const userLocation = useAppSelector(state => state.venues.userLocation);
  const isAuthenticated = useAppSelector(state => state.auth.isAuthenticated);

  // Get venue distance
  const distance = useMemo(() => {
    if (userLocation && venue.location) {
      return getDistanceString(
        userLocation.latitude,
        userLocation.longitude,
        venue.location.lat,
        venue.location.lng
      );
    }
    return null;
  }, [userLocation, venue.location]);

  // Get venue image
  const image = useMemo(() => getVenueImage(venue), [venue]);

  // Get venue price
  const priceText = useMemo(() => {
    if (!venue.price) return '';
    return venue.price.message || '.repeat(venue.price.tier || 1);
  }, [venue.price]);

  // Get venue categories
  const categoryText = useMemo(() => {
    if (!venue.categories || venue.categories.length === 0) return '';
    return venue.categories.map(cat => cat.name).join(', ');
  }, [venue.categories]);

  // Handle press
  const handlePress = useCallback(() => {
    dispatch(setSelectedVenue(venue));

    if (onPress) {
      onPress();
    } else {
      navigation.navigate('VenueDetails', { venueId: venue.id });
    }
  }, [venue, dispatch, onPress, navigation]);

  // Handle bucket list toggle
  const handleBucketListToggle = useCallback(() => {
    if (!isAuthenticated) {
      navigation.navigate('Auth');
      return;
    }

    if (isBucketListed) {
      dispatch(removeFromBucketList(venue.id));
    } else {
      dispatch(addToBucketList({ venueId: venue.id }));
    }
  }, [venue.id, isBucketListed, dispatch, isAuthenticated, navigation]);

  // Handle map directions
  const handleDirections = useCallback(() => {
    if (!venue.location) return;

    const { lat, lng } = venue.location;
    const url = Platform.select({
      ios: `maps:?q=${venue.name}&ll=${lat},${lng}`,
      android: `geo:${lat},${lng}?q=${lat},${lng}(${venue.name})`,
    });

    if (url) {
      Linking.openURL(url);
    }
  }, [venue]);

  // Handle share
  const handleShare = useCallback(() => {
    const title = `Check out ${venue.name}`;
    const message = `I found ${venue.name} and thought you might be interested!\n${venue.location?.formattedAddress || ''}`;
    const url = venue.url;

    Share.share({
      title,
      message: url ? `${message}\n${url}` : message,
    });
  }, [venue]);

  // Render compact view
  if (compact) {
    return (
      <TouchableOpacity
        onPress={handlePress}
        style={styles.compactContainer}
        accessible={true}
        accessibilityLabel={`${venue.name}, ${categoryText}, ${distance ? `${distance} away` : ''}`}
        accessibilityRole="button"
      >
        <View style={styles.compactContent}>
          {image ? (
            <Image source={{ uri: image }} style={styles.compactImage} />
          ) : (
            <View style={[styles.compactImage, styles.placeholderImage]}>
              <Icon name="restaurant" type="material" size={20} color={theme.colors.grey3} />
            </View>
          )}
          <View style={styles.compactDetails}>
            <Text style={styles.compactName} numberOfLines={1}>{venue.name}</Text>
            {categoryText ? (
              <Text style={styles.compactCategory} numberOfLines={1}>{categoryText}</Text>
            ) : null}
            <View style={styles.compactFooter}>
              {priceText ? <Text style={styles.price}>{priceText}</Text> : null}
              {distance ? <Text style={styles.distance}>{distance}</Text> : null}
            </View>
          </View>
          <TouchableOpacity
            onPress={handleBucketListToggle}
            style={styles.compactBookmark}
            accessible={true}
            accessibilityLabel={isBucketListed ? 'Remove from bucket list' : 'Add to bucket list'}
            accessibilityRole="button"
          >
            <Icon
              name={isBucketListed ? 'bookmark' : 'bookmark-outline'}
              type="material-community"
              size={24}
              color={isBucketListed ? theme.colors.primary : theme.colors.grey3}
            />
          </TouchableOpacity>
        </View>
      </TouchableOpacity>
    );
  }

  // Render full card
  return (
    <Card containerStyle={styles.container}>
      <TouchableOpacity
        onPress={handlePress}
        accessible={true}
        accessibilityLabel={`${venue.name}, ${categoryText}, ${distance ? `${distance} away` : ''}`}
        accessibilityRole="button"
      >
        {image ? (
          <Card.Image
            source={{ uri: image }}
            style={styles.image}
            resizeMode="cover"
          />
        ) : (
          <View style={[styles.image, styles.placeholderImage]}>
            <Icon name="restaurant" type="material" size={40} color={theme.colors.grey3} />
          </View>
        )}

        <View style={styles.headerContainer}>
          <View style={styles.titleContainer}>
            <Text style={styles.title} numberOfLines={1}>{venue.name}</Text>
            {venue.rating ? (
              <View style={styles.ratingContainer}>
                <Text style={styles.rating}>{venue.rating.toFixed(1)}</Text>
                <Icon name="star" size={16} color={theme.colors.warning} />
              </View>
            ) : null}
          </View>

          {categoryText ? (
            <Text style={styles.category} numberOfLines={1}>{categoryText}</Text>
          ) : null}

          <View style={styles.infoContainer}>
            {priceText ? <Chip title={priceText} type="outline" /> : null}
            {distance ? <Chip title={distance} type="outline" /> : null}
            {venue.hours?.isOpen !== undefined && (
              <Chip
                title={venue.hours.isOpen ? 'Open' : 'Closed'}
                type="outline"
                titleStyle={{
                  color: venue.hours.isOpen ? theme.colors.success : theme.colors.error,
                }}
              />
            )}
          </View>
        </View>

        {venue.location?.formattedAddress ? (
          <View style={styles.addressContainer}>
            <Icon name="place" size={16} color={theme.colors.grey3} />
            <Text style={styles.address} numberOfLines={2}>
              {venue.location.formattedAddress}
            </Text>
          </View>
        ) : null}
      </TouchableOpacity>

      <Divider style={styles.divider} />

      <View style={styles.actionsContainer}>
        <Button
          title={isBucketListed ? "Saved" : "Save"}
          icon={{
            name: isBucketListed ? 'bookmark' : 'bookmark-outline',
            type: 'material-community',
            color: 'white',
          }}
          onPress={handleBucketListToggle}
          type={isBucketListed ? "solid" : "outline"}
          size="sm"
          buttonStyle={styles.actionButton}
        />

        <Button
          title="Directions"
          icon={{
            name: 'directions',
            type: 'material',
            color: theme.colors.primary,
          }}
          type="outline"
          onPress={handleDirections}
          size="sm"
          buttonStyle={styles.actionButton}
        />

        <Button
          title="Share"
          icon={{
            name: 'share',
            type: 'material',
            color: theme.colors.primary,
          }}
          type="outline"
          onPress={handleShare}
          size="sm"
          buttonStyle={styles.actionButton}
        />
      </View>
    </Card>
  );
};

const styles = StyleSheet.create({
  container: {
    borderRadius: 8,
    padding: 0,
    margin: 8,
    marginBottom: 16,
    overflow: 'hidden',
  },
  image: {
    height: 180,
    width: '100%',
  },
  placeholderImage: {
    backgroundColor: theme.colors.grey5,
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerContainer: {
    padding: 12,
  },
  titleContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 4,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
    flex: 1,
    marginRight: 8,
  },
  ratingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: theme.colors.grey5,
    paddingHorizontal: 8,
    paddingVertical: 2,
    borderRadius: 12,
  },
  rating: {
    fontSize: 14,
    fontWeight: 'bold',
    marginRight: 2,
  },
  category: {
    fontSize: 14,
    color: theme.colors.grey3,
    marginBottom: 8,
  },
  infoContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    marginTop: 4,
    gap: 8,
  },
  price: {
    fontSize: 14,
    color: theme.colors.grey2,
  },
  distance: {
    fontSize: 14,
    color: theme.colors.grey2,
  },
  addressContainer: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    paddingHorizontal: 12,
    paddingBottom: 12,
  },
  address: {
    fontSize: 14,
    color: theme.colors.grey2,
    flex: 1,
    marginLeft: 4,
  },
  divider: {
    marginVertical: 8,
  },
  actionsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    padding: 8,
  },
  actionButton: {
    paddingHorizontal: 12,
  },

  // Compact styles
  compactContainer: {
    backgroundColor: 'white',
    borderRadius: 8,
    marginHorizontal: 12,
    marginVertical: 6,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 1 },
    shadowOpacity: 0.2,
    shadowRadius: 2,
    elevation: 2,
  },
  compactContent: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 10,
  },
  compactImage: {
    width: 60,
    height: 60,
    borderRadius: 6,
  },
  compactDetails: {
    flex: 1,
    marginLeft: 12,
    justifyContent: 'center',
  },
  compactName: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 2,
  },
  compactCategory: {
    fontSize: 14,
    color: theme.colors.grey3,
    marginBottom: 4,
  },
  compactFooter: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  compactBookmark: {
    padding: 8,
  },
});

--- File: packages/mobile/src/components/common/RestaurantCard.tsx ---
import React, { useMemo } from 'react';
import { View, Text, StyleSheet, TouchableOpacity, Image } from 'react-native';
import Icon from 'react-native-vector-icons/MaterialIcons';
import { theme } from '../../theme';
import { getDistanceString } from '../../utils/distanceUtils';

interface RestaurantCardProps {
  venue: any; // Replace with proper Venue type from core
  isBucketListed: boolean;
  compact?: boolean;
  onPress: () => void;
}

export const RestaurantCard: React.FC<RestaurantCardProps> = ({
  venue,
  isBucketListed,
  compact,
  onPress,
}) => {
  const priceText = useMemo(() => {
    if (!venue.price) return '';
    return venue.price.message || '$'.repeat(venue.price.tier || 1);
  }, [venue.price]);

  const distanceText = useMemo(() => {
    // Assuming user location is available; adjust as needed
    const userLocation = { latitude: 0, longitude: 0 }; // Placeholder
    if (venue.location && userLocation.latitude && userLocation.longitude) {
      return getDistanceString(
        userLocation.latitude,
        userLocation.longitude,
        venue.location.lat,
        venue.location.lng
      );
    }
    return '';
  }, [venue.location]);

  return (
    <TouchableOpacity style={[styles.container, compact && styles.compact]} onPress={onPress}>
      <View style={styles.imageContainer}>
        {venue.photos?.length > 0 ? (
          <Image
            source={{ uri: `${venue.photos[0].prefix}300x200${venue.photos[0].suffix}` }}
            style={styles.image}
          />
        ) : (
          <View style={[styles.image, styles.placeholderImage]}>
            <Icon name="restaurant" size={30} color={theme.colors.grey3} />
          </View>
        )}
        {isBucketListed && (
          <View style={styles.bookmarkedBadge}>
            <Icon name="bookmark" size={16} color="white" />
          </View>
        )}
      </View>
      <View style={styles.content}>
        <Text style={styles.title} numberOfLines={1}>
          {venue.name}
        </Text>
        <Text style={styles.category} numberOfLines={1}>
          {venue.categories?.[0]?.name || ''}
        </Text>
        <View style={styles.footer}>
          {priceText && <Text style={styles.price}>{priceText}</Text>}
          {distanceText && <Text style={styles.distance}>{distanceText}</Text>}
        </View>
      </View>
    </TouchableOpacity>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    backgroundColor: theme.colors.background,
    borderRadius: 8,
    marginBottom: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  compact: { marginBottom: 8 },
  imageContainer: { width: 100, height: 100, position: 'relative' },
  image: { width: '100%', height: '100%' },
  placeholderImage: {
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: theme.colors.grey5,
  },
  bookmarkedBadge: {
    position: 'absolute',
    top: 8,
    right: 8,
    backgroundColor: theme.colors.primary,
    borderRadius: 12,
    width: 24,
    height: 24,
    justifyContent: 'center',
    alignItems: 'center',
  },
  content: { flex: 1, padding: 12 },
  title: { fontSize: 16, fontWeight: 'bold', color: theme.colors.grey1, marginBottom: 4 },
  category: { fontSize: 14, color: theme.colors.grey3, marginBottom: 4 },
  footer: { flexDirection: 'row', justifyContent: 'space-between' },
  price: { fontSize: 14, color: theme.colors.grey2 },
  distance: { fontSize: 14, color: theme.colors.grey2 },
});


--- File: packages/mobile/src/components/common/SearchScreen.tsx ---
import React, { useState } from 'react';
import {
  View,
  Text,
  StyleSheet,
  TextInput,
  FlatList,
  TouchableOpacity,
  ActivityIndicator,
} from 'react-native';
import { useTheme } from '../theme/ThemeProvider';
import { useDispatch } from 'react-redux';
import { Venue } from '@restaurant-bucket-list/core/src/api/foursquare';
import FoursquareAPI from '@restaurant-bucket-list/core/src/api/foursquare';
import Icon from 'react-native-vector-icons/MaterialIcons';

const SearchScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const dispatch = useDispatch();
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<Venue[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSearch = async () => {
    if (!searchQuery.trim()) return;

    try {
      setLoading(true);
      setError(null);

      const foursquare = new FoursquareAPI(process.env.FOURSQUARE_API_KEY);
      const results = await foursquare.searchVenues({
        query: searchQuery,
        limit: 20,
      });

      setSearchResults(results);
    } catch (err) {
      setError('Failed to search venues');
      console.error(err);
    } finally {
      setLoading(false);
    }
  };

  const renderVenueItem = ({ item: venue }: { item: Venue }) => (
    <TouchableOpacity
      style={[styles.venueItem, { backgroundColor: theme.colors.card }]}
      onPress={() => navigation.navigate('RestaurantDetails', { venue })}
    >
      <View style={styles.venueInfo}>
        <Text style={[styles.venueName, { color: theme.colors.text }]}>{venue.name}</Text>
        <Text style={[styles.venueAddress, { color: theme.colors.text }]}>
          {venue.location.address}
        </Text>
        {venue.stats?.rating && (
          <Text style={[styles.venueRating, { color: theme.colors.primary }]}>
            Rating: {venue.stats.rating.toFixed(1)}
          </Text>
        )}
      </View>
      <Icon name="chevron-right" size={24} color={theme.colors.text} />
    </TouchableOpacity>
  );

  return (
    <View style={[styles.container, { backgroundColor: theme.colors.background }]}>
      <View style={[styles.searchContainer, { backgroundColor: theme.colors.card }]}>
        <TextInput
          style={[styles.searchInput, { color: theme.colors.text }]}
          placeholder="Search restaurants..."
          placeholderTextColor={theme.colors.text + '80'}
          value={searchQuery}
          onChangeText={setSearchQuery}
          onSubmitEditing={handleSearch}
          returnKeyType="search"
        />
        <TouchableOpacity
          style={[styles.searchButton, { backgroundColor: theme.colors.primary }]}
          onPress={handleSearch}
        >
          <Icon name="search" size={24} color="#FFFFFF" />
        </TouchableOpacity>
      </View>

      {loading ? (
        <ActivityIndicator
          style={styles.loader}
          size="large"
          color={theme.colors.primary}
        />
      ) : error ? (
        <Text style={[styles.errorText, { color: theme.colors.error }]}>{error}</Text>
      ) : (
        <FlatList
          data={searchResults}
          renderItem={renderVenueItem}
          keyExtractor={(item) => item.fsq_id}
          contentContainerStyle={styles.listContainer}
          ListEmptyComponent={
            searchQuery ? (
              <Text style={[styles.emptyText, { color: theme.colors.text }]}>
                No results found
              </Text>
            ) : null
          }
        />
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  searchContainer: {
    flexDirection: 'row',
    padding: 16,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  searchInput: {
    flex: 1,
    height: 40,
    paddingHorizontal: 12,
    borderRadius: 8,
    marginRight: 8,
  },
  searchButton: {
    width: 40,
    height: 40,
    borderRadius: 8,
    justifyContent: 'center',
    alignItems: 'center',
  },
  listContainer: {
    padding: 16,
  },
  venueItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: 16,
    borderRadius: 8,
    marginBottom: 12,
  },
  venueInfo: {
    flex: 1,
  },
  venueName: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  venueAddress: {
    fontSize: 14,
    marginBottom: 4,
  },
  venueRating: {
    fontSize: 14,
    fontWeight: 'bold',
  },
  loader: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorText: {
    fontSize: 16,
    textAlign: 'center',
    margin: 16,
  },
  emptyText: {
    fontSize: 16,
    textAlign: 'center',
    marginTop: 32,
  },
});

export default SearchScreen;

--- File: packages/mobile/src/components/screens/AddToBucketListScreen.tsx ---
import { useRoute } from "@react-navigation/native";
import React from "react";
import { StyleSheet, Text, View } from "react-native";
import { AddToBucketListRouteProp } from "../../navigation/types"; // Assuming types are in ../../navigation
import { theme } from "../../theme"; // Assuming theme is in ../../theme

// Placeholder component for AddToBucketListScreen
export const AddToBucketListScreen = () => {
  const route = useRoute<AddToBucketListRouteProp>();
  const { venueId } = route.params;

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Add To Bucket List Screen</Text>
      <Text style={styles.text}>Venue ID: {venueId}</Text>
      <Text style={styles.text}>
        (Placeholder: Implement form to add notes, priority, tags for the venue)
      </Text>
      {/* You would typically include the BucketListItemForm here */}
      {/* <BucketListItemForm venueId={venueId} onSubmit={...} onCancel={...} /> */}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 16,
    backgroundColor: theme.lightColors?.background || "#FFFFFF",
  },
  title: {
    fontSize: 20,
    fontWeight: "bold",
    marginBottom: 16,
    color: theme.lightColors?.primary || "#000000",
  },
  text: {
    fontSize: 16,
    textAlign: "center",
    marginBottom: 8,
    color: theme.lightColors?.grey1 || "#424242",
  },
});

// Export the component
export default AddToBucketListScreen;


--- File: packages/mobile/src/components/screens/AuthScreen.tsx ---
import { useNavigation } from "@react-navigation/native";
import { StackNavigationProp } from "@react-navigation/stack";
import React from "react";
import { Button, StyleSheet, Text, View } from "react-native";
import { RootStackParamList } from "../../navigation/types"; // Assuming types are in ../../navigation
import { theme } from "../../theme"; // Assuming theme is in ../../theme

type AuthScreenNavigationProp = StackNavigationProp<RootStackParamList, "Auth">;

// Placeholder component for AuthScreen
export const AuthScreen = () => {
  const navigation = useNavigation<AuthScreenNavigationProp>();

  const handleLogin = () => {
    // Placeholder for login logic
    console.log("Login button pressed");
    // Example navigation after successful login (replace with actual logic)
    // navigation.navigate('Main');
  };

  const handleRegister = () => {
    // Placeholder for registration logic
    console.log("Register button pressed");
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Authentication Screen</Text>
      <Text style={styles.text}>
        (Placeholder: Implement Login/Registration form)
      </Text>
      <View style={styles.buttonContainer}>
        <Button
          title="Login"
          onPress={handleLogin}
          color={theme.lightColors?.primary}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Register"
          onPress={handleRegister}
          color={theme.lightColors?.secondary}
        />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 16,
    backgroundColor: theme.lightColors?.background || "#FFFFFF",
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    marginBottom: 24,
    color: theme.lightColors?.primary || "#000000",
  },
  text: {
    fontSize: 16,
    textAlign: "center",
    marginBottom: 24,
    color: theme.lightColors?.grey1 || "#424242",
  },
  buttonContainer: {
    marginVertical: 10,
    width: "80%",
  },
});

// Export the component
export default AuthScreen;


--- File: packages/mobile/src/components/screens/BucketListItemEditScreen.tsx ---
import { useRoute } from "@react-navigation/native";
import React from "react";
import { StyleSheet, Text, View } from "react-native";
import { BucketListItemEditRouteProp } from "../../navigation/types"; // Assuming types are in ../../navigation
import { theme } from "../../theme"; // Assuming theme is in ../../theme

// Placeholder component for BucketListItemEditScreen
export const BucketListItemEditScreen = () => {
  const route = useRoute<BucketListItemEditRouteProp>();
  const { itemId } = route.params;

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Edit Bucket List Item Screen</Text>
      <Text style={styles.text}>Item ID: {itemId}</Text>
      <Text style={styles.text}>
        (Placeholder: Implement form to edit notes, priority, tags for the item)
      </Text>
      {/* You would typically include the BucketListItemForm here, pre-filled with item data */}
      {/* <BucketListItemForm venueId={/* fetch venueId based on itemId *} initialData={/* fetch item data *} onSubmit={...} onCancel={...} /> */}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 16,
    backgroundColor: theme.lightColors?.background || "#FFFFFF",
  },
  title: {
    fontSize: 20,
    fontWeight: "bold",
    marginBottom: 16,
    color: theme.lightColors?.primary || "#000000",
  },
  text: {
    fontSize: 16,
    textAlign: "center",
    marginBottom: 8,
    color: theme.lightColors?.grey1 || "#424242",
  },
});

// Export the component
export default BucketListItemEditScreen;


--- File: packages/mobile/src/components/screens/BucketListScreen copy.tsx ---
import {
  BucketListItem,
  removeFromBucketList,
  markAsVisited,
} from '@restaurant-bucket-list/core/src/store/slices/bucketListSlice';
import { RootState } from '@restaurant-bucket-list/core/src/store';
import React from 'react';
import { View, Text, StyleSheet, FlatList, TouchableOpacity, Alert } from 'react-native';
import { useTheme } from '../theme/ThemeProvider';
import { useDispatch, useSelector } from 'react-redux';
import Icon from 'react-native-vector-icons/MaterialIcons';

export const BucketListScreen = ({ navigation }) => {
  const { theme } = useTheme();
  const dispatch = useDispatch();
  const bucketList = useSelector((state: RootState) => state.bucketList.items);

  const handleRemoveItem = (id: string) => {
    Alert.alert(
      'Remove from Bucket List',
      'Are you sure you want to remove this restaurant from your bucket list?',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Remove',
          style: 'destructive',
          onPress: () => dispatch(removeFromBucketList(id)),
        },
      ]
    );
  };

  const handleMarkAsVisited = (item: BucketListItem) => {
    Alert.alert('Mark as Visited', 'Would you like to rate this restaurant?', [
      {
        text: 'Skip',
        onPress: () => dispatch(markAsVisited({ id: item.fsq_id })),
      },
      {
        text: 'Rate',
        onPress: () => navigation.navigate('RestaurantDetails', { venue: item, markVisited: true }),
      },
    ]);
  };

  const renderBucketListItem = ({ item }: { item: BucketListItem }) => (
    <TouchableOpacity
      style={[styles.itemContainer, { backgroundColor: theme.colors.card }]}
      onPress={() => navigation.navigate('RestaurantDetails', { venue: item })}
    >
      <View style={styles.itemInfo}>
        <Text style={[styles.itemName, { color: theme.colors.text }]}>{item.name}</Text>
        <Text style={[styles.itemAddress, { color: theme.colors.text }]}>
          {item.location.address}
        </Text>
        {item.visited && (
          <View style={styles.visitedContainer}>
            <Icon name="check-circle" size={16} color={theme.colors.success} />
            <Text style={[styles.visitedText, { color: theme.colors.success }]}>
              Visited {new Date(item.dateVisited!).toLocaleDateString()}
            </Text>
          </View>
        )}
      </View>
      <View style={styles.itemActions}>
        {!item.visited && (
          <TouchableOpacity
            style={[styles.actionButton, { backgroundColor: theme.colors.success }]}
            onPress={() => handleMarkAsVisited(item)}
          >
            <Icon name="check" size={24} color="#FFFFFF" />
          </TouchableOpacity>
        )}
        <TouchableOpacity
          style={[styles.actionButton, { backgroundColor: theme.colors.error }]}
          onPress={() => handleRemoveItem(item.fsq_id)}
        >
          <Icon name="delete" size={24} color="#FFFFFF" />
        </TouchableOpacity>
      </View>
    </TouchableOpacity>
  );

  return (
    <View style={[styles.container, { backgroundColor: theme.colors.background }]}>
      {bucketList.length === 0 ? (
        <View style={styles.emptyContainer}>
          <Icon name="restaurant" size={64} color={theme.colors.text} />
          <Text style={[styles.emptyText, { color: theme.colors.text }]}>
            Your bucket list is empty
          </Text>
          <Text style={[styles.emptySubtext, { color: theme.colors.text }]}>
            Add restaurants from the search or home screen
          </Text>
        </View>
      ) : (
        <FlatList
          data={bucketList}
          renderItem={renderBucketListItem}
          keyExtractor={item => item.fsq_id}
          contentContainerStyle={styles.listContainer}
        />
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  listContainer: {
    padding: 16,
  },
  itemContainer: {
    flexDirection: 'row',
    padding: 16,
    borderRadius: 8,
    marginBottom: 12,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  itemInfo: {
    flex: 1,
  },
  itemName: {
    fontSize: 16,
    fontWeight: 'bold',
    marginBottom: 4,
  },
  itemAddress: {
    fontSize: 14,
    marginBottom: 4,
  },
  visitedContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  visitedText: {
    fontSize: 12,
    marginLeft: 4,
  },
  itemActions: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  actionButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginLeft: 8,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 32,
  },
  emptyText: {
    fontSize: 20,
    fontWeight: 'bold',
    marginTop: 16,
    marginBottom: 8,
  },
  emptySubtext: {
    fontSize: 16,
    textAlign: 'center',
  },
});

export default BucketListScreen;


--- File: packages/mobile/src/components/screens/BucketListScreen.tsx ---
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { BucketListNavigationProp } from '../../navigation/types';
import { theme } from '../../theme';

interface BucketListScreenProps {
  navigation: BucketListNavigationProp;
}

/**
 * Bucket List Screen Component (Stub)
 */
export const BucketListScreen: React.FC<BucketListScreenProps> = ({ navigation }) => {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Bucket List Screen</Text>
      <Text style={styles.description}>
        This is a stub for the BucketListScreen component. It will be replaced with the actual implementation.
      </Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
    backgroundColor: theme.colors.background,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: theme.colors.primary,
  },
  description: {
    fontSize: 16,
    textAlign: 'center',
    color: theme.colors.textSecondary,
  },
});

export default BucketListScreen;


--- File: packages/mobile/src/components/screens/DetailsScreen.tsx ---
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { RouteProp } from '@react-navigation/native';
import { StackNavigationProp } from '@react-navigation/stack';
import { RootStackParamList } from '../../navigation/types';
import { theme } from '../../theme';

type DetailsScreenRouteProp = RouteProp<RootStackParamList, 'Details'>;
type DetailsScreenNavigationProp = StackNavigationProp<RootStackParamList, 'Details'>;

interface DetailsScreenProps {
  route: DetailsScreenRouteProp;
  navigation: DetailsScreenNavigationProp;
}

/**
 * Details Screen Component (Stub)
 */
export const DetailsScreen: React.FC<DetailsScreenProps> = ({ route, navigation }) => {
  const { id } = route.params;
  
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Details Screen</Text>
      <Text style={styles.description}>
        This is a stub for the DetailsScreen component. It will be replaced with the actual implementation.
      </Text>
      <Text style={styles.id}>Item ID: {id}</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
    backgroundColor: theme.colors.background,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: theme.colors.primary,
  },
  description: {
    fontSize: 16,
    textAlign: 'center',
    color: theme.colors.textSecondary,
    marginBottom: 16,
  },
  id: {
    fontSize: 18,
    fontWeight: '500',
    color: theme.colors.text,
  },
});

export default DetailsScreen;


--- File: packages/mobile/src/components/screens/ExploreScreen.tsx ---
import React, { useState, useCallback } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  ActivityIndicator,
  FlatList,
  StatusBar,
  Image,
  Platform,
  Dimensions,
  TextInput,
  Modal,
  SafeAreaView,
} from 'react-native';
import Icon from 'react-native-vector-icons/MaterialIcons';
import { useFocusEffect } from '@react-navigation/native';
import { useAppDispatch, useAppSelector } from 'core/src/store';
import {
  getUserLocation,
  fetchNearbyVenues,
  fetchRecommendedVenues,
} from 'core/src/store/slices/venuesSlice';
import { useGeolocation } from 'core/src/hooks/useGeolocation';
import { RestaurantCard } from '../common/RestaurantCard';
import { CategoryCard } from '../common/CategoryCard';
import { LocationPermissionRequest } from '../common/LocationPermissionRequest';
import { theme } from '../../theme';
import { ExploreNavigationProp } from '../../navigation/types';
import { categories } from '../../theme/categories';

interface ExploreScreenProps {
  navigation: ExploreNavigationProp;
}

export const ExploreScreen: React.FC<ExploreScreenProps> = ({ navigation }) => {
  const dispatch = useAppDispatch();
  const { coordinates, permissionGranted, requestLocation } = useGeolocation();

  const nearbyVenues = useAppSelector(state => state.venues.nearby.venues);
  const nearbyLoading = useAppSelector(state => state.venues.nearby.loading);
  const nearbyError = useAppSelector(state => state.venues.nearby.error);

  const recommendedVenues = useAppSelector(state => state.venues.recommended.venues);
  const recommendedLoading = useAppSelector(state => state.venues.recommended.loading);
  const recommendedError = useAppSelector(state => state.venues.recommended.error);

  const bucketListItems = useAppSelector(state => state.bucketList.items);
  const isAuthenticated = useAppSelector(state => state.auth.isAuthenticated);
  const userName = useAppSelector(state => state.auth.user?.displayName);

  const [refreshing, setRefreshing] = useState<boolean>(false);
  const [searchQuery, setSearchQuery] = useState<string>('');

  const topCategories = categories.slice(0, 6);

  const isVenueInBucketList = useCallback(
    (venueId: string) => {
      return bucketListItems.some(item => item.venueId === venueId);
    },
    [bucketListItems]
  );

  useFocusEffect(
    useCallback(() => {
      if (permissionGranted && coordinates) {
        loadVenues();
      }
    }, [permissionGranted, coordinates])
  );

  const loadVenues = useCallback(() => {
    if (coordinates) {
      dispatch(fetchNearbyVenues({ coordinates }));
      dispatch(fetchRecommendedVenues({ coordinates, limit: 5 }));
    }
  }, [coordinates, dispatch]);

  const handleRefresh = useCallback(() => {
    setRefreshing(true);
    loadVenues();
    setTimeout(() => {
      setRefreshing(false);
    }, 1500);
  }, [loadVenues]);

  const handleSearch = useCallback(() => {
    if (searchQuery.trim()) {
      navigation.navigate('Search', { screen: 'SearchResults', params: { query: searchQuery } });
      setSearchQuery('');
    }
  }, [searchQuery, navigation]);

  const handleVenuePress = useCallback(
    (venueId: string) => {
      navigation.navigate('VenueDetails', { venueId });
    },
    [navigation]
  );

  const handleCategoryPress = useCallback(
    (categoryId: string, categoryName: string) => {
      navigation.navigate('Search', {
        screen: 'SearchResults',
        params: {
          categories: [categoryId],
          title: categoryName,
        },
      });
    },
    [navigation]
  );

  const handleSeeAllPress = useCallback(
    (type: 'nearby' | 'recommended') => {
      if (type === 'nearby') {
        navigation.navigate('Explore', { screen: 'NearbyVenues' });
      } else {
        navigation.navigate('Explore', { screen: 'RecommendedVenues' });
      }
    },
    [navigation]
  );

  if (!permissionGranted) {
    return <LocationPermissionRequest onRequestLocation={requestLocation} />;
  }

  if (!coordinates) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={styles.loadingText}>Getting your location...</Text>
      </View>
    );
  }

  return (
    <SafeAreaView style={styles.container}>
      <StatusBar barStyle="dark-content" backgroundColor="white" />
      <ScrollView
        contentContainerStyle={styles.scrollContent}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={handleRefresh}
            colors={[theme.colors.primary]}
            tintColor={theme.colors.primary}
          />
        }
        showsVerticalScrollIndicator={false}
      >
        <View style={styles.header}>
          <View style={styles.headerContent}>
            <View>
              <Text style={styles.greeting}>
                {isAuthenticated && userName ? `Hello, ${userName.split(' ')[0]}!` : 'Hello there!'}
              </Text>
              <Text style={styles.subtitle}>Discover amazing restaurants</Text>
            </View>
            <TouchableOpacity
              onPress={() => navigation.navigate('Profile')}
              style={styles.profileButton}
              accessible={true}
              accessibilityLabel="Your profile"
              accessibilityRole="button"
            >
              <Icon name="person" size={28} color={theme.colors.primary} />
            </TouchableOpacity>
          </View>
        </View>

        <View style={styles.searchBarContainer}>
          <TextInput
            style={styles.searchBar}
            placeholder="Search restaurants..."
            value={searchQuery}
            onChangeText={setSearchQuery}
            onSubmitEditing={handleSearch}
            returnKeyType="search"
            accessibilityLabel="Search for restaurants"
            accessibilityHint="Enter restaurant name or cuisine"
          />
          <TouchableOpacity style={styles.searchButton} onPress={handleSearch}>
            <Icon name="search" size={20} color={theme.colors.primary} />
          </TouchableOpacity>
        </View>

        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>Categories</Text>
            <TouchableOpacity
              onPress={() => navigation.navigate('Explore', { screen: 'CategoryList' })}
              accessible={true}
              accessibilityLabel="View all categories"
              accessibilityRole="button"
            >
              <Text style={styles.seeAll}>See All</Text>
            </TouchableOpacity>
          </View>
          <ScrollView
            horizontal
            showsHorizontalScrollIndicator={false}
            contentContainerStyle={styles.categoriesContainer}
          >
            {topCategories.map((category, index) => (
              <CategoryCard
                key={category.id}
                category={category}
                onPress={() => handleCategoryPress(category.id, category.name)}
              />
            ))}
          </ScrollView>
        </View>

        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>Recommended for You</Text>
            <TouchableOpacity
              onPress={() => handleSeeAllPress('recommended')}
              accessible={true}
              accessibilityLabel="View all recommended restaurants"
              accessibilityRole="button"
            >
              <Text style={styles.seeAll}>See All</Text>
            </TouchableOpacity>
          </View>
          {recommendedLoading && recommendedVenues.length === 0 ? (
            <View style={styles.loadingRow}>
              <ActivityIndicator size="small" color={theme.colors.primary} />
              <Text style={styles.loadingText}>Finding recommendations...</Text>
            </View>
          ) : recommendedError ? (
            <View style={styles.errorContainer}>
              <Icon name="error" size={24} color={theme.colors.error} />
              <Text style={styles.errorText}>{recommendedError}</Text>
              <TouchableOpacity style={styles.retryButton} onPress={loadVenues}>
                <Text style={styles.retryButtonText}>Try Again</Text>
              </TouchableOpacity>
            </View>
          ) : recommendedVenues.length === 0 ? (
            <View style={styles.emptyContainer}>
              <Icon name="restaurant" size={40} color={theme.colors.grey3} />
              <Text style={styles.emptyText}>No recommendations found</Text>
            </View>
          ) : (
            <FlatList
              data={recommendedVenues.slice(0, 5)}
              keyExtractor={item => item.id}
              horizontal
              showsHorizontalScrollIndicator={false}
              contentContainerStyle={styles.recommendedList}
              renderItem={({ item }) => (
                <TouchableOpacity
                  style={styles.recommendedItem}
                  onPress={() => handleVenuePress(item.id)}
                  accessible={true}
                  accessibilityLabel={`${item.name}, ${item.categories?.[0]?.name || ''}`}
                  accessibilityRole="button"
                >
                  <View style={styles.recommendedCard}>
                    <View style={styles.cardImageContainer}>
                      {item.photos?.length > 0 ? (
                        <Image
                          source={{
                            uri: `${item.photos[0].prefix}300x200${item.photos[0].suffix}`,
                          }}
                          style={styles.cardImage}
                          resizeMode="cover"
                        />
                      ) : (
                        <View style={[styles.cardImage, styles.placeholderImage]}>
                          <Icon name="restaurant" size={30} color={theme.colors.grey3} />
                        </View>
                      )}
                      {isVenueInBucketList(item.id) && (
                        <View style={styles.bookmarkedBadge}>
                          <Icon name="bookmark" size={16} color="white" />
                        </View>
                      )}
                    </View>
                    <View style={styles.cardContent}>
                      <Text style={styles.cardTitle} numberOfLines={1}>
                        {item.name}
                      </Text>
                      {item.categories && item.categories.length > 0 && (
                        <Text style={styles.cardCategory} numberOfLines={1}>
                          {item.categories[0].name}
                        </Text>
                      )}
                      <View style={styles.cardFooter}>
                        {item.rating && (
                          <View style={styles.ratingContainer}>
                            <Icon name="star" size={14} color={theme.colors.warning} />
                            <Text style={styles.rating}>{item.rating.toFixed(1)}</Text>
                          </View>
                        )}
                        {item.price && (
                          <Text style={styles.price}>
                            {item.price.message || '$'.repeat(item.price.tier || 1)}
                          </Text>
                        )}
                      </View>
                    </View>
                  </View>
                </TouchableOpacity>
              )}
            />
          )}
        </View>

        <View style={styles.section}>
          <View style={styles.sectionHeader}>
            <Text style={styles.sectionTitle}>Nearby Restaurants</Text>
            <TouchableOpacity
              onPress={() => handleSeeAllPress('nearby')}
              accessible={true}
              accessibilityLabel="View all nearby restaurants"
              accessibilityRole="button"
            >
              <Text style={styles.seeAll}>See All</Text>
            </TouchableOpacity>
          </View>
          {nearbyLoading && nearbyVenues.length === 0 ? (
            <View style={styles.loadingRow}>
              <ActivityIndicator size="small" color={theme.colors.primary} />
              <Text style={styles.loadingText}>Finding nearby restaurants...</Text>
            </View>
          ) : nearbyError ? (
            <View style={styles.errorContainer}>
              <Icon name="error" size={24} color={theme.colors.error} />
              <Text style={styles.errorText}>{nearbyError}</Text>
              <TouchableOpacity style={styles.retryButton} onPress={loadVenues}>
                <Text style={styles.retryButtonText}>Try Again</Text>
              </TouchableOpacity>
            </View>
          ) : nearbyVenues.length === 0 ? (
            <View style={styles.emptyContainer}>
              <Icon name="place" size={40} color={theme.colors.grey3} />
              <Text style={styles.emptyText}>No nearby restaurants found</Text>
            </View>
          ) : (
            <View style={styles.nearbyContainer}>
              {nearbyVenues.slice(0, 5).map(venue => (
                <RestaurantCard
                  key={venue.id}
                  venue={venue}
                  isBucketListed={isVenueInBucketList(venue.id)}
                  compact={true}
                  onPress={() => handleVenuePress(venue.id)}
                />
              ))}
              <TouchableOpacity
                style={styles.viewAllButton}
                onPress={() => handleSeeAllPress('nearby')}
                accessible={true}
                accessibilityLabel="View all nearby restaurants"
                accessibilityRole="button"
              >
                <Text style={styles.viewAllText}>View All Nearby</Text>
                <Icon name="chevron-right" size={18} color={theme.colors.primary} />
              </TouchableOpacity>
            </View>
          )}
        </View>

        {isAuthenticated && bucketListItems.length > 0 && (
          <View style={styles.section}>
            <View style={styles.sectionHeader}>
              <Text style={styles.sectionTitle}>Your Bucket List</Text>
              <TouchableOpacity
                onPress={() => navigation.navigate('BucketList')}
                accessible={true}
                accessibilityLabel="View your bucket list"
                accessibilityRole="button"
              >
                <Text style={styles.seeAll}>See All</Text>
              </TouchableOpacity>
            </View>
            <ScrollView
              horizontal
              showsHorizontalScrollIndicator={false}
              contentContainerStyle={styles.bucketListPreview}
            >
              {bucketListItems.slice(0, 5).map(item => (
                <TouchableOpacity
                  key={item.id}
                  style={styles.bucketListItem}
                  onPress={() => handleVenuePress(item.venueId)}
                  accessible={true}
                  accessibilityLabel={`${item.venue.name} from your bucket list`}
                  accessibilityRole="button"
                >
                  <View style={styles.bucketListCard}>
                    <View style={styles.cardImageContainer}>
                      {item.venue.photos?.length > 0 ? (
                        <Image
                          source={{
                            uri: `${item.venue.photos[0].prefix}300x200${item.venue.photos[0].suffix}`,
                          }}
                          style={styles.cardImage}
                          resizeMode="cover"
                        />
                      ) : (
                        <View style={[styles.cardImage, styles.placeholderImage]}>
                          <Icon name="restaurant" size={30} color={theme.colors.grey3} />
                        </View>
                      )}
                      {item.priority && (
                        <View
                          style={[
                            styles.priorityBadge,
                            item.priority === 'high' && styles.highPriority,
                            item.priority === 'medium' && styles.mediumPriority,
                            item.priority === 'low' && styles.lowPriority,
                          ]}
                        >
                          <Icon name="flag" size={14} color="white" />
                        </View>
                      )}
                    </View>
                    <View style={styles.cardContent}>
                      <Text style={styles.cardTitle} numberOfLines={1}>
                        {item.venue.name}
                      </Text>
                      {item.venue.categories && item.venue.categories.length > 0 && (
                        <Text style={styles.cardCategory} numberOfLines={1}>
                          {item.venue.categories[0].name}
                        </Text>
                      )}
                      {item.visitedAt ? (
                        <View style={styles.visitedBadge}>
                          <Icon name="check-circle" size={14} color={theme.colors.success} />
                          <Text style={styles.visitedText}>Visited</Text>
                        </View>
                      ) : item.plannedVisitDate ? (
                        <Text style={styles.plannedDate}>
                          Planned: {new Date(item.plannedVisitDate).toLocaleDateString()}
                        </Text>
                      ) : null}
                    </View>
                  </View>
                </TouchableOpacity>
              ))}
            </ScrollView>
          </View>
        )}
        <View style={{ height: 80 }} />
      </ScrollView>
    </SafeAreaView>
  );
};

const { width } = Dimensions.get('window');

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: 'white' },
  scrollContent: { flexGrow: 1 },
  header: { padding: 16, paddingTop: Platform.OS === 'ios' ? 0 : 16 },
  headerContent: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' },
  greeting: { fontSize: 24, fontWeight: 'bold', marginBottom: 4, color: theme.colors.grey1 },
  subtitle: { fontSize: 16, color: theme.colors.grey3 },
  profileButton: {
    width: 40,
    height: 40,
    borderRadius: 20,
    backgroundColor: theme.colors.grey5,
    justifyContent: 'center',
    alignItems: 'center',
  },
  searchBarContainer: {
    paddingHorizontal: 16,
    marginBottom: 16,
    flexDirection: 'row',
    alignItems: 'center',
  },
  searchBar: {
    flex: 1,
    backgroundColor: theme.colors.grey5,
    borderRadius: 8,
    paddingHorizontal: 12,
    height: 40,
    fontSize: 16,
  },
  searchButton: { marginLeft: 8, padding: 8 },
  section: { marginBottom: 24 },
  sectionHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: 16,
    marginBottom: 12,
  },
  sectionTitle: { fontSize: 20, fontWeight: 'bold', color: theme.colors.grey1 },
  seeAll: { fontSize: 14, color: theme.colors.primary, fontWeight: '500' },
  categoriesContainer: { paddingHorizontal: 12 },
  recommendedList: { paddingHorizontal: 12, paddingVertical: 4 },
  recommendedItem: { width: width * 0.7, maxWidth: 280, marginHorizontal: 4 },
  recommendedCard: {
    borderRadius: 8,
    backgroundColor: theme.colors.background,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  cardImageContainer: { position: 'relative' },
  cardImage: { width: '100%', height: 150, backgroundColor: theme.colors.grey5 },
  placeholderImage: { justifyContent: 'center', alignItems: 'center' },
  bookmarkedBadge: {
    position: 'absolute',
    top: 8,
    right: 8,
    backgroundColor: theme.colors.primary,
    borderRadius: 12,
    width: 24,
    height: 24,
    justifyContent: 'center',
    alignItems: 'center',
  },
  priorityBadge: {
    position: 'absolute',
    top: 8,
    right: 8,
    borderRadius: 12,
    width: 24,
    height: 24,
    justifyContent: 'center',
    alignItems: 'center',
  },
  highPriority: { backgroundColor: theme.colors.error },
  mediumPriority: { backgroundColor: theme.colors.warning },
  lowPriority: { backgroundColor: theme.colors.success },
  cardContent: { padding: 12 },
  cardTitle: { fontSize: 16, fontWeight: 'bold', marginBottom: 4, color: theme.colors.grey1 },
  cardCategory: { fontSize: 14, color: theme.colors.grey3, marginBottom: 6 },
  cardFooter: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center' },
  ratingContainer: { flexDirection: 'row', alignItems: 'center' },
  rating: { fontSize: 14, marginLeft: 4, color: theme.colors.grey2 },
  price: { fontSize: 14, color: theme.colors.grey2 },
  nearbyContainer: { paddingHorizontal: 16 },
  viewAllButton: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    paddingVertical: 12,
    borderWidth: 1,
    borderColor: theme.colors.grey4,
    borderRadius: 8,
    marginVertical: 8,
  },
  viewAllText: { fontSize: 14, fontWeight: '500', color: theme.colors.primary, marginRight: 4 },
  bucketListPreview: { paddingHorizontal: 12, paddingVertical: 4 },
  bucketListItem: { width: width * 0.6, maxWidth: 240, marginHorizontal: 4 },
  bucketListCard: {
    borderRadius: 8,
    backgroundColor: theme.colors.background,
    elevation: 2,
    shadowColor: '#000',
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.1,
    shadowRadius: 4,
  },
  visitedBadge: { flexDirection: 'row', alignItems: 'center' },
  visitedText: { fontSize: 12, color: theme.colors.success, marginLeft: 4 },
  plannedDate: { fontSize: 12, color: theme.colors.grey3 },
  loadingContainer: { flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20 },
  loadingRow: { flexDirection: 'row', alignItems: 'center', justifyContent: 'center', padding: 20 },
  loadingText: { fontSize: 16, color: theme.colors.grey3, marginLeft: 12 },
  errorContainer: { padding: 20, alignItems: 'center', justifyContent: 'center' },
  errorText: { fontSize: 16, color: theme.colors.error, textAlign: 'center', marginVertical: 12 },
  emptyContainer: { padding: 40, alignItems: 'center', justifyContent: 'center' },
  emptyText: { fontSize: 16, color: theme.colors.grey3, textAlign: 'center', marginTop: 12 },
  retryButton: { padding: 10, borderRadius: 8, backgroundColor: theme.colors.primary },
  retryButtonText: { color: 'white', fontSize: 14, fontWeight: '500' },
});


--- File: packages/mobile/src/components/screens/HomeScreen.tsx ---
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { HomeNavigationProp } from '../../navigation/types';
import { theme } from '../../theme';

interface HomeScreenProps {
  navigation: HomeNavigationProp;
}

/**
 * Home Screen Component (Stub)
 */
export const HomeScreen: React.FC<HomeScreenProps> = ({ navigation }) => {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Home Screen</Text>
      <Text style={styles.description}>
        This is a stub for the HomeScreen component. It will be replaced with the actual implementation.
      </Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
    backgroundColor: theme.colors.background,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: theme.colors.primary,
  },
  description: {
    fontSize: 16,
    textAlign: 'center',
    color: theme.colors.textSecondary,
  },
});

export default HomeScreen;


--- File: packages/mobile/src/components/screens/OnBoardingScreen.tsx ---
import { useNavigation } from "@react-navigation/native";
import { StackNavigationProp } from "@react-navigation/stack";
import React from "react";
import { Button, StyleSheet, Text, View } from "react-native";
import { RootStackParamList } from "../../navigation/types"; // Assuming types are in ../../navigation
import { theme } from "../../theme"; // Assuming theme is in ../../theme
// import { useAppDispatch } from 'core/src/store'; // If using Redux for state management
// import { completeOnboarding } from 'core/src/store/slices/uiSlice'; // Action to mark onboarding complete

type OnBoardingScreenNavigationProp = StackNavigationProp<
  RootStackParamList,
  "OnBoarding"
>;

// Placeholder component for OnBoardingScreen
export const OnBoardingScreen = () => {
  const navigation = useNavigation<OnBoardingScreenNavigationProp>();
  // const dispatch = useAppDispatch(); // Uncomment if using Redux

  const handleCompleteOnboarding = () => {
    // Placeholder for completing onboarding logic
    console.log("Onboarding completed");
    // Mark onboarding as complete in state management (e.g., Redux)
    // dispatch(completeOnboarding());
    // Navigate to the main app or auth screen
    // This navigation depends on whether the user needs to authenticate next
    navigation.replace("Auth"); // Or 'Main' if authentication isn't required immediately after onboarding
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Welcome Onboarding!</Text>
      <Text style={styles.text}>
        (Placeholder: Implement onboarding steps/slides)
      </Text>
      <Button
        title="Get Started"
        onPress={handleCompleteOnboarding}
        color={theme.lightColors?.primary}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 16,
    backgroundColor: theme.lightColors?.background || "#FFFFFF",
  },
  title: {
    fontSize: 24,
    fontWeight: "bold",
    marginBottom: 24,
    color: theme.lightColors?.primary || "#000000",
    textAlign: "center",
  },
  text: {
    fontSize: 18,
    textAlign: "center",
    marginBottom: 32,
    color: theme.lightColors?.grey1 || "#424242",
  },
});

// Export the component
export default OnBoardingScreen;


--- File: packages/mobile/src/components/screens/ProfileScreen copy.tsx ---
import { useNavigation } from "@react-navigation/native";
import React from "react";
import { Button, StyleSheet, Text, View } from "react-native";
import { ProfileNavigationProp } from "../../navigation/types"; // Assuming types are in ../../navigation
import { theme } from "../../theme"; // Assuming theme is in ../../theme
// import { useAppDispatch, useAppSelector } from 'core/src/store'; // If using Redux
// import { logout } from 'core/src/store/slices/authSlice'; // Example Redux action

// Placeholder component for ProfileScreen
// Note: A ProfileScreen also exists in components/common. This aligns with the import path.
export const ProfileScreen = () => {
  const navigation = useNavigation<ProfileNavigationProp>();
  // const dispatch = useAppDispatch(); // Uncomment if using Redux
  // const user = useAppSelector((state) => state.auth.user); // Example Redux state

  const handleLogout = () => {
    // Placeholder for logout logic
    console.log("Logout button pressed");
    // dispatch(logout()); // Example Redux action
    // Navigation after logout usually handled by the main navigator based on auth state
  };

  const navigateToSettings = () => {
    navigation.navigate("Settings");
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Profile Screen</Text>
      {/* Example user info */}
      {/* <Text style={styles.text}>Welcome, {user?.displayName || 'User'}!</Text>
      <Text style={styles.text}>Email: {user?.email}</Text> */}
      <Text style={styles.text}>
        (Placeholder: Display user info, stats, settings links)
      </Text>
      <View style={styles.buttonContainer}>
        <Button
          title="Settings"
          onPress={navigateToSettings}
          color={theme.lightColors?.secondary}
        />
      </View>
      <View style={styles.buttonContainer}>
        <Button
          title="Log Out"
          onPress={handleLogout}
          color={theme.lightColors?.error}
        />
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    padding: 16,
    backgroundColor: theme.lightColors?.background || "#FFFFFF",
  },
  title: {
    fontSize: 22,
    fontWeight: "bold",
    marginBottom: 20,
    color: theme.lightColors?.primary || "#000000",
  },
  text: {
    fontSize: 16,
    textAlign: "center",
    marginBottom: 10,
    color: theme.lightColors?.grey1 || "#424242",
  },
  buttonContainer: {
    marginVertical: 10,
    width: "60%",
  },
});

// Export the component
export default ProfileScreen;


--- File: packages/mobile/src/components/screens/ProfileScreen.tsx ---
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { ProfileNavigationProp } from '../../navigation/types';
import { theme } from '../../theme';

interface ProfileScreenProps {
  navigation: ProfileNavigationProp;
}

/**
 * Profile Screen Component (Stub)
 */
export const ProfileScreen: React.FC<ProfileScreenProps> = ({ navigation }) => {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Profile Screen</Text>
      <Text style={styles.description}>
        This is a stub for the ProfileScreen component. It will be replaced with the actual implementation.
      </Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
    backgroundColor: theme.colors.background,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: theme.colors.primary,
  },
  description: {
    fontSize: 16,
    textAlign: 'center',
    color: theme.colors.textSecondary,
  },
});

export default ProfileScreen;


--- File: packages/mobile/src/components/screens/SearchScreen copy.tsx ---
import { useNavigation } from "@react-navigation/native";
import React, { useState } from "react";
import { Button, StyleSheet, Text, TextInput, View } from "react-native";
import { SearchNavigationProp } from "../../navigation/types"; // Assuming types are in ../../navigation
import { theme } from "../../theme"; // Assuming theme is in ../../theme
// import { useAppDispatch, useAppSelector } from 'core/src/store'; // If using Redux
// import { searchVenues } from 'core/src/store/slices/venuesSlice'; // Example Redux action

// Placeholder component for SearchScreen
// Note: A SearchScreen also exists in components/common. This aligns with the import path.
export const SearchScreen = () => {
  const navigation = useNavigation<SearchNavigationProp>();
  const [query, setQuery] = useState("");
  // const dispatch = useAppDispatch(); // Uncomment if using Redux
  // const searchResults = useAppSelector((state) => state.venues.search.venues); // Example Redux state
  // const isLoading = useAppSelector((state) => state.venues.search.loading); // Example Redux state

  const handleSearch = () => {
    if (query.trim()) {
      console.log("Searching for:", query);
      // dispatch(searchVenues({ query, coordinates: /* Get coordinates */ })); // Example Redux action
      // Optionally navigate to a dedicated results screen, or display results here
      navigation.navigate("Search", {
        screen: "SearchResults", // Example nested navigation
        params: { query: query },
      });
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Search Screen</Text>
      <TextInput
        style={styles.input}
        placeholder="Search for restaurants, cuisines..."
        value={query}
        onChangeText={setQuery}
        onSubmitEditing={handleSearch}
        returnKeyType="search"
      />
      <Button
        title="Search"
        onPress={handleSearch}
        color={theme.lightColors?.primary}
        // disabled={isLoading} // Disable button while loading
      />
      <Text style={styles.text}>
        (Placeholder: Display search results or suggestions below)
      </Text>
      {/* Placeholder for results list */}
      {/* {isLoading && <ActivityIndicator size="large" color={theme.lightColors?.primary} />} */}
      {/* <FlatList data={searchResults} renderItem={...} keyExtractor={...} /> */}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    paddingTop: 40, // Add padding to avoid status bar overlap
    backgroundColor: theme.lightColors?.background || "#FFFFFF",
  },
  title: {
    fontSize: 22,
    fontWeight: "bold",
    marginBottom: 16,
    textAlign: "center",
    color: theme.lightColors?.primary || "#000000",
  },
  input: {
    height: 45,
    borderColor: theme.lightColors?.grey4 || "#CCCCCC",
    borderWidth: 1,
    borderRadius: 8,
    paddingHorizontal: 12,
    marginBottom: 16,
    fontSize: 16,
    backgroundColor: theme.lightColors?.white || "#FFFFFF",
  },
  text: {
    fontSize: 16,
    textAlign: "center",
    marginTop: 20,
    color: theme.lightColors?.grey1 || "#424242",
  },
});

// Export the component
export default SearchScreen;


--- File: packages/mobile/src/components/screens/SearchScreen.tsx ---
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { SearchNavigationProp } from '../../navigation/types';
import { theme } from '../../theme';

interface SearchScreenProps {
  navigation: SearchNavigationProp;
}

/**
 * Search Screen Component (Stub)
 */
export const SearchScreen: React.FC<SearchScreenProps> = ({ navigation }) => {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Search Screen</Text>
      <Text style={styles.description}>
        This is a stub for the SearchScreen component. It will be replaced with the actual implementation.
      </Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
    backgroundColor: theme.colors.background,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    color: theme.colors.primary,
  },
  description: {
    fontSize: 16,
    textAlign: 'center',
    color: theme.colors.textSecondary,
  },
});

export default SearchScreen;


--- File: packages/mobile/src/components/screens/SettingsScreen.tsx ---
import React from "react";
import { StyleSheet, Switch, Text, View } from "react-native";
import { theme } from "../../theme"; // Assuming theme is in ../../theme
// import { useAppDispatch, useAppSelector } from 'core/src/store'; // If using Redux
// import { toggleTheme, setPreference } from 'core/src/store/slices/uiSlice'; // Example Redux actions

// Placeholder component for SettingsScreen
export const SettingsScreen = () => {
  // const dispatch = useAppDispatch(); // Uncomment if using Redux
  // const currentTheme = useAppSelector((state) => state.ui.theme); // Example Redux state
  // const isDark = currentTheme === 'dark';

  const handleThemeToggle = (value: boolean) => {
    console.log("Theme toggle:", value ? "dark" : "light");
    // dispatch(toggleTheme()); // Example Redux action
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Settings Screen</Text>

      <View style={styles.settingItem}>
        <Text style={styles.settingText}>Dark Mode</Text>
        <Switch
          // value={isDark} // Use Redux state if available
          // onValueChange={handleThemeToggle}
          trackColor={{
            false: theme.lightColors?.grey4,
            true: theme.lightColors?.primary,
          }}
          thumbColor={theme.lightColors?.white}
        />
      </View>

      <Text style={styles.placeholder}>
        (Placeholder: Add more settings like notifications, preferences, etc.)
      </Text>
      {/* Add more settings options here */}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: 16,
    backgroundColor: theme.lightColors?.background || "#FFFFFF",
  },
  title: {
    fontSize: 22,
    fontWeight: "bold",
    marginBottom: 24,
    color: theme.lightColors?.grey0 || "#000000",
  },
  settingItem: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingVertical: 12,
    borderBottomWidth: 1,
    borderBottomColor: theme.lightColors?.divider || "#EEEEEE",
  },
  settingText: {
    fontSize: 18,
    color: theme.lightColors?.grey1 || "#424242",
  },
  placeholder: {
    fontSize: 16,
    textAlign: "center",
    marginTop: 30,
    color: theme.lightColors?.grey3 || "#757575",
  },
});

// Export the component
export default SettingsScreen;


--- File: packages/mobile/src/components/screens/VenueDetailsScreen.tsx ---
import React, { useEffect, useState, useCallback, useMemo } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  TouchableOpacity,
  Image,
  Linking,
  Platform,
  Share,
  ActivityIndicator,
  Modal,
  TextInput,
} from 'react-native';
import { useRoute, useNavigation, RouteProp } from '@react-navigation/native';
import { StackNavigationProp } from '@react-navigation/stack';
import Icon from 'react-native-vector-icons/MaterialIcons';
import MapView, { Marker } from 'react-native-maps';
import { useAppDispatch, useAppSelector } from 'core/src/store';
import { selectVenue } from 'core/src/store/slices/venuesSlice';
import {
  addToBucketList,
  removeFromBucketList,
  updateBucketListItem,
  markAsVisited,
} from 'core/src/store/slices/bucketListSlice';
import { theme } from '../../theme';
import { getVenueImage } from '../../utils/imageUtils';
import { getDistanceString } from '../../utils/distanceUtils';
import { RootStackParamList } from '../../navigation/types';
import { BucketListItemForm } from '../forms/BucketListItemForm';

type VenueDetailsScreenRouteProp = RouteProp<RootStackParamList, 'VenueDetails'>;
type VenueDetailsScreenNavigationProp = StackNavigationProp<RootStackParamList, 'VenueDetails'>;

export const VenueDetailsScreen: React.FC = () => {
  const route = useRoute<VenueDetailsScreenRouteProp>();
  const navigation = useNavigation<VenueDetailsScreenNavigationProp>();
  const dispatch = useAppDispatch();
  const { venueId } = route.params;
  const venue = useAppSelector(state => state.venues.selectedVenue);
  const userLocation = useAppSelector(state => state.venues.userLocation);
  const isAuthenticated = useAppSelector(state => state.auth.isAuthenticated);
  const bucketListItems = useAppSelector(state => state.bucketList.items);

  const [isLoading, setIsLoading] = useState<boolean>(true);
  const [formVisible, setFormVisible] = useState<boolean>(false);
  const [visitedModalVisible, setVisitedModalVisible] = useState<boolean>(false);
  const [rating, setRating] = useState<number>(0);
  const [review, setReview] = useState<string>('');

  const bucketListItem = useMemo(() => {
    return bucketListItems.find(item => item.venueId === venueId);
  }, [bucketListItems, venueId]);

  const isBucketListed = !!bucketListItem;

  const mainImage = useMemo(() => {
    return getVenueImage(venue, 600, 400);
  }, [venue]);

  const distance = useMemo(() => {
    if (userLocation && venue?.location) {
      return getDistanceString(
        userLocation.latitude,
        userLocation.longitude,
        venue.location.lat,
        venue.location.lng
      );
    }
    return null;
  }, [userLocation, venue?.location]);

  useEffect(() => {
    const loadVenue = async () => {
      setIsLoading(true);
      await dispatch(selectVenue(venueId));
      setIsLoading(false);
    };

    if (venueId) {
      loadVenue();
    }
  }, [dispatch, venueId]);

  useEffect(() => {
    if (venue) {
      navigation.setOptions({
        title: venue.name,
        headerRight: () => (
          <TouchableOpacity
            onPress={handleShare}
            style={{ marginRight: 16 }}
            accessibilityLabel="Share this venue"
            accessibilityRole="button"
          >
            <Icon name="share" size={24} color={theme.colors.primary} />
          </TouchableOpacity>
        ),
      });
    }
  }, [navigation, venue]);

  const handleBucketListToggle = useCallback(() => {
    if (!isAuthenticated) {
      navigation.navigate('Auth');
      return;
    }

    if (isBucketListed) {
      dispatch(removeFromBucketList(bucketListItem!.id));
    } else {
      setFormVisible(true);
    }
  }, [dispatch, isAuthenticated, isBucketListed, bucketListItem, navigation]);

  const handleEditBucketList = useCallback(() => {
    if (bucketListItem) {
      setFormVisible(true);
    }
  }, [bucketListItem]);

  const handleFormSubmit = useCallback(
    (data: {
      notes?: string;
      tags?: string[];
      priority?: 'low' | 'medium' | 'high';
      plannedVisitDate?: Date;
    }) => {
      if (isBucketListed && bucketListItem) {
        dispatch(
          updateBucketListItem({
            id: bucketListItem.id,
            updates: {
              ...data,
              plannedVisitDate: data.plannedVisitDate?.getTime(),
            },
          })
        );
      } else {
        dispatch(
          addToBucketList({
            venueId,
            ...data,
            plannedVisitDate: data.plannedVisitDate?.getTime(),
          })
        );
      }

      setFormVisible(false);
    },
    [dispatch, venueId, isBucketListed, bucketListItem]
  );

  const handleMarkAsVisited = useCallback(() => {
    setVisitedModalVisible(true);
  }, []);

  const handleVisitedSubmit = useCallback(() => {
    if (bucketListItem) {
      dispatch(
        markAsVisited({
          id: bucketListItem.id,
          rating,
          review: review.trim() || undefined,
        })
      );
      setVisitedModalVisible(false);
    }
  }, [dispatch, bucketListItem, rating, review]);

  const handleDirections = useCallback(() => {
    if (!venue?.location) return;

    const { lat, lng } = venue.location;
    const url = Platform.select({
      ios: `maps:?q=${venue.name}&ll=${lat},${lng}`,
      android: `geo:${lat},${lng}?q=${lat},${lng}(${venue.name})`,
    });

    if (url) {
      Linking.openURL(url);
    }
  }, [venue]);

  const handleOpenWebsite = useCallback(() => {
    if (venue?.url) {
      Linking.openURL(venue.url);
    }
  }, [venue?.url]);

  const handleCall = useCallback(() => {
    if (venue?.contact?.phone) {
      Linking.openURL(`tel:${venue.contact.phone}`);
    }
  }, [venue?.contact?.phone]);

  const handleShare = useCallback(() => {
    if (!venue) return;

    const title = `Check out ${venue.name}`;
    const message = `I found ${venue.name} and thought you might be interested!\n${
      venue.location?.formattedAddress || ''
    }`;
    const url = venue.url;

    Share.share({
      title,
      message: url ? `${message}\n${url}` : message,
    });
  }, [venue]);

  if (isLoading || !venue) {
    return (
      <View style={styles.loadingContainer}>
        <ActivityIndicator size="large" color={theme.colors.primary} />
        <Text style={styles.loadingText}>Loading venue details...</Text>
      </View>
    );
  }

  const categoryText = venue.categories?.map(cat => cat.name).join(', ') || '';
  const priceText = venue.price?.message || (venue.price?.tier ? '$'.repeat(venue.price.tier) : '');

  return (
    <View style={styles.container}>
      <ScrollView
        contentContainerStyle={styles.scrollContainer}
        showsVerticalScrollIndicator={false}
      >
        {mainImage ? (
          <Image source={{ uri: mainImage }} style={styles.mainImage} />
        ) : (
          <View style={[styles.mainImage, styles.placeholderImage]}>
            <Icon name="restaurant" size={60} color={theme.colors.grey3} />
          </View>
        )}
        <View style={styles.headerContainer}>
          <View style={styles.titleContainer}>
            <Text style={styles.title}>{venue.name}</Text>
            {venue.rating ? (
              <View style={styles.ratingContainer}>
                <Text style={styles.rating}>{venue.rating.toFixed(1)}</Text>
                <Icon name="star" size={16} color={theme.colors.warning} />
              </View>
            ) : null}
          </View>
          {categoryText ? <Text style={styles.category}>{categoryText}</Text> : null}
          <View style={styles.tagsContainer}>
            {priceText ? (
              <View style={styles.chip}>
                <Text style={styles.chipText}>{priceText}</Text>
              </View>
            ) : null}
            {distance ? (
              <View style={styles.chip}>
                <Text style={styles.chipText}>{distance}</Text>
              </View>
            ) : null}
            {venue.hours?.isOpen !== undefined && (
              <View
                style={[
                  styles.chip,
                  { borderColor: venue.hours.isOpen ? theme.colors.success : theme.colors.error },
                ]}
              >
                <Text
                  style={[
                    styles.chipText,
                    { color: venue.hours.isOpen ? theme.colors.success : theme.colors.error },
                  ]}
                >
                  {venue.hours.isOpen ? 'Open' : 'Closed'}
                </Text>
              </View>
            )}
          </View>
          {venue.hours?.displayHours && venue.hours.displayHours.length > 0 && (
            <View style={styles.hoursContainer}>
              <Text style={styles.sectionTitle}>Hours</Text>
              {venue.hours.displayHours.map((hour, index) => (
                <Text key={index} style={styles.hourText}>
                  {hour}
                </Text>
              ))}
            </View>
          )}
        </View>
        <View style={styles.divider} />
        <View style={styles.actionsContainer}>
          <TouchableOpacity
            style={[
              styles.actionButton,
              isBucketListed ? styles.solidButton : styles.outlineButton,
            ]}
            onPress={handleBucketListToggle}
          >
            <Icon
              name={isBucketListed ? 'bookmark' : 'bookmark-outline'}
              type="material-community"
              color={isBucketListed ? 'white' : theme.colors.primary}
              size={20}
            />
            <Text
              style={[
                styles.actionButtonText,
                isBucketListed ? styles.solidButtonText : styles.outlineButtonText,
              ]}
            >
              {isBucketListed ? 'Saved' : 'Save'}
            </Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.actionButton} onPress={handleDirections}>
            <Icon name="directions" size={20} color={theme.colors.primary} />
            <Text style={styles.actionButtonText}>Directions</Text>
          </TouchableOpacity>
          {venue.contact?.phone && (
            <TouchableOpacity style={styles.actionButton} onPress={handleCall}>
              <Icon name="phone" size={20} color={theme.colors.primary} />
              <Text style={styles.actionButtonText}>Call</Text>
            </TouchableOpacity>
          )}
        </View>
        {isBucketListed && (
          <View style={styles.bucketListActionsContainer}>
            <TouchableOpacity style={styles.smallButton} onPress={handleEditBucketList}>
              <Icon name="edit" size={16} color={theme.colors.primary} />
              <Text style={styles.smallButtonText}>Edit Details</Text>
            </TouchableOpacity>
            {!bucketListItem?.visitedAt && (
              <TouchableOpacity style={styles.smallButton} onPress={handleMarkAsVisited}>
                <Icon name="check-circle" size={16} color={theme.colors.success} />
                <Text style={[styles.smallButtonText, { color: theme.colors.success }]}>
                  Mark as Visited
                </Text>
              </TouchableOpacity>
            )}
          </View>
        )}
        <View style={styles.divider} />
        {venue.location?.formattedAddress && (
          <View style={styles.sectionContainer}>
            <Text style={styles.sectionTitle}>Address</Text>
            <View style={styles.addressContainer}>
              <Icon name="place" size={20} color={theme.colors.grey3} />
              <Text style={styles.address}>
                {typeof venue.location.formattedAddress === 'string'
                  ? venue.location.formattedAddress
                  : venue.location.formattedAddress.join(', ')}
              </Text>
            </View>
          </View>
        )}
        {venue.location?.lat && venue.location?.lng && (
          <View style={styles.mapContainer}>
            <MapView
              style={styles.map}
              initialRegion={{
                latitude: venue.location.lat,
                longitude: venue.location.lng,
                latitudeDelta: 0.005,
                longitudeDelta: 0.005,
              }}
            >
              <Marker
                coordinate={{
                  latitude: venue.location.lat,
                  longitude: venue.location.lng,
                }}
                title={venue.name}
                description={categoryText}
              />
            </MapView>
            <TouchableOpacity
              style={styles.directionsButton}
              onPress={handleDirections}
              accessible={true}
              accessibilityLabel="Get directions to this venue"
              accessibilityRole="button"
            >
              <Text style={styles.directionsButtonText}>Directions</Text>
              <Icon name="directions" size={16} color="white" />
            </TouchableOpacity>
          </View>
        )}
        {isBucketListed && bucketListItem?.notes && (
          <View style={styles.sectionContainer}>
            <Text style={styles.sectionTitle}>Your Notes</Text>
            <Text style={styles.notes}>{bucketListItem.notes}</Text>
          </View>
        )}
        {isBucketListed && bucketListItem?.visitedAt && (
          <View style={styles.sectionContainer}>
            <Text style={styles.sectionTitle}>Your Visit</Text>
            <Text style={styles.visitedDate}>
              Visited on {new Date(bucketListItem.visitedAt).toLocaleDateString()}
            </Text>
            {bucketListItem.rating && (
              <View style={styles.userRatingContainer}>
                <Text style={styles.userRatingLabel}>Your Rating: </Text>
                <View style={styles.userRatingStars}>
                  {Array.from({ length: 5 }).map((_, i) => (
                    <Icon
                      key={i}
                      name="star"
                      size={20}
                      color={i < bucketListItem.rating! ? theme.colors.warning : theme.colors.grey4}
                    />
                  ))}
                </View>
              </View>
            )}
            {bucketListItem.review && (
              <View style={styles.reviewContainer}>
                <Text style={styles.reviewLabel}>Your Review:</Text>
                <Text style={styles.review}>{bucketListItem.review}</Text>
              </View>
            )}
          </View>
        )}
        {venue.description && (
          <View style={styles.sectionContainer}>
            <Text style={styles.sectionTitle}>About</Text>
            <Text style={styles.description}>{venue.description}</Text>
          </View>
        )}
        {venue.url && (
          <View style={styles.sectionContainer}>
            <Text style={styles.sectionTitle}>Website</Text>
            <TouchableOpacity
              onPress={handleOpenWebsite}
              style={styles.websiteButton}
              accessible={true}
              accessibilityLabel="Visit website"
              accessibilityRole="button"
            >
              <Text style={styles.websiteButtonText}>{venue.url}</Text>
              <Icon name="open-in-new" size={16} color={theme.colors.primary} />
            </TouchableOpacity>
          </View>
        )}
        {(venue.contact?.phone || venue.contact?.formattedPhone) && (
          <View style={styles.sectionContainer}>
            <Text style={styles.sectionTitle}>Contact</Text>
            <TouchableOpacity
              onPress={handleCall}
              style={styles.contactButton}
              accessible={true}
              accessibilityLabel={`Call ${venue.name}`}
              accessibilityRole="button"
            >
              <Icon name="phone" size={20} color={theme.colors.primary} />
              <Text style={styles.contactButtonText}>
                {venue.contact.formattedPhone || venue.contact.phone}
              </Text>
            </TouchableOpacity>
          </View>
        )}
        <View style={{ height: 80 }} />
      </ScrollView>
      <Modal
        visible={formVisible}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setFormVisible(false)}
      >
        <View style={styles.formOverlay}>
          <BucketListItemForm
            venueId={venueId}
            initialData={
              isBucketListed
                ? {
                    notes: bucketListItem?.notes,
                    tags: bucketListItem?.tags,
                    priority: bucketListItem?.priority,
                    plannedVisitDate: bucketListItem?.plannedVisitDate
                      ? new Date(bucketListItem.plannedVisitDate)
                      : undefined,
                  }
                : undefined
            }
            onSubmit={handleFormSubmit}
            onCancel={() => setFormVisible(false)}
          />
        </View>
      </Modal>
      <Modal
        visible={visitedModalVisible}
        transparent={true}
        animationType="slide"
        onRequestClose={() => setVisitedModalVisible(false)}
      >
        <View style={styles.formOverlay}>
          <View style={styles.visitedForm}>
            <Text style={styles.formTitle}>Mark as Visited</Text>
            <Text style={styles.formLabel}>How would you rate your experience?</Text>
            <View style={styles.ratingInputContainer}>
              {Array.from({ length: 5 }).map((_, i) => (
                <TouchableOpacity
                  key={i}
                  onPress={() => setRating(i + 1)}
                  style={styles.ratingButton}
                  accessible={true}
                  accessibilityLabel={`Rate ${i + 1} stars`}
                  accessibilityRole="button"
                >
                  <Icon
                    name="star"
                    size={32}
                    color={i < rating ? theme.colors.warning : theme.colors.grey4}
                  />
                </TouchableOpacity>
              ))}
            </View>
            <Text style={styles.formLabel}>Add a review (optional)</Text>
            <TextInput
              style={styles.reviewInput}
              value={review}
              onChangeText={setReview}
              placeholder="Share your experience..."
              multiline
              numberOfLines={4}
              textAlignVertical="top"
            />
            <View style={styles.formButtons}>
              <TouchableOpacity
                style={[styles.formButton, styles.outlineButton]}
                onPress={() => setVisitedModalVisible(false)}
              >
                <Text style={styles.outlineButtonText}>Cancel</Text>
              </TouchableOpacity>
              <TouchableOpacity
                style={[
                  styles.formButton,
                  rating === 0 ? styles.disabledButton : styles.solidButton,
                ]}
                onPress={handleVisitedSubmit}
                disabled={rating === 0}
              >
                <Text style={styles.solidButtonText}>Submit</Text>
              </TouchableOpacity>
            </View>
          </View>
        </View>
      </Modal>
      <TouchableOpacity
        style={styles.fab}
        onPress={handleBucketListToggle}
        accessible={true}
        accessibilityLabel={isBucketListed ? 'Remove from bucket list' : 'Add to bucket list'}
        accessibilityRole="button"
      >
        <Icon
          name={isBucketListed ? 'bookmark' : 'bookmark-outline'}
          type="material-community"
          color="white"
          size={24}
        />
        <Text style={styles.fabText}>{isBucketListed ? 'Saved' : 'Save'}</Text>
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: 'white' },
  scrollContainer: { flexGrow: 1 },
  loadingContainer: { flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20 },
  loadingText: { marginTop: 16, fontSize: 16, color: theme.colors.grey3 },
  mainImage: { width: '100%', height: 250 },
  placeholderImage: {
    backgroundColor: theme.colors.grey5,
    justifyContent: 'center',
    alignItems: 'center',
  },
  headerContainer: { padding: 16 },
  titleContainer: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: 4,
  },
  title: { fontSize: 22, fontWeight: 'bold', flex: 1, marginRight: 8 },
  ratingContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: theme.colors.grey5,
    paddingHorizontal: 8,
    paddingVertical: 4,
    borderRadius: 12,
  },
  rating: { fontSize: 16, fontWeight: 'bold', marginRight: 2 },
  category: { fontSize: 16, color: theme.colors.grey3, marginBottom: 12 },
  tagsContainer: { flexDirection: 'row', flexWrap: 'wrap', gap: 8, marginBottom: 12 },
  chip: {
    borderWidth: 1,
    borderColor: theme.colors.grey4,
    borderRadius: 16,
    paddingHorizontal: 12,
    paddingVertical: 4,
  },
  chipText: { fontSize: 14, color: theme.colors.grey2 },
  hoursContainer: { marginTop: 8 },
  hourText: { fontSize: 14, marginBottom: 2, color: theme.colors.grey2 },
  divider: { height: 1, backgroundColor: theme.colors.grey4, marginVertical: 8 },
  actionsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    padding: 8,
    marginHorizontal: 8,
  },
  actionButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderWidth: 1,
    borderColor: theme.colors.primary,
    borderRadius: 8,
    minWidth: 100,
  },
  actionButtonText: { fontSize: 14, color: theme.colors.primary, marginLeft: 8 },
  solidButton: { backgroundColor: theme.colors.primary, borderColor: theme.colors.primary },
  outlineButton: { backgroundColor: 'transparent', borderColor: theme.colors.primary },
  solidButtonText: { color: 'white' },
  outlineButtonText: { color: theme.colors.primary },
  bucketListActionsContainer: { flexDirection: 'row', justifyContent: 'center', padding: 8 },
  smallButton: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 8,
    paddingVertical: 4,
  },
  smallButtonText: { fontSize: 12, marginLeft: 4 },
  sectionContainer: { padding: 16 },
  sectionTitle: { fontSize: 18, fontWeight: 'bold', marginBottom: 8, color: theme.colors.grey1 },
  addressContainer: { flexDirection: 'row', alignItems: 'flex-start' },
  address: { fontSize: 16, flex: 1, marginLeft: 8, color: theme.colors.grey2 },
  mapContainer: {
    height: 200,
    marginHorizontal: 16,
    marginBottom: 16,
    borderRadius: 8,
    overflow: 'hidden',
  },
  map: { ...StyleSheet.absoluteFillObject },
  directionsButton: {
    position: 'absolute',
    bottom: 12,
    right: 12,
    backgroundColor: theme.colors.primary,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 6,
    borderRadius: 16,
  },
  directionsButtonText: { color: 'white', fontWeight: 'bold', marginRight: 4 },
  notes: {
    fontSize: 16,
    color: theme.colors.grey2,
    backgroundColor: theme.colors.grey5,
    padding: 12,
    borderRadius: 8,
    fontStyle: 'italic',
  },
  visitedDate: { fontSize: 16, color: theme.colors.grey2, marginBottom: 8 },
  userRatingContainer: { flexDirection: 'row', alignItems: 'center', marginVertical: 8 },
  userRatingLabel: { fontSize: 16, color: theme.colors.grey2 },
  userRatingStars: { flexDirection: 'row', marginLeft: 8 },
  reviewContainer: { marginTop: 8 },
  reviewLabel: { fontSize: 16, color: theme.colors.grey2, marginBottom: 4 },
  review: {
    fontSize: 16,
    color: theme.colors.grey2,
    backgroundColor: theme.colors.grey5,
    padding: 12,
    borderRadius: 8,
  },
  description: { fontSize: 16, color: theme.colors.grey2, lineHeight: 22 },
  websiteButton: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
    backgroundColor: theme.colors.grey5,
    padding: 12,
    borderRadius: 8,
  },
  websiteButtonText: { fontSize: 16, color: theme.colors.primary, flex: 1 },
  contactButton: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: theme.colors.grey5,
    padding: 12,
    borderRadius: 8,
  },
  contactButtonText: { fontSize: 16, color: theme.colors.primary, marginLeft: 8 },
  formOverlay: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(0,0,0,0.5)',
    padding: 16,
  },
  visitedForm: {
    backgroundColor: 'white',
    borderRadius: 8,
    padding: 20,
    width: '90%',
    maxWidth: 400,
  },
  formTitle: { fontSize: 20, fontWeight: 'bold', marginBottom: 16, textAlign: 'center' },
  formLabel: { fontSize: 16, marginBottom: 8, color: theme.colors.grey1 },
  ratingInputContainer: { flexDirection: 'row', justifyContent: 'space-around', marginBottom: 20 },
  ratingButton: { padding: 8 },
  reviewInput: {
    borderWidth: 1,
    borderColor: theme.colors.grey4,
    borderRadius: 8,
    padding: 12,
    fontSize: 16,
    height: 120,
    marginBottom: 20,
  },
  formButtons: { flexDirection: 'row', justifyContent: 'space-around' },
  formButton: { paddingHorizontal: 16, paddingVertical: 10, borderRadius: 8 },
  disabledButton: { backgroundColor: theme.colors.grey4, borderColor: theme.colors.grey4 },
  fab: {
    position: 'absolute',
    bottom: 16,
    right: 16,
    backgroundColor: theme.colors.primary,
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: 12,
    paddingVertical: 8,
    borderRadius: 24,
  },
  fabText: { color: 'white', fontSize: 14, marginLeft: 8 },
});


--- File: packages/mobile/src/navigation/LocationPermissionRequest.tsx ---
import React from 'react';
import { View, Text, StyleSheet, Linking, Platform, ScrollView } from 'react-native';
import Icon from 'react-native-vector-icons/MaterialIcons';
import { SafeAreaView } from 'react-native-safe-area-context';
import { theme } from '../../theme';

interface LocationPermissionRequestProps {
  onRequestLocation: () => void;
}

export const LocationPermissionRequest: React.FC<LocationPermissionRequestProps> = ({
  onRequestLocation,
}) => {
  const openSettings = () => {
    Linking.openSettings();
  };

  return (
    <SafeAreaView style={styles.safeArea}>
      <ScrollView contentContainerStyle={styles.container} showsVerticalScrollIndicator={false}>
        <View style={styles.iconContainer}>
          <Icon name="location-on" size={80} color={theme.colors.primary} />
        </View>
        <Text style={styles.title}>Location Access Needed</Text>
        <Text style={styles.description}>
          Restaurant Bucket List needs access to your location to find restaurants near you. We use
          this information only to show you relevant results and never track or store your location
          data.
        </Text>
        <View style={styles.benefitsContainer}>
          <View style={styles.benefitItem}>
            <Icon name="place" size={24} color={theme.colors.primary} />
            <Text style={styles.benefitText}>Discover nearby restaurants</Text>
          </View>
          <View style={styles.benefitItem}>
            <Icon name="star" size={24} color={theme.colors.primary} />
            <Text style={styles.benefitText}>Get personalized recommendations</Text>
          </View>
          <View style={styles.benefitItem}>
            <Icon name="directions" size={24} color={theme.colors.primary} />
            <Text style={styles.benefitText}>See distances and get directions</Text>
          </View>
        </View>
        <View style={styles.buttonsContainer}>
          <TouchableOpacity style={styles.primaryButton} onPress={onRequestLocation}>
            <Icon name="location-on" size={20} color="white" style={styles.buttonIcon} />
            <Text style={styles.buttonTitle}>Allow Location Access</Text>
          </TouchableOpacity>
          <TouchableOpacity style={styles.secondaryButton} onPress={openSettings}>
            <Icon
              name="settings"
              size={20}
              color={theme.colors.primary}
              style={styles.buttonIcon}
            />
            <Text style={styles.secondaryButtonTitle}>Open Settings</Text>
          </TouchableOpacity>
          <Text style={styles.privacyNote}>
            You can change this permission later in your device settings.
          </Text>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
};

const styles = StyleSheet.create({
  safeArea: { flex: 1, backgroundColor: 'white' },
  container: { flexGrow: 1, alignItems: 'center', padding: 24, justifyContent: 'center' },
  iconContainer: {
    width: 140,
    height: 140,
    borderRadius: 70,
    backgroundColor: theme.colors.grey5,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 24,
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    marginBottom: 16,
    textAlign: 'center',
    color: theme.colors.grey1,
  },
  description: {
    fontSize: 16,
    textAlign: 'center',
    marginBottom: 32,
    color: theme.colors.grey2,
    lineHeight: 24,
  },
  benefitsContainer: { width: '100%', marginBottom: 32 },
  benefitItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: 16,
    paddingHorizontal: 8,
  },
  benefitText: { fontSize: 16, marginLeft: 12, color: theme.colors.grey2 },
  buttonsContainer: { width: '100%', alignItems: 'center' },
  primaryButton: {
    backgroundColor: theme.colors.primary,
    borderRadius: 8,
    paddingVertical: 12,
    width: '100%',
    marginBottom: 16,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  buttonTitle: { fontSize: 16, fontWeight: '600', color: 'white' },
  secondaryButton: {
    borderColor: theme.colors.primary,
    borderWidth: 1,
    borderRadius: 8,
    paddingVertical: 12,
    width: '100%',
    marginBottom: 20,
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
  },
  secondaryButtonTitle: { color: theme.colors.primary, fontSize: 16, fontWeight: '600' },
  buttonIcon: { marginRight: 8 },
  privacyNote: { fontSize: 14, textAlign: 'center', color: theme.colors.grey3, marginTop: 8 },
});


--- File: packages/mobile/src/navigation/MainNavigator.tsx ---
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { createStackNavigator } from '@react-navigation/stack';
import { Icon } from '@rneui/themed';
import { useAppSelector } from 'core/src/store';
import React from 'react';
import { Platform } from 'react-native';
import { theme } from '../theme';

// Import screens
import { BucketListScreen } from '../components/screens/BucketListScreen';
import { ExploreScreen } from '../components/screens/ExploreScreen';
import { ProfileScreen } from '../components/screens/ProfileScreen';
import { SearchScreen } from '../components/screens/SearchScreen';

// Import types
import { MainTabParamList, RootStackParamList } from './types';

// Create navigators
const Stack = createStackNavigator<RootStackParamList>();
const Tab = createBottomTabNavigator<MainTabParamList>();

/**
 * Bottom Tab Navigator
 * - Provides the main navigation tabs for the app
 * - Includes icons and labels for each tab
 * - Handles badge indicators for bucket list
 */
const MainTabNavigator = () => {
  const bucketListCount = useAppSelector(state => state.bucketList.items.length);

  return (
    <Tab.Navigator
      screenOptions={{
        tabBarActiveTintColor: theme.colors.primary,
        tabBarInactiveTintColor: theme.colors.grey3,
        tabBarLabelStyle: {
          fontSize: 12,
          fontWeight: '500',
        },
        tabBarStyle: {
          paddingVertical: Platform.OS === 'ios' ? 10 : 5,
          height: Platform.OS === 'ios' ? 90 : 70,
        },
        headerShown: false,
      }}
    >
      <Tab.Screen
        name="Explore"
        component={ExploreScreen}
        options={{
          tabBarIcon: ({ color, size }) => (
            <Icon name="explore" type="material" color={color} size={size} />
          ),
        }}
      />
    </Tab.Navigator>
  );
};


--- File: packages/mobile/src/navigation/types.ts ---
import { StackNavigationProp } from '@react-navigation/stack';
import { BottomTabNavigationProp } from '@react-navigation/bottom-tabs';
import { CompositeNavigationProp } from '@react-navigation/native';

// Define root stack param list
export type RootStackParamList = {
  Main: undefined;
  Details: { id: string };
};

// Define bottom tab param list
export type MainTabParamList = {
  Explore: undefined;
  Home: undefined;
  Search: undefined;
  BucketList: undefined;
  Profile: undefined;
};

// Define combined navigation types
export type ExploreNavigationProp = CompositeNavigationProp<
  BottomTabNavigationProp<MainTabParamList, 'Explore'>,
  StackNavigationProp<RootStackParamList>
>;

// Define combined navigation types
export type HomeNavigationProp = CompositeNavigationProp<
  BottomTabNavigationProp<MainTabParamList, 'Home'>,
  StackNavigationProp<RootStackParamList>
>;

export type SearchNavigationProp = CompositeNavigationProp<
  BottomTabNavigationProp<MainTabParamList, 'Search'>,
  StackNavigationProp<RootStackParamList>
>;

export type BucketListNavigationProp = CompositeNavigationProp<
  BottomTabNavigationProp<MainTabParamList, 'BucketList'>,
  StackNavigationProp<RootStackParamList>
>;

export type ProfileNavigationProp = CompositeNavigationProp<
  BottomTabNavigationProp<MainTabParamList, 'Profile'>,
  StackNavigationProp<RootStackParamList>
>;


--- File: packages/mobile/src/theme/categories.ts ---
  export const categories = [
    {
      id: '13065',
      name: 'Restaurant',
      icon: 'restaurant',
      color: theme.lightColors.primary,
    },
    {
      id: '13034',
      name: 'Cafe',
      icon: 'local-cafe',
      color: '#8D6E63',
    },
    {
      id: '13003',
      name: 'Bar',
      icon: 'local-bar',
      color: '#7B1FA2',
    },
    {
      id: '13145',
      name: 'Fast Food',
      icon: 'fastfood',
      color: '#F57C00',
    },
    {
      id: '13350',
      name: 'Pizza',
      icon: 'local-pizza',
      color: '#D32F2F',
    },
    {
      id: '13274',
      name: 'Breakfast',
      icon: 'free-breakfast',
      color: '#FFA000',
    },
    {
      id: '13065',
      name: 'Dessert',
      icon: 'cake',
      color: '#FBC02D',
    },
    {
      id: '13065',
      name: 'Ice Cream',
      icon: 'icecream',
      color: '#FFB74D',
    },
    {
      id: '13065',
      name: 'Bakery',
      icon: 'bakery_dining',
      color: '#FF7043',
    }]



--- File: packages/mobile/src/theme/index.ts ---
/**
 * Theme colors and styles for the app
 */
export const theme = {
  colors: {
    primary: '#FF5A5F', // Airbnb-inspired red
    primaryDark: '#E04146',
    primaryLight: '#FF8A8F',
    secondary: '#00A699', // Teal
    background: '#FFFFFF',
    backgroundDark: '#121212',
    surface: '#FFFFFF',
    surfaceDark: '#1E1E1E',
    error: '#F44336',
    warning: '#FF9800',
    success: '#4CAF50',
    info: '#2196F3',
    
    // Gray scale
    grey1: '#212121',
    grey2: '#424242',
    grey3: '#757575',
    grey4: '#BDBDBD',
    grey5: '#E0E0E0',
    grey6: '#F5F5F5',
    
    // Text colors
    text: '#212121',
    textSecondary: '#757575',
    textDark: '#FFFFFF',
    textSecondaryDark: '#BDBDBD',
  },
  
  // Typography
  typography: {
    h1: {
      fontSize: 32,
      fontWeight: 'bold',
    },
    h2: {
      fontSize: 24,
      fontWeight: 'bold',
    },
    body1: {
      fontSize: 16,
    },
    body2: {
      fontSize: 14,
    },
  },
  
  // Spacing
  spacing: {
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32,
  },
  
  // Radius
  radius: {
    sm: 4,
    md: 8,
    lg: 16,
    round: 9999,
  },
};

/**
 * Get theme based on mode
 * @param mode 'light' or 'dark'
 */
export const getTheme = (mode: 'light' | 'dark') => {
  const baseTheme = { ...theme };
  
  if (mode === 'dark') {
    return {
      ...baseTheme,
      colors: {
        ...baseTheme.colors,
        background: baseTheme.colors.backgroundDark,
        surface: baseTheme.colors.surfaceDark,
        text: baseTheme.colors.textDark,
        textSecondary: baseTheme.colors.textSecondaryDark,
      },
    };
  }
  
  return baseTheme;
};


--- File: packages/mobile/src/utils/distanceUtils.ts ---
/**
 * Utility functions for calculating and formatting distances
 */

/**
 * Convert degrees to radians
 */
const degreesToRadians = (degrees: number): number => {
  return degrees * (Math.PI / 180);
};

/**
 * Calculate distance between two coordinates using the Haversine formula
 * @param lat1 Latitude of point 1
 * @param lon1 Longitude of point 1
 * @param lat2 Latitude of point 2
 * @param lon2 Longitude of point 2
 * @returns Distance in meters
 */
export const getDistance = (
  lat1: number,
  lon1: number,
  lat2: number,
  lon2: number
): number => {
  const R = 6371e3; // Earth's radius in meters
  const φ1 = degreesToRadians(lat1);
  const φ2 = degreesToRadians(lat2);
  const Δφ = degreesToRadians(lat2 - lat1);
  const Δλ = degreesToRadians(lon2 - lon1);

  const a =
    Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
    Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  const distance = R * c;
  return distance;
};

/**
 * Format distance in a user-friendly way
 * @param lat1 Latitude of point 1
 * @param lon1 Longitude of point 1
 * @param lat2 Latitude of point 2
 * @param lon2 Longitude of point 2
 * @returns Formatted distance string (e.g., "125 m" or "2.4 km")
 */
export const getDistanceString = (
  lat1: number,
  lon1: number,
  lat2: number,
  lon2: number
): string => {
  const distance = getDistance(lat1, lon1, lat2, lon2);

  // Format distance
  if (distance < 1000) {
    return `${Math.round(distance)} m`;
  } else {
    return `${(distance / 1000).toFixed(1)} km`;
  }
};

/**
 * Get approximate walking time between two points
 * @param lat1 Latitude of point 1
 * @param lon1 Longitude of point 1
 * @param lat2 Latitude of point 2
 * @param lon2 Longitude of point 2
 * @returns Walking time in minutes
 */
export const getWalkingTime = (
  lat1: number,
  lon1: number,
  lat2: number,
  lon2: number
): number => {
  const distance = getDistance(lat1, lon1, lat2, lon2);
  // Average walking speed is about 5 km/h = 83.33 m/min
  const walkingSpeedMeterPerMin = 83.33;
  
  return Math.round(distance / walkingSpeedMeterPerMin);
};

/**
 * Get formatted walking time string
 * @param lat1 Latitude of point 1
 * @param lon1 Longitude of point 1
 * @param lat2 Latitude of point 2
 * @param lon2 Longitude of point 2
 * @returns Formatted walking time string (e.g., "5 min walk")
 */
export const getWalkingTimeString = (
  lat1: number,
  lon1: number,
  lat2: number,
  lon2: number
): string => {
  const walkingTime = getWalkingTime(lat1, lon1, lat2, lon2);
  
  return `${walkingTime} min walk`;
};


--- File: packages/mobile/src/utils/imageUtils.ts ---
import { Venue, VenuePhoto } from 'core/src/models/venue';

/**
 * Utility functions for handling images throughout the app
 */

/**
 * Default fallback image for venues without photos
 */
export const DEFAULT_VENUE_IMAGE = 'https://via.placeholder.com/400x300?text=No+Image+Available';

/**
 * Get the best venue image URL
 * @param venue The venue object
 * @param width Desired image width
 * @param height Desired image height
 * @returns URL of the best suitable image
 */
export const getVenueImage = (
  venue?: Venue | null,
  width: number = 300, 
  height: number = 200
): string => {
  if (!venue || !venue.photos || venue.photos.length === 0) {
    return DEFAULT_VENUE_IMAGE;
  }

  // Use the first photo
  const photo = venue.photos[0];
  return constructPhotoUrl(photo, width, height);
};

/**
 * Get all venue images
 * @param venue The venue object
 * @param width Desired image width
 * @param height Desired image height
 * @returns Array of image URLs
 */
export const getVenueImages = (
  venue?: Venue | null,
  width: number = 300,
  height: number = 200
): string[] => {
  if (!venue || !venue.photos || venue.photos.length === 0) {
    return [DEFAULT_VENUE_IMAGE];
  }

  return venue.photos.map(photo => constructPhotoUrl(photo, width, height));
};

/**
 * Construct a photo URL from Foursquare photo object
 * @param photo The photo object
 * @param width Desired image width
 * @param height Desired image height
 * @returns Constructed image URL
 */
export const constructPhotoUrl = (
  photo: VenuePhoto,
  width: number = 300,
  height: number = 200
): string => {
  return `${photo.prefix}${width}x${height}${photo.suffix}`;
};

/**
 * Get a category icon URL
 * @param category The category object
 * @param size Desired icon size
 * @returns Category icon URL
 */
export const getCategoryIcon = (
  category: { icon?: { prefix?: string; suffix?: string } },
  size: number = 64
): string | undefined => {
  if (!category.icon || !category.icon.prefix || !category.icon.suffix) {
    return undefined;
  }

  return `${category.icon.prefix}${size}${category.icon.suffix}`;
};

/**
 * Get a placeholder image with custom text
 * @param text Custom text for the placeholder
 * @param width Image width
 * @param height Image height
 * @returns Placeholder image URL
 */
export const getPlaceholderImage = (
  text: string = 'No Image',
  width: number = 300,
  height: number = 200
): string => {
  const encodedText = encodeURIComponent(text);
  return `https://via.placeholder.com/${width}x${height}?text=${encodedText}`;
};

/**
 * Convert a photo URL to a lower resolution for thumbnails
 * @param url Original image URL
 * @param size Desired thumbnail size
 * @returns Thumbnail URL
 */
export const getThumbnailUrl = (url: string, size: number = 100): string => {
  // If it's a placeholder, adjust the dimensions
  if (url.includes('via.placeholder.com')) {
    return url.replace(/(\d+)x(\d+)/, `${size}x${size}`);
  }

  // For Foursquare photos, construct a new URL with smaller dimensions
  if (url.includes('.foursquare.com')) {
    // Extract prefix and suffix
    const match = url.match(/(.+)(\d+)x(\d+)(.+)/);
    if (match) {
      const [, prefix, , , suffix] = match;
      return `${prefix}${size}x${size}${suffix}`;
    }
  }

  // Return original URL if we can't create a thumbnail
  return url;
};


--- File: packages/mobile/theme/categories.ts ---
  export const categories = [
    {
      id: '13065',
      name: 'Restaurant',
      icon: 'restaurant',
      color: theme.lightColors.primary,
    },
    {
      id: '13034',
      name: 'Cafe',
      icon: 'local-cafe',
      color: '#8D6E63',
    },
    {
      id: '13003',
      name: 'Bar',
      icon: 'local-bar',
      color: '#7B1FA2',
    },
    {
      id: '13145',
      name: 'Fast Food',
      icon: 'fastfood',
      color: '#F57C00',
    },
    {
      id: '13350',
      name: 'Pizza',
      icon: 'local-pizza',
      color: '#D32F2F',
    },
    {
      id: '13274',
      name: 'Breakfast',
      icon: 'free-breakfast',
      color: '#FFA000',
    },
    {
      id: '13065',
      name: 'Dessert',
      icon: 'cake',
      color: '#FBC02D',
    },
    {
      id: '13065',
      name: 'Ice Cream',
      icon: 'icecream',
      color: '#FFB74D',
    },
    {
      id: '13065',
      name: 'Bakery',
      icon: 'bakery_dining',
      color: '#FF7043',
    }]



--- File: packages/mobile/theme/index.ts ---
/**
 * Theme colors and styles for the app
 */
export const theme = {
  colors: {
    primary: '#FF5A5F', // Airbnb-inspired red
    primaryDark: '#E04146',
    primaryLight: '#FF8A8F',
    secondary: '#00A699', // Teal
    background: '#FFFFFF',
    backgroundDark: '#121212',
    surface: '#FFFFFF',
    surfaceDark: '#1E1E1E',
    error: '#F44336',
    warning: '#FF9800',
    success: '#4CAF50',
    info: '#2196F3',
    
    // Gray scale
    grey1: '#212121',
    grey2: '#424242',
    grey3: '#757575',
    grey4: '#BDBDBD',
    grey5: '#E0E0E0',
    grey6: '#F5F5F5',
    
    // Text colors
    text: '#212121',
    textSecondary: '#757575',
    textDark: '#FFFFFF',
    textSecondaryDark: '#BDBDBD',
  },
  
  // Typography
  typography: {
    h1: {
      fontSize: 32,
      fontWeight: 'bold',
    },
    h2: {
      fontSize: 24,
      fontWeight: 'bold',
    },
    body1: {
      fontSize: 16,
    },
    body2: {
      fontSize: 14,
    },
  },
  
  // Spacing
  spacing: {
    xs: 4,
    sm: 8,
    md: 16,
    lg: 24,
    xl: 32,
  },
  
  // Radius
  radius: {
    sm: 4,
    md: 8,
    lg: 16,
    round: 9999,
  },
};

/**
 * Get theme based on mode
 * @param mode 'light' or 'dark'
 */
export const getTheme = (mode: 'light' | 'dark') => {
  const baseTheme = { ...theme };
  
  if (mode === 'dark') {
    return {
      ...baseTheme,
      colors: {
        ...baseTheme.colors,
        background: baseTheme.colors.backgroundDark,
        surface: baseTheme.colors.surfaceDark,
        text: baseTheme.colors.textDark,
        textSecondary: baseTheme.colors.textSecondaryDark,
      },
    };
  }
  
  return baseTheme;
};


--- File: packages/mobile/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "jsx": "react-native",
    "lib": ["es2019", "dom"],
    "moduleResolution": "node",
    "noEmit": true,
    "resolveJsonModule": true,
    "skipLibCheck": true,
    "target": "esnext",
    "allowSyntheticDefaultImports": true,
    "baseUrl": ".",
    "paths": {
      "core/*": ["../core/src/*"]
    },
    "types": ["react-native"]
  },
  "include": ["src/**/*", "App.tsx"],
  "exclude": [
    "node_modules",
    "babel.config.js",
    "metro.config.js",
    "jest.config.js",
    "**/*.spec.ts",
    "**/*.test.ts"
  ]
}


--- File: packages/web/package.json ---
{
  "name": "web",
  "version": "1.0.0",
  "description": "React web app for Restaurant Bucket List",
  "private": true,
  "dependencies": {
    "@emotion/react": "^11.10.8",
    "@emotion/styled": "^11.10.8",
    "@mui/icons-material": "^5.11.16",
    "@mui/material": "^5.12.3",
    "core": "1.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-redux": "^8.0.5",
    "react-router-dom": "^6.11.0",
    "react-scripts": "5.0.1"
  },
  "devDependencies": {
    "@testing-library/jest-dom": "^5.16.5",
    "@testing-library/react": "^14.0.0",
    "@testing-library/user-event": "^14.4.3",
    "@types/jest": "^29.5.1",
    "@types/node": "^18.16.3",
    "@types/react": "^18.2.0",
    "@types/react-dom": "^18.2.1",
    "rimraf": "^5.0.0",
    "typescript": "^5.0.4",
    "web-vitals": "^3.3.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject",
    "clean": "rimraf ./build",
    "lint": "eslint . --ext .js,.jsx,.ts,.tsx"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}


--- File: packages/web/src/App.tsx ---
import React from 'react';
import { BrowserRouter as Router, Routes, Route } from 'react-router-dom';
import { useAppSelector } from 'core/src';
import HomePage from './components/pages/HomePage';

function App() {
  const theme = useAppSelector(state => state.ui.theme);
  
  return (
    <div className={`app ${theme}`}>
      <Router>
        <Routes>
          <Route path="/" element={<HomePage />} />
          {/* Add more routes as needed */}
        </Routes>
      </Router>
    </div>
  );
}

export default App;


--- File: packages/web/src/components/pages/HomePage.tsx ---
import React from 'react';

const HomePage: React.FC = () => {
  return (
    <div style={{ padding: '2rem', textAlign: 'center' }}>
      <h1>Restaurant Bucket List</h1>
      <p>
        Welcome to the Restaurant Bucket List web application. This is a stub component that will be
        replaced with the actual implementation.
      </p>
    </div>
  );
};

export default HomePage;


--- File: packages/web/src/index.tsx ---
import React from 'react';
import ReactDOM from 'react-dom/client';
import { Provider } from 'react-redux';
import { PersistGate } from 'redux-persist/integration/react';
import { store, persistor } from 'core/src/store';
import App from './App';

const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(
  <React.StrictMode>
    <Provider store={store}>
      <PersistGate loading={null} persistor={persistor}>
        <App />
      </PersistGate>
    </Provider>
  </React.StrictMode>
);


--- File: packages/web/tsconfig.json ---
{
  "extends": "../../tsconfig.json",
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noFallthroughCasesInSwitch": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "paths": {
      "core/*": ["../core/src/*"]
    }
  },
  "include": ["src"],
  "exclude": ["node_modules", "**/*.spec.ts", "**/*.test.ts"]
}


--- File: tsconfig.json ---
{
  "compilerOptions": {
    "target": "es2016",
    "module": "esnext",
    "moduleResolution": "node",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true,
    "jsx": "react-jsx",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "allowSyntheticDefaultImports": true,
    "noFallthroughCasesInSwitch": true,
    "baseUrl": ".",
    "paths": {
      "core/*": ["packages/core/*"]
    }
  },
  "exclude": ["node_modules", "**/*.spec.ts", "**/*.test.ts"],
  "references": [
    { "path": "./packages/core" },
    { "path": "./packages/mobile" },
    { "path": "./packages/web" }
  ]
}

